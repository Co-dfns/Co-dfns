#include "codfns.h"
#include "prim.h"

EXPORT int
DyalogGetInterpreterFunctions(void *p)
{
    return set_dwafns(p);
}

extern struct cell_func *cdf_q_signal_ibeam;
extern struct cell_func *cdf_q_dr_ibeam;
extern struct cell_array *cdf_span_array;
extern struct cell_doper *cdf_eq_ibeam;
extern struct cell_func *cdf_squeeze_ibeam;
extern struct cell_func *cdf_is_simple_ibeam;
extern struct cell_func *cdf_is_numeric_ibeam;
extern struct cell_func *cdf_is_char_ibeam;
extern struct cell_func *cdf_is_integer_ibeam;
extern struct cell_func *cdf_is_span_ibeam;
extern struct cell_func *cdf_max_shp_ibeam;
extern struct cell_func *cdf_max_shp_ibeam;
extern struct cell_func *cdf_has_nat_vals_ibeam;
extern struct cell_func *cdf_any_ibeam;
extern struct cell_moper *cdf_veach_ibeam;
extern struct cell_func *cdf_reshape_ibeam;
extern struct cell_func *cdf_reshape_ibeam;
extern struct cell_func *cdf_shape_ibeam;
extern struct cell_func *cdf_set_ibeam;
extern struct cell_moper *cdf_mst_ibeam;
extern struct cell_func *cdf_index_ibeam;
extern struct cell_func *cdf_index_ibeam;
extern struct cell_func *cdf_index_ibeam;
extern struct cell_func *cdf_index_ibeam;
extern struct cell_func *cdf_ravel_ibeam;
extern struct cell_func *cdf_ravel_ibeam;
extern struct cell_func *cdf_ravel_ibeam;
extern struct cell_func *cdf_ravel_ibeam;
extern struct cell_func *cdf_same_ibeam;
extern struct cell_func *cdf_nqv_ibeam;
extern struct cell_func *cdf_index_gen_vec;
extern struct cell_func *cdf_index_gen_vec;
extern struct cell_func *cdf_disclose_ibeam;
extern struct cell_func *cdf_enclose_ibeam;
extern struct cell_func *cdf_enclose_ibeam;
extern struct cell_func *cdf_conjugate_vec_ibeam;
extern struct cell_func *cdf_conjugate_vec_ibeam;
extern struct cell_func *cdf_add_vec_ibeam;
extern struct cell_func *cdf_sub_vec_ibeam;
extern struct cell_func *cdf_mul_vec_ibeam;
extern struct cell_func *cdf_div_vec_ibeam;
extern struct cell_func *cdf_abs_vec_ibeam;
extern struct cell_func *cdf_abs_vec_ibeam;
extern struct cell_func *cdf_floor_vec_ibeam;
extern struct cell_func *cdf_floor_vec_ibeam;
extern struct cell_func *cdf_min_vec_ibeam;
extern struct cell_func *cdf_ceil_vec_ibeam;
extern struct cell_func *cdf_ceil_vec_ibeam;
extern struct cell_func *cdf_max_vec_ibeam;
extern struct cell_func *cdf_pow_vec_ibeam;
extern struct cell_func *cdf_exp_vec_ibeam;
extern struct cell_func *cdf_log_vec_ibeam;
extern struct cell_func *cdf_nlg_vec_ibeam;
extern struct cell_func *cdf_sin_vec_ibeam;
extern struct cell_func *cdf_arcsin_vec_ibeam;
extern struct cell_func *cdf_cos_vec_ibeam;
extern struct cell_func *cdf_arccos_vec_ibeam;
extern struct cell_func *cdf_tan_vec_ibeam;
extern struct cell_func *cdf_arctan_vec_ibeam;
extern struct cell_func *cdf_sinh_vec_ibeam;
extern struct cell_func *cdf_arcsinh_vec_ibeam;
extern struct cell_func *cdf_cosh_vec_ibeam;
extern struct cell_func *cdf_arccosh_vec_ibeam;
extern struct cell_func *cdf_tanh_vec_ibeam;
extern struct cell_func *cdf_arctanh_vec_ibeam;
extern struct cell_func *cdf_realpart_vec_ibeam;
extern struct cell_func *cdf_realpart_vec_ibeam;
extern struct cell_func *cdf_imagpart_vec_ibeam;
extern struct cell_func *cdf_imagpart_vec_ibeam;
extern struct cell_func *cdf_sin_vec_ibeam;
extern struct cell_func *cdf_arcsin_vec_ibeam;
extern struct cell_func *cdf_cos_vec_ibeam;
extern struct cell_func *cdf_arccos_vec_ibeam;
extern struct cell_func *cdf_tan_vec_ibeam;
extern struct cell_func *cdf_arctan_vec_ibeam;
extern struct cell_func *cdf_sinh_vec_ibeam;
extern struct cell_func *cdf_arcsinh_vec_ibeam;
extern struct cell_func *cdf_cosh_vec_ibeam;
extern struct cell_func *cdf_arccosh_vec_ibeam;
extern struct cell_func *cdf_tanh_vec_ibeam;
extern struct cell_func *cdf_arctanh_vec_ibeam;
extern struct cell_func *cdf_realpart_vec_ibeam;
extern struct cell_func *cdf_realpart_vec_ibeam;
extern struct cell_func *cdf_imagpart_vec_ibeam;
extern struct cell_func *cdf_imagpart_vec_ibeam;
extern struct cell_func *cdf_factorial_vec_ibeam;
extern struct cell_func *cdf_not_vec_ibeam;
extern struct cell_func *cdf_not_vec_ibeam;
extern struct cell_func *cdf_and_vec_ibeam;
extern struct cell_func *cdf_and_vec_ibeam;
extern struct cell_func *cdf_lor_vec_ibeam;
extern struct cell_func *cdf_lor_vec_ibeam;
extern struct cell_func *cdf_lth_vec_ibeam;
extern struct cell_func *cdf_lth_vec_ibeam;
extern struct cell_func *cdf_lte_vec_ibeam;
extern struct cell_func *cdf_lte_vec_ibeam;
extern struct cell_func *cdf_eql_vec_ibeam;
extern struct cell_func *cdf_gte_vec_ibeam;
extern struct cell_func *cdf_gte_vec_ibeam;
extern struct cell_func *cdf_gth_vec_ibeam;
extern struct cell_func *cdf_gth_vec_ibeam;
extern struct cell_func *cdf_neq_vec_ibeam;
extern struct cell_func *cdf_roll_ibeam;
extern struct cell_func *cdf_roll_ibeam;

int cdf_ptr13519(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13520(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13521(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13522(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13523(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13524(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13525(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13526(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13527(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13528(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13529(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13530(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13531(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13532(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13533(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13534(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13535(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13536(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13537(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13538(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13539(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13540(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13541(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13542(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13543(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13544(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13545(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13546(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13547(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13548(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13549(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13550(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13551(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13552(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13553(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13554(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13555(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13556(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13557(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13558(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13559(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13560(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13561(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13562(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13563(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13564(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13565(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13566(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13567(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13568(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13569(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13570(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13571(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13572(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13573(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13574(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13575(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13576(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13577(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13578(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13579(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13580(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13581(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13582(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13583(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13584(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13585(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13586(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13587(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13588(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13589(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13590(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13591(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13592(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13593(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13594(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13595(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13596(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13597(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13598(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13599(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13600(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13601(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13602(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13603(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13604(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13605(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13606(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13607(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13608(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13609(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13610(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13611(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13612(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13613(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13614(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13615(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13616(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13617(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13618(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13619(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13620(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13621(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13622(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13623(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13624(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13625(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13626(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13627(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13628(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13629(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13630(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13631(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13632(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13633(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13634(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13635(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13636(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13637(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13638(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13639(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13640(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13641(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13642(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13643(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13644(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13645(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13646(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13647(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13648(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13649(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13650(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13651(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13652(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13653(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13654(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13655(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13656(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13657(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13658(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13659(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13660(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13661(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13662(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13663(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13664(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13665(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13666(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13667(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13668(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13669(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13670(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13671(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13672(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13673(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13674(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13675(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13676(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13677(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13678(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13679(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13680(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13681(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13682(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13683(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13684(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13685(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13686(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13687(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13688(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13689(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13690(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13691(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13692(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13693(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13694(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13695(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13696(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13697(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13698(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13699(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13700(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13701(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13702(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13703(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13704(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13705(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13706(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13707(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13708(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13709(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13710(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13711(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13712(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13713(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13714(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13715(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13716(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13717(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13718(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13719(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13720(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13721(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13722(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13723(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13724(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13725(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13726(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13727(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13728(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13729(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13730(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13731(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13732(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13733(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13734(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13735(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13736(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13737(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13738(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13739(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13740(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13741(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13742(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13743(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13744(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13745(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13746(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13747(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13748(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13749(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13750(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13751(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13752(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13753(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13754(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13755(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13756(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13757(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13758(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13759(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13760(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13761(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13762(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13763(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13764(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13765(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13766(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13767(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13768(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13769(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13770(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13771(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13772(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13773(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13774(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13775(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13776(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13777(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13778(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13779(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13780(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13781(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13782(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13783(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13784(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13785(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13786(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13787(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13788(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13789(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13790(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13791(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13792(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13793(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13794(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13795(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13796(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13797(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13798(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13799(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13800(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13801(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13802(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13803(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13804(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13805(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13806(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13807(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13808(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13809(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13810(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13811(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13812(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13813(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13814(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13815(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13816(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13817(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13818(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13819(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13820(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13821(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13822(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13823(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13824(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13825(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13826(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13827(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13828(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13829(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13830(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13831(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13832(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13833(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13834(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13835(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13836(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13837(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13838(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13839(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13840(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13841(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13842(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13843(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13844(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13845(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13846(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13847(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13848(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13849(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13850(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13851(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13852(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13853(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13854(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13855(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13856(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13857(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13858(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13859(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13860(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13861(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13862(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13863(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13864(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13865(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13866(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13867(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13868(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13869(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13870(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13871(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13872(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13873(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13874(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13875(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13876(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13877(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13878(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13879(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13880(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13881(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13882(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13883(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13884(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13885(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13886(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13887(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13888(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13889(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13890(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13891(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13892(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13893(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13894(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13895(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13896(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13897(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13898(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13899(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13900(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13901(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13902(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13903(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13904(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13905(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13906(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13907(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13908(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13909(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13910(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13911(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13912(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13913(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13914(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13915(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13916(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13917(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13918(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13919(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13920(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13921(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13922(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13923(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13924(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13925(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13926(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13927(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13928(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13929(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13930(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13931(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13932(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13933(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13934(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13935(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13936(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13937(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13938(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13939(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13940(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13941(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13942(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13943(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13944(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13945(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13946(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13947(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13948(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13949(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int cdf_ptr13950(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);

int cdf_prim_flag = 0;

wchar_t *cdf_prim_names[] = {L"q_signal", L"q_dr", L"spn", L"eq", L"squeeze", L"is_simple", L"is_numeric", L"is_char", L"is_integer", L"is_bool", L"is_span", L"max_shp", L"has_nat_vals", L"chk_scl", L"both_simple", L"both_numeric", L"both_integer", L"both_char", L"both_bool", L"any", L"numeric", L"ambiv", L"same", L"veach", L"scalar", L"chk_valid_shape", L"reshape", L"rho", L"idx_rnk_check", L"idx_rng_check", L"flatten_idx", L"idx_shp_check", L"set_get_idx", L"set", L"mst_vals", L"mst", L"sqd", L"brk", L"rgt", L"lft", L"cat", L"ctf", L"depth", L"eqv", L"nqv", L"index_gen", L"index_of", L"iot", L"dis", L"enclose", L"par", L"conjugate", L"add", L"sub", L"sign", L"mul", L"div", L"absolute", L"residue", L"res", L"floor_array", L"min", L"ceil_array", L"max", L"exp", L"log", L"pitimes", L"trig", L"cir", L"binomial", L"fac", L"notscl", L"without", L"not", L"logand", L"and", L"logor", L"lor", L"nan", L"nor", L"lessthan", L"lth", L"lesseql", L"lte", L"eql_vec", L"equal", L"eql", L"greatereql", L"gte", L"greaterthan", L"gth", L"firstocc", L"neq_vec", L"noteq", L"neq", L"mix", L"take", L"tke", L"drp", L"rtf", L"reverse_last", L"rotate_last", L"rot", L"trn", L"gdu", L"gdd", L"enc", L"dec", L"mem", L"fnd", L"unq", L"int", L"deal", L"roll", L"rol", L"mdv", L"com", L"map", L"identity", L"reduce", L"nwreduce", L"red_check", L"rdf", L"red", L"rpf", L"rep", L"scf", L"scn", L"xpf", L"xpd", L"dot", L"oup", L"pow", L"jot", L"rnk", L"key"};

EXPORT int
cdf_prim_init(void)
{
	struct cdf_prim_loc *loc;
	void *stk[128];
	void **stkhd;
	int err;

	if (cdf_prim_flag)
		return 0;

	err = 0;
	cdf_prim_flag = 1;
	stkhd = &stk[0];
	loc = &cdf_prim;
	loc->__count = 136;
	loc->__names = cdf_prim_names;

	if (debug_info)
		release_array(debug_info);

	debug_info = NULL;

	CHKFN(cdf_prim_init(), cleanup);

	loc->cdf_q_signal = NULL;
	loc->cdf_q_dr = NULL;
	loc->cdf_spn = NULL;
	CHK(mk_doper_box(&loc->cdf_eq, NULL), cleanup, L"Init mutable variable: loc->cdf_eq");
	CHK(mk_func_box(&loc->cdf_squeeze, NULL), cleanup, L"Init mutable variable: loc->cdf_squeeze");
	CHK(mk_func_box(&loc->cdf_is_simple, NULL), cleanup, L"Init mutable variable: loc->cdf_is_simple");
	CHK(mk_func_box(&loc->cdf_is_numeric, NULL), cleanup, L"Init mutable variable: loc->cdf_is_numeric");
	CHK(mk_func_box(&loc->cdf_is_char, NULL), cleanup, L"Init mutable variable: loc->cdf_is_char");
	CHK(mk_func_box(&loc->cdf_is_integer, NULL), cleanup, L"Init mutable variable: loc->cdf_is_integer");
	CHK(mk_func_box(&loc->cdf_is_bool, NULL), cleanup, L"Init mutable variable: loc->cdf_is_bool");
	CHK(mk_func_box(&loc->cdf_is_span, NULL), cleanup, L"Init mutable variable: loc->cdf_is_span");
	CHK(mk_func_box(&loc->cdf_max_shp, NULL), cleanup, L"Init mutable variable: loc->cdf_max_shp");
	CHK(mk_func_box(&loc->cdf_has_nat_vals, NULL), cleanup, L"Init mutable variable: loc->cdf_has_nat_vals");
	CHK(mk_func_box(&loc->cdf_chk_scl, NULL), cleanup, L"Init mutable variable: loc->cdf_chk_scl");
	CHK(mk_func_box(&loc->cdf_both_simple, NULL), cleanup, L"Init mutable variable: loc->cdf_both_simple");
	CHK(mk_func_box(&loc->cdf_both_numeric, NULL), cleanup, L"Init mutable variable: loc->cdf_both_numeric");
	CHK(mk_func_box(&loc->cdf_both_integer, NULL), cleanup, L"Init mutable variable: loc->cdf_both_integer");
	CHK(mk_func_box(&loc->cdf_both_char, NULL), cleanup, L"Init mutable variable: loc->cdf_both_char");
	CHK(mk_func_box(&loc->cdf_both_bool, NULL), cleanup, L"Init mutable variable: loc->cdf_both_bool");
	CHK(mk_func_box(&loc->cdf_any, NULL), cleanup, L"Init mutable variable: loc->cdf_any");
	loc->cdf_numeric = NULL;
	loc->cdf_ambiv = NULL;
	CHK(mk_func_box(&loc->cdf_same, NULL), cleanup, L"Init mutable variable: loc->cdf_same");
	CHK(mk_moper_box(&loc->cdf_veach, NULL), cleanup, L"Init mutable variable: loc->cdf_veach");
	loc->cdf_scalar = NULL;
	CHK(mk_func_box(&loc->cdf_chk_valid_shape, NULL), cleanup, L"Init mutable variable: loc->cdf_chk_valid_shape");
	loc->cdf_reshape = NULL;
	loc->cdf_rho = NULL;
	CHK(mk_func_box(&loc->cdf_idx_rnk_check, NULL), cleanup, L"Init mutable variable: loc->cdf_idx_rnk_check");
	CHK(mk_func_box(&loc->cdf_idx_rng_check, NULL), cleanup, L"Init mutable variable: loc->cdf_idx_rng_check");
	CHK(mk_func_box(&loc->cdf_flatten_idx, NULL), cleanup, L"Init mutable variable: loc->cdf_flatten_idx");
	CHK(mk_func_box(&loc->cdf_idx_shp_check, NULL), cleanup, L"Init mutable variable: loc->cdf_idx_shp_check");
	CHK(mk_moper_box(&loc->cdf_set_get_idx, NULL), cleanup, L"Init mutable variable: loc->cdf_set_get_idx");
	loc->cdf_set = NULL;
	loc->cdf_mst_vals = NULL;
	loc->cdf_mst = NULL;
	loc->cdf_sqd = NULL;
	loc->cdf_brk = NULL;
	loc->cdf_rgt = NULL;
	loc->cdf_lft = NULL;
	loc->cdf_cat = NULL;
	loc->cdf_ctf = NULL;
	loc->cdf_depth = NULL;
	loc->cdf_eqv = NULL;
	loc->cdf_nqv = NULL;
	loc->cdf_index_gen = NULL;
	loc->cdf_index_of = NULL;
	loc->cdf_iot = NULL;
	loc->cdf_dis = NULL;
	loc->cdf_enclose = NULL;
	loc->cdf_par = NULL;
	loc->cdf_conjugate = NULL;
	loc->cdf_add = NULL;
	loc->cdf_sub = NULL;
	loc->cdf_sign = NULL;
	loc->cdf_mul = NULL;
	loc->cdf_div = NULL;
	loc->cdf_absolute = NULL;
	loc->cdf_residue = NULL;
	loc->cdf_res = NULL;
	loc->cdf_floor_array = NULL;
	loc->cdf_min = NULL;
	loc->cdf_ceil_array = NULL;
	loc->cdf_max = NULL;
	loc->cdf_exp = NULL;
	loc->cdf_log = NULL;
	loc->cdf_pitimes = NULL;
	loc->cdf_trig = NULL;
	loc->cdf_cir = NULL;
	loc->cdf_binomial = NULL;
	loc->cdf_fac = NULL;
	loc->cdf_notscl = NULL;
	loc->cdf_without = NULL;
	loc->cdf_not = NULL;
	loc->cdf_logand = NULL;
	loc->cdf_and = NULL;
	loc->cdf_logor = NULL;
	loc->cdf_lor = NULL;
	loc->cdf_nan = NULL;
	loc->cdf_nor = NULL;
	loc->cdf_lessthan = NULL;
	loc->cdf_lth = NULL;
	loc->cdf_lesseql = NULL;
	loc->cdf_lte = NULL;
	CHK(mk_func_box(&loc->cdf_eql_vec, NULL), cleanup, L"Init mutable variable: loc->cdf_eql_vec");
	loc->cdf_equal = NULL;
	loc->cdf_eql = NULL;
	loc->cdf_greatereql = NULL;
	loc->cdf_gte = NULL;
	loc->cdf_greaterthan = NULL;
	loc->cdf_gth = NULL;
	loc->cdf_firstocc = NULL;
	CHK(mk_func_box(&loc->cdf_neq_vec, NULL), cleanup, L"Init mutable variable: loc->cdf_neq_vec");
	loc->cdf_noteq = NULL;
	loc->cdf_neq = NULL;
	loc->cdf_mix = NULL;
	loc->cdf_take = NULL;
	loc->cdf_tke = NULL;
	loc->cdf_drp = NULL;
	loc->cdf_rtf = NULL;
	loc->cdf_reverse_last = NULL;
	loc->cdf_rotate_last = NULL;
	loc->cdf_rot = NULL;
	loc->cdf_trn = NULL;
	loc->cdf_gdu = NULL;
	loc->cdf_gdd = NULL;
	loc->cdf_enc = NULL;
	loc->cdf_dec = NULL;
	loc->cdf_mem = NULL;
	loc->cdf_fnd = NULL;
	loc->cdf_unq = NULL;
	loc->cdf_int = NULL;
	loc->cdf_deal = NULL;
	loc->cdf_roll = NULL;
	loc->cdf_rol = NULL;
	loc->cdf_mdv = NULL;
	loc->cdf_com = NULL;
	loc->cdf_map = NULL;
	CHK(mk_moper_box(&loc->cdf_identity, NULL), cleanup, L"Init mutable variable: loc->cdf_identity");
	CHK(mk_doper_box(&loc->cdf_reduce, NULL), cleanup, L"Init mutable variable: loc->cdf_reduce");
	CHK(mk_doper_box(&loc->cdf_nwreduce, NULL), cleanup, L"Init mutable variable: loc->cdf_nwreduce");
	CHK(mk_func_box(&loc->cdf_red_check, NULL), cleanup, L"Init mutable variable: loc->cdf_red_check");
	loc->cdf_rdf = NULL;
	loc->cdf_red = NULL;
	loc->cdf_rpf = NULL;
	loc->cdf_rep = NULL;
	loc->cdf_scf = NULL;
	loc->cdf_scn = NULL;
	loc->cdf_xpf = NULL;
	loc->cdf_xpd = NULL;
	loc->cdf_dot = NULL;
	loc->cdf_oup = NULL;
	loc->cdf_pow = NULL;
	loc->cdf_jot = NULL;
	loc->cdf_rnk = NULL;
	loc->cdf_key = NULL;

	if (!cdf_q_signal_ibeam)
		CHK(6, cleanup, L"[4] q_signal'q_signal_ibeam'");
	
	*stkhd++ = retain_cell(cdf_q_signal_ibeam);
	
	release_cell(loc->cdf_q_signal);
	loc->cdf_q_signal = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_q_dr_ibeam)
		CHK(6, cleanup, L"[5] q_dr'q_dr_ibeam'");
	
	*stkhd++ = retain_cell(cdf_q_dr_ibeam);
	
	release_cell(loc->cdf_q_dr);
	loc->cdf_q_dr = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_span_array)
		CHK(6, cleanup, L"[8] spn'span_array'");
	
	*stkhd++ = retain_cell(cdf_span_array);
	
	release_cell(loc->cdf_spn);
	loc->cdf_spn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_eq_ibeam)
		CHK(6, cleanup, L"[11] eq'eq_ibeam'");
	
	*stkhd++ = retain_cell(cdf_eq_ibeam);
	
	release_cell(loc->cdf_eq->value);
	loc->cdf_eq->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_squeeze_ibeam)
		CHK(6, cleanup, L"[12] squeeze'squeeze_ibeam'");
	
	*stkhd++ = retain_cell(cdf_squeeze_ibeam);
	
	release_cell(loc->cdf_squeeze->value);
	loc->cdf_squeeze->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_is_simple_ibeam)
		CHK(6, cleanup, L"[13] is_simple'is_simple_ibeam'");
	
	*stkhd++ = retain_cell(cdf_is_simple_ibeam);
	
	release_cell(loc->cdf_is_simple->value);
	loc->cdf_is_simple->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_is_numeric_ibeam)
		CHK(6, cleanup, L"[14] is_numeric'is_numeric_ibeam'");
	
	*stkhd++ = retain_cell(cdf_is_numeric_ibeam);
	
	release_cell(loc->cdf_is_numeric->value);
	loc->cdf_is_numeric->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_is_char_ibeam)
		CHK(6, cleanup, L"[15] is_char'is_char_ibeam'");
	
	*stkhd++ = retain_cell(cdf_is_char_ibeam);
	
	release_cell(loc->cdf_is_char->value);
	loc->cdf_is_char->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_is_integer_ibeam)
		CHK(6, cleanup, L"[16] is_integer'is_integer_ibeam'");
	
	*stkhd++ = retain_cell(cdf_is_integer_ibeam);
	
	release_cell(loc->cdf_is_integer->value);
	loc->cdf_is_integer->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13519, cdf_ptr13520, 1), cleanup, 
		    L"[17] is_bool{11DR squeeze }");
	
		k->fv[0] = retain_cell(loc->cdf_squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_is_bool->value);
	loc->cdf_is_bool->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_is_span_ibeam)
		CHK(6, cleanup, L"[18] is_span'is_span_ibeam'");
	
	*stkhd++ = retain_cell(cdf_is_span_ibeam);
	
	release_cell(loc->cdf_is_span->value);
	loc->cdf_is_span->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13521, cdf_ptr13522, 0), cleanup, 
		    L"[19] max_shp{0  ('max_shp_ibeam')}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_max_shp->value);
	loc->cdf_max_shp->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_has_nat_vals_ibeam)
		CHK(6, cleanup, L"[20] has_nat_vals'has_nat_vals_ibeam'");
	
	*stkhd++ = retain_cell(cdf_has_nat_vals_ibeam);
	
	release_cell(loc->cdf_has_nat_vals->value);
	loc->cdf_has_nat_vals->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13523, cdf_ptr13524, 0), cleanup, 
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_chk_scl->value);
	loc->cdf_chk_scl->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13525, cdf_ptr13526, 1), cleanup, 
		    L"[22] both_simple{is_simple :is_simple   0}");
	
		k->fv[0] = retain_cell(loc->cdf_is_simple);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_both_simple->value);
	loc->cdf_both_simple->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13527, cdf_ptr13528, 1), cleanup, 
		    L"[23] both_numeric{is_numeric :is_numeric   0}");
	
		k->fv[0] = retain_cell(loc->cdf_is_numeric);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_both_numeric->value);
	loc->cdf_both_numeric->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13529, cdf_ptr13530, 1), cleanup, 
		    L"[24] both_integer{is_integer :is_integer   0}");
	
		k->fv[0] = retain_cell(loc->cdf_is_integer);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_both_integer->value);
	loc->cdf_both_integer->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13531, cdf_ptr13532, 1), cleanup, 
		    L"[25] both_char{is_char :is_char   0}");
	
		k->fv[0] = retain_cell(loc->cdf_is_char);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_both_char->value);
	loc->cdf_both_char->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13533, cdf_ptr13534, 1), cleanup, 
		    L"[26] both_bool{is_bool :is_bool   0}");
	
		k->fv[0] = retain_cell(loc->cdf_is_bool);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_both_bool->value);
	loc->cdf_both_bool->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_any_ibeam)
		CHK(6, cleanup, L"[27] any'any_ibeam'");
	
	*stkhd++ = retain_cell(cdf_any_ibeam);
	
	release_cell(loc->cdf_any->value);
	loc->cdf_any->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, cdf_ptr13535, cdf_ptr13536, cdf_ptr13537, cdf_ptr13538, 1), cleanup, 
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		k->fv[0] = retain_cell(loc->cdf_both_numeric);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_numeric);
	loc->cdf_numeric = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, cdf_ptr13539, cdf_ptr13540, cdf_ptr13541, cdf_ptr13542, cdf_ptr13543, cdf_ptr13544, cdf_ptr13545, cdf_ptr13546, 1), cleanup, 
		    L"[29] ambiv{  1 same  1:     }");
	
		k->fv[0] = retain_cell(loc->cdf_same);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_ambiv);
	loc->cdf_ambiv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_veach_ibeam)
		CHK(6, cleanup, L"[30] veach'veach_ibeam'");
	
	*stkhd++ = retain_cell(cdf_veach_ibeam);
	
	release_cell(loc->cdf_veach->value);
	loc->cdf_veach->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, cdf_ptr13547, cdf_ptr13548, cdf_ptr13549, cdf_ptr13550, 5), cleanup, 
		    L"[31] scalar{");
	
		k->fv[0] = retain_cell(loc->cdf_veach);
		k->fv[1] = retain_cell(loc->cdf_both_simple);
		k->fv[2] = retain_cell(loc->cdf_chk_scl);
		k->fv[3] = retain_cell(loc->cdf_max_shp);
		k->fv[4] = retain_cell(loc->cdf_squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_scalar);
	loc->cdf_scalar = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13551, cdf_ptr13556, 1), cleanup, 
		    L"[41] chk_valid_shape{");
	
		k->fv[0] = retain_cell(loc->cdf_has_nat_vals);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_chk_valid_shape->value);
	loc->cdf_chk_valid_shape->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13561, cdf_ptr13562, 1), cleanup, 
		    L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
		k->fv[0] = retain_cell(loc->cdf_chk_valid_shape);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_reshape);
	loc->cdf_reshape = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_reshape)
		CHK(6, cleanup, L"[48] rho('shape_ibeam') ambiv reshape");
	
	*stkhd++ = retain_cell(loc->cdf_reshape);
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[48] rho('shape_ibeam') ambiv reshape");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!cdf_shape_ibeam)
		CHK(6, cleanup, L"[48] rho('shape_ibeam') ambiv reshape");
	
	*stkhd++ = retain_cell(cdf_shape_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[48] rho('shape_ibeam') ambiv reshape");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rho);
	loc->cdf_rho = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13563, cdf_ptr13564, 0), cleanup, 
		    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_idx_rnk_check->value);
	loc->cdf_idx_rnk_check->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13565, cdf_ptr13566, 3), cleanup, 
		    L"[52] idx_rng_check{");
	
		k->fv[0] = retain_cell(loc->cdf_any);
		k->fv[1] = retain_cell(loc->cdf_is_integer);
		k->fv[2] = retain_cell(loc->cdf_squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_idx_rng_check->value);
	loc->cdf_idx_rng_check->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13567, cdf_ptr13572, 2), cleanup, 
		    L"[58] flatten_idx{");
	
		k->fv[0] = retain_cell(loc->cdf_idx_rng_check);
		k->fv[1] = retain_cell(loc->cdf_is_span);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_flatten_idx->value);
	loc->cdf_flatten_idx->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13577, cdf_ptr13578, 0), cleanup, 
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_idx_shp_check->value);
	loc->cdf_idx_shp_check->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, cdf_ptr13579, cdf_ptr13582, cdf_ptr13585, cdf_ptr13588, 4), cleanup, 
		    L"[64] set_get_idx{");
	
		k->fv[0] = retain_cell(loc->cdf_idx_shp_check);
		k->fv[1] = retain_cell(loc->cdf_flatten_idx);
		k->fv[2] = retain_cell(loc->cdf_idx_rnk_check);
		k->fv[3] = retain_cell(loc->cdf_is_span);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_set_get_idx->value);
	loc->cdf_set_get_idx->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_set_ibeam)
		CHK(6, cleanup, L"[71] set'set_ibeam'");
	
	*stkhd++ = retain_cell(cdf_set_ibeam);
	
	release_cell(loc->cdf_set);
	loc->cdf_set = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, cdf_ptr13591, cdf_ptr13594, cdf_ptr13597, cdf_ptr13600, cdf_ptr13603, cdf_ptr13606, cdf_ptr13609, cdf_ptr13612, 2), cleanup, 
		    L"[74] mst_vals{op");
	
		k->fv[0] = retain_cell(loc->cdf_set_get_idx);
		k->fv[1] = retain_cell(loc->cdf_is_span);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_mst_vals);
	loc->cdf_mst_vals = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_mst_ibeam)
		CHK(6, cleanup, L"[80] mst'mst_ibeam'");
	
	*stkhd++ = retain_cell(cdf_mst_ibeam);
	
	release_cell(loc->cdf_mst);
	loc->cdf_mst = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13615, cdf_ptr13618, 2), cleanup, 
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		k->fv[0] = retain_cell(loc->cdf_flatten_idx);
		k->fv[1] = retain_cell(loc->cdf_is_span);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_sqd);
	loc->cdf_sqd = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13621, cdf_ptr13622, 1), cleanup, 
		    L"[94] brk{ idx_rnk_check :  }");
	
		k->fv[0] = retain_cell(loc->cdf_idx_rnk_check);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_brk);
	loc->cdf_brk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13623, cdf_ptr13624, 0), cleanup, 
		    L"[97] rgt{}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_rgt);
	loc->cdf_rgt = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13627, cdf_ptr13628, 0), cleanup, 
		    L"[100] lft{} ambiv {}");
	
		*stkhd++ = k;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[100] lft{} ambiv {}");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13625, cdf_ptr13626, 0), cleanup, 
		    L"[100] lft{} ambiv {}");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[100] lft{} ambiv {}");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lft);
	loc->cdf_lft = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13629, cdf_ptr13640, 1), cleanup, 
		    L"[103] cat{");
	
		k->fv[0] = retain_cell(loc->cdf_is_numeric);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_cat);
	loc->cdf_cat = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13651, cdf_ptr13652, 0), cleanup, 
		    L"[131] ctf{,[0]}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_ctf);
	loc->cdf_ctf = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13653, cdf_ptr13656, 1), cleanup, 
		    L"[134] depth{");
	
		k->fv[0] = retain_cell(loc->cdf_is_simple);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_depth);
	loc->cdf_depth = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_same_ibeam)
		CHK(6, cleanup, L"[141] same'same_ibeam'");
	
	*stkhd++ = retain_cell(cdf_same_ibeam);
	
	release_cell(loc->cdf_same->value);
	loc->cdf_same->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_same->value)
		CHK(6, cleanup, L"[142] eqvdepth ambiv same");
	
	*stkhd++ = retain_cell(loc->cdf_same->value);
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[142] eqvdepth ambiv same");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_depth)
		CHK(6, cleanup, L"[142] eqvdepth ambiv same");
	
	*stkhd++ = retain_cell(loc->cdf_depth);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[142] eqvdepth ambiv same");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_eqv);
	loc->cdf_eqv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_nqv_ibeam)
		CHK(6, cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
	*stkhd++ = retain_cell(cdf_nqv_ibeam);
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13659, cdf_ptr13660, 0), cleanup, 
		    L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_nqv);
	loc->cdf_nqv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13661, cdf_ptr13662, 1), cleanup, 
		    L"[148] index_gen{");
	
		k->fv[0] = retain_cell(loc->cdf_chk_valid_shape);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_index_gen);
	loc->cdf_index_gen = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13663, cdf_ptr13664, 0), cleanup, 
		    L"[155] index_of{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_index_of);
	loc->cdf_index_of = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_index_of)
		CHK(6, cleanup, L"[156] iotindex_gen ambiv index_of");
	
	*stkhd++ = retain_cell(loc->cdf_index_of);
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[156] iotindex_gen ambiv index_of");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_index_gen)
		CHK(6, cleanup, L"[156] iotindex_gen ambiv index_of");
	
	*stkhd++ = retain_cell(loc->cdf_index_gen);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[156] iotindex_gen ambiv index_of");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_iot);
	loc->cdf_iot = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13665, cdf_ptr13666, 0), cleanup, 
		    L"[159] dis('disclose_ibeam') ambiv {SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[159] dis('disclose_ibeam') ambiv {SIGNAL 16}");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!cdf_disclose_ibeam)
		CHK(6, cleanup, L"[159] dis('disclose_ibeam') ambiv {SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_disclose_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[159] dis('disclose_ibeam') ambiv {SIGNAL 16}");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_dis);
	loc->cdf_dis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13667, cdf_ptr13668, 0), cleanup, 
		    L"[162] enclose{");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_enclose);
	loc->cdf_enclose = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13669, cdf_ptr13670, 0), cleanup, 
		    L"[166] parenclose ambiv {SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[166] parenclose ambiv {SIGNAL 16}");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_enclose)
		CHK(6, cleanup, L"[166] parenclose ambiv {SIGNAL 16}");
	
	*stkhd++ = retain_cell(loc->cdf_enclose);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[166] parenclose ambiv {SIGNAL 16}");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_par);
	loc->cdf_par = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13671, cdf_ptr13672, 1), cleanup, 
		    L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
		k->fv[0] = retain_cell(loc->cdf_squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_conjugate);
	loc->cdf_conjugate = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[170] addconjugate ambiv ('add_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[170] addconjugate ambiv ('add_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!cdf_add_vec_ibeam)
		CHK(6, cleanup, L"[170] addconjugate ambiv ('add_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_add_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[170] addconjugate ambiv ('add_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[170] addconjugate ambiv ('add_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[170] addconjugate ambiv ('add_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_conjugate)
		CHK(6, cleanup, L"[170] addconjugate ambiv ('add_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_conjugate);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[170] addconjugate ambiv ('add_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_add);
	loc->cdf_add = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!cdf_sub_vec_ibeam)
		CHK(6, cleanup, L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_sub_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13673, cdf_ptr13674, 0), cleanup, 
		    L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_sub);
	loc->cdf_sub = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13675, cdf_ptr13676, 0), cleanup, 
		    L"[176] sign{");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_sign);
	loc->cdf_sign = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[180] mulsign ambiv ('mul_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[180] mulsign ambiv ('mul_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!cdf_mul_vec_ibeam)
		CHK(6, cleanup, L"[180] mulsign ambiv ('mul_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_mul_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[180] mulsign ambiv ('mul_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[180] mulsign ambiv ('mul_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[180] mulsign ambiv ('mul_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_sign)
		CHK(6, cleanup, L"[180] mulsign ambiv ('mul_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_sign);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[180] mulsign ambiv ('mul_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_mul);
	loc->cdf_mul = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!cdf_div_vec_ibeam)
		CHK(6, cleanup, L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_div_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13677, cdf_ptr13678, 0), cleanup, 
		    L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_div);
	loc->cdf_div = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13679, cdf_ptr13680, 1), cleanup, 
		    L"[186] absolute{");
	
		k->fv[0] = retain_cell(loc->cdf_is_numeric);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_absolute);
	loc->cdf_absolute = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13681, cdf_ptr13682, 0), cleanup, 
		    L"[191] residue{-+0=}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_residue);
	loc->cdf_residue = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_residue)
		CHK(6, cleanup, L"[192] resabsolute numeric ambiv residue");
	
	*stkhd++ = retain_cell(loc->cdf_residue);
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[192] resabsolute numeric ambiv residue");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[192] resabsolute numeric ambiv residue");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!loc->cdf_absolute)
		CHK(6, cleanup, L"[192] resabsolute numeric ambiv residue");
	
	*stkhd++ = retain_cell(loc->cdf_absolute);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[192] resabsolute numeric ambiv residue");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[192] resabsolute numeric ambiv residue");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_res);
	loc->cdf_res = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13683, cdf_ptr13684, 1), cleanup, 
		    L"[195] floor_array{");
	
		k->fv[0] = retain_cell(loc->cdf_is_integer);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_floor_array);
	loc->cdf_floor_array = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[200] minfloor_array numeric ambiv ('min_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[200] minfloor_array numeric ambiv ('min_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!cdf_min_vec_ibeam)
		CHK(6, cleanup, L"[200] minfloor_array numeric ambiv ('min_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_min_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[200] minfloor_array numeric ambiv ('min_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[200] minfloor_array numeric ambiv ('min_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[200] minfloor_array numeric ambiv ('min_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[200] minfloor_array numeric ambiv ('min_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!loc->cdf_floor_array)
		CHK(6, cleanup, L"[200] minfloor_array numeric ambiv ('min_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_floor_array);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[200] minfloor_array numeric ambiv ('min_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[200] minfloor_array numeric ambiv ('min_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_min);
	loc->cdf_min = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13685, cdf_ptr13686, 1), cleanup, 
		    L"[203] ceil_array{");
	
		k->fv[0] = retain_cell(loc->cdf_is_integer);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_ceil_array);
	loc->cdf_ceil_array = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[208] maxceil_array numeric ambiv ('max_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[208] maxceil_array numeric ambiv ('max_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!cdf_max_vec_ibeam)
		CHK(6, cleanup, L"[208] maxceil_array numeric ambiv ('max_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_max_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[208] maxceil_array numeric ambiv ('max_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[208] maxceil_array numeric ambiv ('max_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[208] maxceil_array numeric ambiv ('max_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[208] maxceil_array numeric ambiv ('max_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!loc->cdf_ceil_array)
		CHK(6, cleanup, L"[208] maxceil_array numeric ambiv ('max_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ceil_array);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[208] maxceil_array numeric ambiv ('max_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[208] maxceil_array numeric ambiv ('max_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_max);
	loc->cdf_max = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[211] exp'exp_vec_ibeam' numeric ambiv ('pow_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[211] exp'exp_vec_ibeam' numeric ambiv ('pow_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!cdf_pow_vec_ibeam)
		CHK(6, cleanup, L"[211] exp'exp_vec_ibeam' numeric ambiv ('pow_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_pow_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[211] exp'exp_vec_ibeam' numeric ambiv ('pow_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[211] exp'exp_vec_ibeam' numeric ambiv ('pow_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[211] exp'exp_vec_ibeam' numeric ambiv ('pow_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[211] exp'exp_vec_ibeam' numeric ambiv ('pow_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!cdf_exp_vec_ibeam)
		CHK(6, cleanup, L"[211] exp'exp_vec_ibeam' numeric ambiv ('pow_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_exp_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[211] exp'exp_vec_ibeam' numeric ambiv ('pow_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[211] exp'exp_vec_ibeam' numeric ambiv ('pow_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_exp);
	loc->cdf_exp = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[214] log'nlg_vec_ibeam' numeric ambiv ('log_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[214] log'nlg_vec_ibeam' numeric ambiv ('log_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!cdf_log_vec_ibeam)
		CHK(6, cleanup, L"[214] log'nlg_vec_ibeam' numeric ambiv ('log_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_log_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[214] log'nlg_vec_ibeam' numeric ambiv ('log_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[214] log'nlg_vec_ibeam' numeric ambiv ('log_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[214] log'nlg_vec_ibeam' numeric ambiv ('log_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[214] log'nlg_vec_ibeam' numeric ambiv ('log_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!cdf_nlg_vec_ibeam)
		CHK(6, cleanup, L"[214] log'nlg_vec_ibeam' numeric ambiv ('log_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_nlg_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[214] log'nlg_vec_ibeam' numeric ambiv ('log_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[214] log'nlg_vec_ibeam' numeric ambiv ('log_vec_ibeam' numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_log);
	loc->cdf_log = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13687, cdf_ptr13688, 0), cleanup, 
		    L"[217] pitimes{3.14159265358979323846}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_pitimes);
	loc->cdf_pitimes = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13689, cdf_ptr13694, 0), cleanup, 
		    L"[218] trig{");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_trig);
	loc->cdf_trig = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[247] cirpitimes numeric ambiv (trig numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[247] cirpitimes numeric ambiv (trig numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!loc->cdf_trig)
		CHK(6, cleanup, L"[247] cirpitimes numeric ambiv (trig numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_trig);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[247] cirpitimes numeric ambiv (trig numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[247] cirpitimes numeric ambiv (trig numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[247] cirpitimes numeric ambiv (trig numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[247] cirpitimes numeric ambiv (trig numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!loc->cdf_pitimes)
		CHK(6, cleanup, L"[247] cirpitimes numeric ambiv (trig numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_pitimes);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[247] cirpitimes numeric ambiv (trig numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[247] cirpitimes numeric ambiv (trig numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_cir);
	loc->cdf_cir = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13699, cdf_ptr13700, 0), cleanup, 
		    L"[250] binomial{");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_binomial);
	loc->cdf_binomial = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[254] fac'factorial_vec_ibeam' numeric ambiv (binomial numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[254] fac'factorial_vec_ibeam' numeric ambiv (binomial numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!loc->cdf_binomial)
		CHK(6, cleanup, L"[254] fac'factorial_vec_ibeam' numeric ambiv (binomial numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_binomial);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[254] fac'factorial_vec_ibeam' numeric ambiv (binomial numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[254] fac'factorial_vec_ibeam' numeric ambiv (binomial numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[254] fac'factorial_vec_ibeam' numeric ambiv (binomial numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[254] fac'factorial_vec_ibeam' numeric ambiv (binomial numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!cdf_factorial_vec_ibeam)
		CHK(6, cleanup, L"[254] fac'factorial_vec_ibeam' numeric ambiv (binomial numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_factorial_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[254] fac'factorial_vec_ibeam' numeric ambiv (binomial numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[254] fac'factorial_vec_ibeam' numeric ambiv (binomial numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_fac);
	loc->cdf_fac = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13701, cdf_ptr13702, 1), cleanup, 
		    L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
		k->fv[0] = retain_cell(loc->cdf_is_bool);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_notscl);
	loc->cdf_notscl = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13703, cdf_ptr13704, 0), cleanup, 
		    L"[258] without{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_without);
	loc->cdf_without = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_without)
		CHK(6, cleanup, L"[259] notnotscl ambiv without");
	
	*stkhd++ = retain_cell(loc->cdf_without);
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[259] notnotscl ambiv without");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_notscl)
		CHK(6, cleanup, L"[259] notnotscl ambiv without");
	
	*stkhd++ = retain_cell(loc->cdf_notscl);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[259] notnotscl ambiv without");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_not);
	loc->cdf_not = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13705, cdf_ptr13706, 1), cleanup, 
		    L"[262] logand{");
	
		k->fv[0] = retain_cell(loc->cdf_both_bool);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_logand);
	loc->cdf_logand = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!loc->cdf_logand)
		CHK(6, cleanup, L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_logand);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13707, cdf_ptr13708, 0), cleanup, 
		    L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_and);
	loc->cdf_and = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13709, cdf_ptr13714, 4), cleanup, 
		    L"[269] logor{");
	
		k->fv[0] = retain_cell(loc->cdf_both_bool);
		k->fv[1] = retain_cell(loc->cdf_both_integer);
		k->fv[2] = retain_cell(loc->cdf_is_bool);
		k->fv[3] = retain_cell(loc->cdf_is_integer);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_logor);
	loc->cdf_logor = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!loc->cdf_logor)
		CHK(6, cleanup, L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_logor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13719, cdf_ptr13720, 0), cleanup, 
		    L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lor);
	loc->cdf_lor = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13723, cdf_ptr13724, 1), cleanup, 
		    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		k->fv[0] = retain_cell(loc->cdf_both_bool);
	
		*stkhd++ = k;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13721, cdf_ptr13722, 0), cleanup, 
		    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_nan);
	loc->cdf_nan = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13727, cdf_ptr13728, 1), cleanup, 
		    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		k->fv[0] = retain_cell(loc->cdf_both_bool);
	
		*stkhd++ = k;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13725, cdf_ptr13726, 0), cleanup, 
		    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_nor);
	loc->cdf_nor = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13729, cdf_ptr13730, 0), cleanup, 
		    L"[285] lessthan{");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_lessthan);
	loc->cdf_lessthan = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!loc->cdf_lessthan)
		CHK(6, cleanup, L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_lessthan);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13731, cdf_ptr13732, 0), cleanup, 
		    L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lth);
	loc->cdf_lth = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13733, cdf_ptr13734, 0), cleanup, 
		    L"[292] lesseql{");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_lesseql);
	loc->cdf_lesseql = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!loc->cdf_lesseql)
		CHK(6, cleanup, L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_lesseql);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13735, cdf_ptr13736, 0), cleanup, 
		    L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lte);
	loc->cdf_lte = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_eql_vec_ibeam)
		CHK(6, cleanup, L"[299] eql_vec'eql_vec_ibeam'");
	
	*stkhd++ = retain_cell(cdf_eql_vec_ibeam);
	
	release_cell(loc->cdf_eql_vec->value);
	loc->cdf_eql_vec->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13737, cdf_ptr13738, 3), cleanup, 
		    L"[300] equal{");
	
		k->fv[0] = retain_cell(loc->cdf_eql_vec);
		k->fv[1] = retain_cell(loc->cdf_both_char);
		k->fv[2] = retain_cell(loc->cdf_both_numeric);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_equal);
	loc->cdf_equal = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_equal)
		CHK(6, cleanup, L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_equal);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13739, cdf_ptr13740, 0), cleanup, 
		    L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_eql);
	loc->cdf_eql = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13741, cdf_ptr13742, 0), cleanup, 
		    L"[308] greatereql{");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_greatereql);
	loc->cdf_greatereql = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!loc->cdf_greatereql)
		CHK(6, cleanup, L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_greatereql);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13743, cdf_ptr13744, 0), cleanup, 
		    L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_gte);
	loc->cdf_gte = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13745, cdf_ptr13746, 0), cleanup, 
		    L"[315] greaterthan{");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_greaterthan);
	loc->cdf_greaterthan = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_numeric)
		CHK(6, cleanup, L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_numeric);
	
	if (!loc->cdf_greaterthan)
		CHK(6, cleanup, L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_greaterthan);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13747, cdf_ptr13748, 0), cleanup, 
		    L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_gth);
	loc->cdf_gth = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13749, cdf_ptr13750, 0), cleanup, 
		    L"[322] firstocc{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_firstocc);
	loc->cdf_firstocc = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_neq_vec_ibeam)
		CHK(6, cleanup, L"[323] neq_vec'neq_vec_ibeam'");
	
	*stkhd++ = retain_cell(cdf_neq_vec_ibeam);
	
	release_cell(loc->cdf_neq_vec->value);
	loc->cdf_neq_vec->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13751, cdf_ptr13752, 3), cleanup, 
		    L"[324] noteq{");
	
		k->fv[0] = retain_cell(loc->cdf_neq_vec);
		k->fv[1] = retain_cell(loc->cdf_both_char);
		k->fv[2] = retain_cell(loc->cdf_both_numeric);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_noteq);
	loc->cdf_noteq = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_scalar)
		CHK(6, cleanup, L"[329] neqfirstocc ambiv (noteq scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_scalar);
	
	if (!loc->cdf_noteq)
		CHK(6, cleanup, L"[329] neqfirstocc ambiv (noteq scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_noteq);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[329] neqfirstocc ambiv (noteq scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[329] neqfirstocc ambiv (noteq scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_firstocc)
		CHK(6, cleanup, L"[329] neqfirstocc ambiv (noteq scalar)");
	
	*stkhd++ = retain_cell(loc->cdf_firstocc);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[329] neqfirstocc ambiv (noteq scalar)");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_neq);
	loc->cdf_neq = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13753, cdf_ptr13754, 0), cleanup, 
		    L"[332] mix{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_mix);
	loc->cdf_mix = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13755, cdf_ptr13756, 0), cleanup, 
		    L"[333] take{()}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_take);
	loc->cdf_take = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_take)
		CHK(6, cleanup, L"[334] tkemix ambiv take");
	
	*stkhd++ = retain_cell(loc->cdf_take);
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[334] tkemix ambiv take");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_mix)
		CHK(6, cleanup, L"[334] tkemix ambiv take");
	
	*stkhd++ = retain_cell(loc->cdf_mix);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[334] tkemix ambiv take");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_tke);
	loc->cdf_tke = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13757, cdf_ptr13758, 0), cleanup, 
		    L"[337] drp{");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_drp);
	loc->cdf_drp = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13759, cdf_ptr13760, 0), cleanup, 
		    L"[345] rtf{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_rtf);
	loc->cdf_rtf = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13761, cdf_ptr13762, 0), cleanup, 
		    L"[348] reverse_last{(()-1+)}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_reverse_last);
	loc->cdf_reverse_last = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13763, cdf_ptr13764, 0), cleanup, 
		    L"[349] rotate_last{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_rotate_last);
	loc->cdf_rotate_last = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_rotate_last)
		CHK(6, cleanup, L"[350] rotreverse_last ambiv rotate_last");
	
	*stkhd++ = retain_cell(loc->cdf_rotate_last);
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[350] rotreverse_last ambiv rotate_last");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_reverse_last)
		CHK(6, cleanup, L"[350] rotreverse_last ambiv rotate_last");
	
	*stkhd++ = retain_cell(loc->cdf_reverse_last);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[350] rotreverse_last ambiv rotate_last");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rot);
	loc->cdf_rot = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13765, cdf_ptr13766, 0), cleanup, 
		    L"[353] trn{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_trn);
	loc->cdf_trn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13767, cdf_ptr13768, 0), cleanup, 
		    L"[356] gdu{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_gdu);
	loc->cdf_gdu = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13769, cdf_ptr13770, 0), cleanup, 
		    L"[359] gdd{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_gdd);
	loc->cdf_gdd = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13771, cdf_ptr13772, 0), cleanup, 
		    L"[362] enc{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_enc);
	loc->cdf_enc = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13773, cdf_ptr13778, 2), cleanup, 
		    L"[365] dec{");
	
		k->fv[0] = retain_cell(loc->cdf_both_numeric);
		k->fv[1] = retain_cell(loc->cdf_squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_dec);
	loc->cdf_dec = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13783, cdf_ptr13784, 0), cleanup, 
		    L"[376] mem{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_mem);
	loc->cdf_mem = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13785, cdf_ptr13786, 0), cleanup, 
		    L"[379] fnd{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_fnd);
	loc->cdf_fnd = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13787, cdf_ptr13788, 0), cleanup, 
		    L"[382] unq{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_unq);
	loc->cdf_unq = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13789, cdf_ptr13790, 0), cleanup, 
		    L"[385] int{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_int);
	loc->cdf_int = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13791, cdf_ptr13794, 2), cleanup, 
		    L"[388] deal{");
	
		k->fv[0] = retain_cell(loc->cdf_both_integer);
		k->fv[1] = retain_cell(loc->cdf_squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_deal);
	loc->cdf_deal = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13797, cdf_ptr13798, 3), cleanup, 
		    L"[394] roll{");
	
		k->fv[0] = retain_cell(loc->cdf_any);
		k->fv[1] = retain_cell(loc->cdf_is_integer);
		k->fv[2] = retain_cell(loc->cdf_squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_roll);
	loc->cdf_roll = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_deal)
		CHK(6, cleanup, L"[400] rolroll ambiv deal");
	
	*stkhd++ = retain_cell(loc->cdf_deal);
	
	if (!loc->cdf_ambiv)
		CHK(6, cleanup, L"[400] rolroll ambiv deal");
	
	*stkhd++ = retain_cell(loc->cdf_ambiv);
	
	if (!loc->cdf_roll)
		CHK(6, cleanup, L"[400] rolroll ambiv deal");
	
	*stkhd++ = retain_cell(loc->cdf_roll);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[400] rolroll ambiv deal");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rol);
	loc->cdf_rol = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13799, cdf_ptr13800, 0), cleanup, 
		    L"[403] mdv{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_mdv);
	loc->cdf_mdv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, cdf_ptr13801, cdf_ptr13802, cdf_ptr13803, cdf_ptr13804, 0), cleanup, 
		    L"[406] com{2=NC'':      }");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_com);
	loc->cdf_com = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, cdf_ptr13805, cdf_ptr13806, cdf_ptr13807, cdf_ptr13808, 4), cleanup, 
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		k->fv[0] = retain_cell(loc->cdf_veach);
		k->fv[1] = retain_cell(loc->cdf_chk_scl);
		k->fv[2] = retain_cell(loc->cdf_max_shp);
		k->fv[3] = retain_cell(loc->cdf_squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_map);
	loc->cdf_map = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, cdf_ptr13809, cdf_ptr13810, cdf_ptr13811, cdf_ptr13812, 1), cleanup, 
		    L"[412] identity{");
	
		k->fv[0] = retain_cell(loc->cdf_eq);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_identity->value);
	loc->cdf_identity->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, cdf_ptr13813, cdf_ptr13816, cdf_ptr13819, cdf_ptr13822, cdf_ptr13825, cdf_ptr13828, cdf_ptr13831, cdf_ptr13834, 1), cleanup, 
		    L"[419] reduce{axis");
	
		k->fv[0] = retain_cell(loc->cdf_identity);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_reduce->value);
	loc->cdf_reduce->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, cdf_ptr13837, cdf_ptr13840, cdf_ptr13843, cdf_ptr13846, cdf_ptr13849, cdf_ptr13852, cdf_ptr13855, cdf_ptr13858, 1), cleanup, 
		    L"[424] nwreduce{op  axis");
	
		k->fv[0] = retain_cell(loc->cdf_is_integer);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_nwreduce->value);
	loc->cdf_nwreduce->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13861, cdf_ptr13862, 0), cleanup, 
		    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_red_check->value);
	loc->cdf_red_check->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, cdf_ptr13863, cdf_ptr13864, cdf_ptr13865, cdf_ptr13866, 3), cleanup, 
		    L"[429] rdf{   red_check :  axis0");
	
		k->fv[0] = retain_cell(loc->cdf_red_check);
		k->fv[1] = retain_cell(loc->cdf_nwreduce);
		k->fv[2] = retain_cell(loc->cdf_reduce);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_rdf);
	loc->cdf_rdf = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, cdf_ptr13867, cdf_ptr13868, cdf_ptr13869, cdf_ptr13870, 3), cleanup, 
		    L"[434] red{   red_check :  axis01+");
	
		k->fv[0] = retain_cell(loc->cdf_red_check);
		k->fv[1] = retain_cell(loc->cdf_nwreduce);
		k->fv[2] = retain_cell(loc->cdf_reduce);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_red);
	loc->cdf_red = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13871, cdf_ptr13872, 0), cleanup, 
		    L"[439] rpf{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_rpf);
	loc->cdf_rpf = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13873, cdf_ptr13874, 0), cleanup, 
		    L"[442] rep{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_rep);
	loc->cdf_rep = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, cdf_ptr13875, cdf_ptr13878, cdf_ptr13881, cdf_ptr13884, 1), cleanup, 
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		k->fv[0] = retain_cell(loc->cdf_squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_scf);
	loc->cdf_scf = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, cdf_ptr13887, cdf_ptr13892, cdf_ptr13897, cdf_ptr13902, 1), cleanup, 
		    L"[448] scn{");
	
		k->fv[0] = retain_cell(loc->cdf_squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_scn);
	loc->cdf_scn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13907, cdf_ptr13908, 0), cleanup, 
		    L"[456] xpf{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_xpf);
	loc->cdf_xpf = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13909, cdf_ptr13910, 0), cleanup, 
		    L"[459] xpd{SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_xpd);
	loc->cdf_xpd = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, cdf_ptr13911, cdf_ptr13912, cdf_ptr13913, cdf_ptr13914, cdf_ptr13915, cdf_ptr13916, cdf_ptr13917, cdf_ptr13918, 0), cleanup, 
		    L"[462] dot{  }");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_dot);
	loc->cdf_dot = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, cdf_ptr13919, cdf_ptr13920, cdf_ptr13921, cdf_ptr13922, 0), cleanup, 
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_oup);
	loc->cdf_oup = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, cdf_ptr13923, cdf_ptr13924, cdf_ptr13925, cdf_ptr13926, cdf_ptr13927, cdf_ptr13928, cdf_ptr13929, cdf_ptr13930, 0), cleanup, 
		    L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_pow);
	loc->cdf_pow = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, cdf_ptr13931, cdf_ptr13932, cdf_ptr13933, cdf_ptr13934, cdf_ptr13935, cdf_ptr13936, cdf_ptr13937, cdf_ptr13938, 0), cleanup, 
		    L"[471] jot{");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_jot);
	loc->cdf_jot = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, cdf_ptr13939, cdf_ptr13940, cdf_ptr13941, cdf_ptr13942, cdf_ptr13943, cdf_ptr13944, cdf_ptr13945, cdf_ptr13946, 0), cleanup, 
		    L"[481] rnk{fn  rk  SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_rnk);
	loc->cdf_rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, cdf_ptr13947, cdf_ptr13948, cdf_ptr13949, cdf_ptr13950, 0), cleanup, 
		    L"[484] key{fn  SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cdf_key);
	loc->cdf_key = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
cdf_ptr13519(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[17] is_bool{11DR squeeze }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[17] is_bool{11DR squeeze }");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[17] is_bool{11DR squeeze }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[17] is_bool{11DR squeeze }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[17] is_bool{11DR squeeze }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[17] is_bool{11DR squeeze }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[17] is_bool{11DR squeeze }");
	
		CHK(fill_array(arr, dat), cleanup, L"[17] is_bool{11DR squeeze }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[17] is_bool{11DR squeeze }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[17] is_bool{11DR squeeze }");
	return err;
}

int
cdf_ptr13520(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[17] is_bool{11DR squeeze }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[17] is_bool{11DR squeeze }");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[17] is_bool{11DR squeeze }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[17] is_bool{11DR squeeze }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[17] is_bool{11DR squeeze }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[17] is_bool{11DR squeeze }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[17] is_bool{11DR squeeze }");
	
		CHK(fill_array(arr, dat), cleanup, L"[17] is_bool{11DR squeeze }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[17] is_bool{11DR squeeze }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[17] is_bool{11DR squeeze }");
	return err;
}

int
cdf_ptr13521(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[19] max_shp{0  ('max_shp_ibeam')}");
	
		CHK(fill_array(arr, dat), cleanup, L"[19] max_shp{0  ('max_shp_ibeam')}");
	
		*stkhd++ = arr;
	}
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[19] max_shp{0  ('max_shp_ibeam')}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_max_shp_ibeam)
		CHK(6, cleanup, L"[19] max_shp{0  ('max_shp_ibeam')}");
	
	*stkhd++ = retain_cell(cdf_max_shp_ibeam);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[19] max_shp{0  ('max_shp_ibeam')}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[19] max_shp{0  ('max_shp_ibeam')}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[19] max_shp{0  ('max_shp_ibeam')}");
	return err;
}

int
cdf_ptr13522(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[19] max_shp{0  ('max_shp_ibeam')}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_max_shp_ibeam)
		CHK(6, cleanup, L"[19] max_shp{0  ('max_shp_ibeam')}");
	
	*stkhd++ = retain_cell(cdf_max_shp_ibeam);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[19] max_shp{0  ('max_shp_ibeam')}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[19] max_shp{0  ('max_shp_ibeam')}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[19] max_shp{0  ('max_shp_ibeam')}");
	return err;
}

int
cdf_ptr13523(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	return err;
}

int
cdf_ptr13524(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[21] chk_scl{0  ():0  1,:0  1,:0  ():SIGNAL 5  SIGNAL 4}");
	return err;
}

int
cdf_ptr13525(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_is_simple;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[22] both_simple{is_simple :is_simple   0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_simple->value)
		CHK(6, cleanup, L"[22] both_simple{is_simple :is_simple   0}");
	
	*stkhd++ = retain_cell(lex->cdf_is_simple->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[22] both_simple{is_simple :is_simple   0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[22] both_simple{is_simple :is_simple   0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[22] both_simple{is_simple :is_simple   0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_is_simple->value)
				CHK(6, cleanup, L"[22] both_simple{is_simple :is_simple   0}");
			
			*stkhd++ = retain_cell(lex->cdf_is_simple->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[22] both_simple{is_simple :is_simple   0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] both_simple{is_simple :is_simple   0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] both_simple{is_simple :is_simple   0}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[22] both_simple{is_simple :is_simple   0}");
	return err;
}

int
cdf_ptr13526(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_is_simple;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[22] both_simple{is_simple :is_simple   0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_simple->value)
		CHK(6, cleanup, L"[22] both_simple{is_simple :is_simple   0}");
	
	*stkhd++ = retain_cell(lex->cdf_is_simple->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[22] both_simple{is_simple :is_simple   0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[22] both_simple{is_simple :is_simple   0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[22] both_simple{is_simple :is_simple   0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_is_simple->value)
				CHK(6, cleanup, L"[22] both_simple{is_simple :is_simple   0}");
			
			*stkhd++ = retain_cell(lex->cdf_is_simple->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[22] both_simple{is_simple :is_simple   0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] both_simple{is_simple :is_simple   0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] both_simple{is_simple :is_simple   0}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[22] both_simple{is_simple :is_simple   0}");
	return err;
}

int
cdf_ptr13527(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_is_numeric;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[23] both_numeric{is_numeric :is_numeric   0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_numeric->value)
		CHK(6, cleanup, L"[23] both_numeric{is_numeric :is_numeric   0}");
	
	*stkhd++ = retain_cell(lex->cdf_is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[23] both_numeric{is_numeric :is_numeric   0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[23] both_numeric{is_numeric :is_numeric   0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[23] both_numeric{is_numeric :is_numeric   0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_is_numeric->value)
				CHK(6, cleanup, L"[23] both_numeric{is_numeric :is_numeric   0}");
			
			*stkhd++ = retain_cell(lex->cdf_is_numeric->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[23] both_numeric{is_numeric :is_numeric   0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[23] both_numeric{is_numeric :is_numeric   0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[23] both_numeric{is_numeric :is_numeric   0}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[23] both_numeric{is_numeric :is_numeric   0}");
	return err;
}

int
cdf_ptr13528(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_is_numeric;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[23] both_numeric{is_numeric :is_numeric   0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_numeric->value)
		CHK(6, cleanup, L"[23] both_numeric{is_numeric :is_numeric   0}");
	
	*stkhd++ = retain_cell(lex->cdf_is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[23] both_numeric{is_numeric :is_numeric   0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[23] both_numeric{is_numeric :is_numeric   0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[23] both_numeric{is_numeric :is_numeric   0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_is_numeric->value)
				CHK(6, cleanup, L"[23] both_numeric{is_numeric :is_numeric   0}");
			
			*stkhd++ = retain_cell(lex->cdf_is_numeric->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[23] both_numeric{is_numeric :is_numeric   0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[23] both_numeric{is_numeric :is_numeric   0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[23] both_numeric{is_numeric :is_numeric   0}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[23] both_numeric{is_numeric :is_numeric   0}");
	return err;
}

int
cdf_ptr13529(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[24] both_integer{is_integer :is_integer   0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[24] both_integer{is_integer :is_integer   0}");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[24] both_integer{is_integer :is_integer   0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[24] both_integer{is_integer :is_integer   0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[24] both_integer{is_integer :is_integer   0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_is_integer->value)
				CHK(6, cleanup, L"[24] both_integer{is_integer :is_integer   0}");
			
			*stkhd++ = retain_cell(lex->cdf_is_integer->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[24] both_integer{is_integer :is_integer   0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[24] both_integer{is_integer :is_integer   0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[24] both_integer{is_integer :is_integer   0}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[24] both_integer{is_integer :is_integer   0}");
	return err;
}

int
cdf_ptr13530(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[24] both_integer{is_integer :is_integer   0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[24] both_integer{is_integer :is_integer   0}");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[24] both_integer{is_integer :is_integer   0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[24] both_integer{is_integer :is_integer   0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[24] both_integer{is_integer :is_integer   0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_is_integer->value)
				CHK(6, cleanup, L"[24] both_integer{is_integer :is_integer   0}");
			
			*stkhd++ = retain_cell(lex->cdf_is_integer->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[24] both_integer{is_integer :is_integer   0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[24] both_integer{is_integer :is_integer   0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[24] both_integer{is_integer :is_integer   0}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[24] both_integer{is_integer :is_integer   0}");
	return err;
}

int
cdf_ptr13531(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_is_char;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[25] both_char{is_char :is_char   0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_char->value)
		CHK(6, cleanup, L"[25] both_char{is_char :is_char   0}");
	
	*stkhd++ = retain_cell(lex->cdf_is_char->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[25] both_char{is_char :is_char   0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[25] both_char{is_char :is_char   0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[25] both_char{is_char :is_char   0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_is_char->value)
				CHK(6, cleanup, L"[25] both_char{is_char :is_char   0}");
			
			*stkhd++ = retain_cell(lex->cdf_is_char->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[25] both_char{is_char :is_char   0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[25] both_char{is_char :is_char   0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[25] both_char{is_char :is_char   0}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[25] both_char{is_char :is_char   0}");
	return err;
}

int
cdf_ptr13532(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_is_char;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[25] both_char{is_char :is_char   0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_char->value)
		CHK(6, cleanup, L"[25] both_char{is_char :is_char   0}");
	
	*stkhd++ = retain_cell(lex->cdf_is_char->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[25] both_char{is_char :is_char   0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[25] both_char{is_char :is_char   0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[25] both_char{is_char :is_char   0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_is_char->value)
				CHK(6, cleanup, L"[25] both_char{is_char :is_char   0}");
			
			*stkhd++ = retain_cell(lex->cdf_is_char->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[25] both_char{is_char :is_char   0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[25] both_char{is_char :is_char   0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[25] both_char{is_char :is_char   0}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[25] both_char{is_char :is_char   0}");
	return err;
}

int
cdf_ptr13533(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_is_bool;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[26] both_bool{is_bool :is_bool   0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_bool->value)
		CHK(6, cleanup, L"[26] both_bool{is_bool :is_bool   0}");
	
	*stkhd++ = retain_cell(lex->cdf_is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[26] both_bool{is_bool :is_bool   0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[26] both_bool{is_bool :is_bool   0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[26] both_bool{is_bool :is_bool   0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_is_bool->value)
				CHK(6, cleanup, L"[26] both_bool{is_bool :is_bool   0}");
			
			*stkhd++ = retain_cell(lex->cdf_is_bool->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[26] both_bool{is_bool :is_bool   0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[26] both_bool{is_bool :is_bool   0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[26] both_bool{is_bool :is_bool   0}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[26] both_bool{is_bool :is_bool   0}");
	return err;
}

int
cdf_ptr13534(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_is_bool;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[26] both_bool{is_bool :is_bool   0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_bool->value)
		CHK(6, cleanup, L"[26] both_bool{is_bool :is_bool   0}");
	
	*stkhd++ = retain_cell(lex->cdf_is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[26] both_bool{is_bool :is_bool   0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[26] both_bool{is_bool :is_bool   0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[26] both_bool{is_bool :is_bool   0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_is_bool->value)
				CHK(6, cleanup, L"[26] both_bool{is_bool :is_bool   0}");
			
			*stkhd++ = retain_cell(lex->cdf_is_bool->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[26] both_bool{is_bool :is_bool   0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[26] both_bool{is_bool :is_bool   0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[26] both_bool{is_bool :is_bool   0}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[26] both_bool{is_bool :is_bool   0}");
	return err;
}

int
cdf_ptr13535(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct lex_vars {
		struct cell_func_box *cdf_both_numeric;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_numeric->value)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->cdf_both_numeric->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	return err;
}

int
cdf_ptr13536(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct lex_vars {
		struct cell_func_box *cdf_both_numeric;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_numeric->value)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->cdf_both_numeric->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	return err;
}

int
cdf_ptr13537(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct lex_vars {
		struct cell_func_box *cdf_both_numeric;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_numeric->value)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->cdf_both_numeric->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	return err;
}

int
cdf_ptr13538(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct lex_vars {
		struct cell_func_box *cdf_both_numeric;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_numeric->value)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->cdf_both_numeric->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[28] numeric{  (0)both_numeric :    SIGNAL 11}");
	return err;
}

int
cdf_ptr13539(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct lex_vars {
		struct cell_func_box *cdf_same;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_same->value)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(lex->cdf_same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[29] ambiv{  1 same  1:     }");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[29] ambiv{  1 same  1:     }");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[29] ambiv{  1 same  1:     }");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[29] ambiv{  1 same  1:     }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[29] ambiv{  1 same  1:     }");
	return err;
}

int
cdf_ptr13540(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct lex_vars {
		struct cell_func_box *cdf_same;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[29] ambiv{  1 same  1:     }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	if (!lex->cdf_same->value)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(lex->cdf_same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[29] ambiv{  1 same  1:     }");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[29] ambiv{  1 same  1:     }");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[29] ambiv{  1 same  1:     }");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[29] ambiv{  1 same  1:     }");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[29] ambiv{  1 same  1:     }");
	return err;
}

int
cdf_ptr13541(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct lex_vars {
		struct cell_func_box *cdf_same;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_same->value)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(lex->cdf_same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[29] ambiv{  1 same  1:     }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[29] ambiv{  1 same  1:     }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[29] ambiv{  1 same  1:     }");
	return err;
}

int
cdf_ptr13542(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct lex_vars {
		struct cell_func_box *cdf_same;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[29] ambiv{  1 same  1:     }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	if (!lex->cdf_same->value)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(lex->cdf_same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[29] ambiv{  1 same  1:     }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[29] ambiv{  1 same  1:     }");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[29] ambiv{  1 same  1:     }");
	return err;
}

int
cdf_ptr13543(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct lex_vars {
		struct cell_func_box *cdf_same;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_same->value)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(lex->cdf_same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[29] ambiv{  1 same  1:     }");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[29] ambiv{  1 same  1:     }");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[29] ambiv{  1 same  1:     }");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[29] ambiv{  1 same  1:     }");
	return err;
}

int
cdf_ptr13544(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct lex_vars {
		struct cell_func_box *cdf_same;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[29] ambiv{  1 same  1:     }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	if (!lex->cdf_same->value)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(lex->cdf_same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[29] ambiv{  1 same  1:     }");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[29] ambiv{  1 same  1:     }");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[29] ambiv{  1 same  1:     }");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[29] ambiv{  1 same  1:     }");
	return err;
}

int
cdf_ptr13545(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct lex_vars {
		struct cell_func_box *cdf_same;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_same->value)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(lex->cdf_same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[29] ambiv{  1 same  1:     }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[29] ambiv{  1 same  1:     }");
	return err;
}

int
cdf_ptr13546(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct lex_vars {
		struct cell_func_box *cdf_same;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[29] ambiv{  1 same  1:     }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	if (!lex->cdf_same->value)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(lex->cdf_same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] ambiv{  1 same  1:     }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[29] ambiv{  1 same  1:     }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[29] ambiv{  1 same  1:     }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] ambiv{  1 same  1:     }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[29] ambiv{  1 same  1:     }");
	return err;
}

int
cdf_ptr13547(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_veach;
		struct cell_func_box *cdf_both_simple;
		struct cell_func_box *cdf_chk_scl;
		struct cell_func_box *cdf_max_shp;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[32] 	 chk_scl : ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_chk_scl->value)
		CHK(6, cleanup, L"[32] 	 chk_scl : ");
	
	*stkhd++ = retain_cell(lex->cdf_chk_scl->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[32] 	 chk_scl : ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[32] 	 chk_scl : ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[32] 	 chk_scl : ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[33] 	s max_shp ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_max_shp->value)
		CHK(6, cleanup, L"[33] 	s max_shp ");
	
	*stkhd++ = retain_cell(lex->cdf_max_shp->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[33] 	s max_shp ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[33] 	s max_shp ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[34] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[34] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[34] 	0,:s0");
	
		CHK(fill_array(arr, dat), cleanup, L"[34] 	0,:s0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[34] 	0,:s0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[34] 	0,:s0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[34] 	0,:s0");
			
				CHK(fill_array(arr, dat), cleanup, L"[34] 	0,:s0");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[34] 	0,:s0");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[34] 	0,:s0");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[34] 	0,:s0");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[35] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[35] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[35] 	0,:s0");
	
		CHK(fill_array(arr, dat), cleanup, L"[35] 	0,:s0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[35] 	0,:s0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[35] 	0,:s0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[35] 	0,:s0");
			
				CHK(fill_array(arr, dat), cleanup, L"[35] 	0,:s0");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[35] 	0,:s0");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[35] 	0,:s0");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[35] 	0,:s0");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[36] 	 both_simple :s  ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_simple->value)
		CHK(6, cleanup, L"[36] 	 both_simple :s  ");
	
	*stkhd++ = retain_cell(lex->cdf_both_simple->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[36] 	 both_simple :s  ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[36] 	 both_simple :s  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[36] 	 both_simple :s  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[36] 	 both_simple :s  ");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[36] 	 both_simple :s  ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[36] 	 both_simple :s  ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[36] 	 both_simple :s  ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_veach->value)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(lex->cdf_veach->value);
	
	if (!cdf_self)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[31] scalar{");
	return err;
}

int
cdf_ptr13548(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_veach;
		struct cell_func_box *cdf_both_simple;
		struct cell_func_box *cdf_chk_scl;
		struct cell_func_box *cdf_max_shp;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[32] 	 chk_scl : ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_chk_scl->value)
		CHK(6, cleanup, L"[32] 	 chk_scl : ");
	
	*stkhd++ = retain_cell(lex->cdf_chk_scl->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[32] 	 chk_scl : ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[32] 	 chk_scl : ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[32] 	 chk_scl : ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[33] 	s max_shp ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_max_shp->value)
		CHK(6, cleanup, L"[33] 	s max_shp ");
	
	*stkhd++ = retain_cell(lex->cdf_max_shp->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[33] 	s max_shp ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[33] 	s max_shp ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[34] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[34] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[34] 	0,:s0");
	
		CHK(fill_array(arr, dat), cleanup, L"[34] 	0,:s0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[34] 	0,:s0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[34] 	0,:s0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[34] 	0,:s0");
			
				CHK(fill_array(arr, dat), cleanup, L"[34] 	0,:s0");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[34] 	0,:s0");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[34] 	0,:s0");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[34] 	0,:s0");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[35] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[35] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[35] 	0,:s0");
	
		CHK(fill_array(arr, dat), cleanup, L"[35] 	0,:s0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[35] 	0,:s0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[35] 	0,:s0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[35] 	0,:s0");
			
				CHK(fill_array(arr, dat), cleanup, L"[35] 	0,:s0");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[35] 	0,:s0");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[35] 	0,:s0");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[35] 	0,:s0");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[36] 	 both_simple :s  ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_simple->value)
		CHK(6, cleanup, L"[36] 	 both_simple :s  ");
	
	*stkhd++ = retain_cell(lex->cdf_both_simple->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[36] 	 both_simple :s  ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[36] 	 both_simple :s  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[36] 	 both_simple :s  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[36] 	 both_simple :s  ");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[36] 	 both_simple :s  ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[36] 	 both_simple :s  ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[36] 	 both_simple :s  ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_veach->value)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(lex->cdf_veach->value);
	
	if (!cdf_self)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[31] scalar{");
	return err;
}

int
cdf_ptr13549(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_veach;
		struct cell_func_box *cdf_both_simple;
		struct cell_func_box *cdf_chk_scl;
		struct cell_func_box *cdf_max_shp;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[32] 	 chk_scl : ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_chk_scl->value)
		CHK(6, cleanup, L"[32] 	 chk_scl : ");
	
	*stkhd++ = retain_cell(lex->cdf_chk_scl->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[32] 	 chk_scl : ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[32] 	 chk_scl : ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[32] 	 chk_scl : ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[33] 	s max_shp ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_max_shp->value)
		CHK(6, cleanup, L"[33] 	s max_shp ");
	
	*stkhd++ = retain_cell(lex->cdf_max_shp->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[33] 	s max_shp ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[33] 	s max_shp ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[34] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[34] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[34] 	0,:s0");
	
		CHK(fill_array(arr, dat), cleanup, L"[34] 	0,:s0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[34] 	0,:s0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[34] 	0,:s0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[34] 	0,:s0");
			
				CHK(fill_array(arr, dat), cleanup, L"[34] 	0,:s0");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[34] 	0,:s0");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[34] 	0,:s0");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[34] 	0,:s0");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[35] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[35] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[35] 	0,:s0");
	
		CHK(fill_array(arr, dat), cleanup, L"[35] 	0,:s0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[35] 	0,:s0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[35] 	0,:s0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[35] 	0,:s0");
			
				CHK(fill_array(arr, dat), cleanup, L"[35] 	0,:s0");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[35] 	0,:s0");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[35] 	0,:s0");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[35] 	0,:s0");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[36] 	 both_simple :s  ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_simple->value)
		CHK(6, cleanup, L"[36] 	 both_simple :s  ");
	
	*stkhd++ = retain_cell(lex->cdf_both_simple->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[36] 	 both_simple :s  ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[36] 	 both_simple :s  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[36] 	 both_simple :s  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[36] 	 both_simple :s  ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[36] 	 both_simple :s  ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_veach->value)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(lex->cdf_veach->value);
	
	if (!cdf_self)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[31] scalar{");
	return err;
}

int
cdf_ptr13550(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_veach;
		struct cell_func_box *cdf_both_simple;
		struct cell_func_box *cdf_chk_scl;
		struct cell_func_box *cdf_max_shp;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[32] 	 chk_scl : ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_chk_scl->value)
		CHK(6, cleanup, L"[32] 	 chk_scl : ");
	
	*stkhd++ = retain_cell(lex->cdf_chk_scl->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[32] 	 chk_scl : ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[32] 	 chk_scl : ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[32] 	 chk_scl : ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[33] 	s max_shp ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_max_shp->value)
		CHK(6, cleanup, L"[33] 	s max_shp ");
	
	*stkhd++ = retain_cell(lex->cdf_max_shp->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[33] 	s max_shp ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[33] 	s max_shp ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[34] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[34] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[34] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[34] 	0,:s0");
	
		CHK(fill_array(arr, dat), cleanup, L"[34] 	0,:s0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[34] 	0,:s0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[34] 	0,:s0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[34] 	0,:s0");
			
				CHK(fill_array(arr, dat), cleanup, L"[34] 	0,:s0");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[34] 	0,:s0");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[34] 	0,:s0");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[34] 	0,:s0");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[35] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[35] 	0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[35] 	0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[35] 	0,:s0");
	
		CHK(fill_array(arr, dat), cleanup, L"[35] 	0,:s0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[35] 	0,:s0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[35] 	0,:s0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[35] 	0,:s0");
			
				CHK(fill_array(arr, dat), cleanup, L"[35] 	0,:s0");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[35] 	0,:s0");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[35] 	0,:s0");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[35] 	0,:s0");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[36] 	 both_simple :s  ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_simple->value)
		CHK(6, cleanup, L"[36] 	 both_simple :s  ");
	
	*stkhd++ = retain_cell(lex->cdf_both_simple->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[36] 	 both_simple :s  ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[36] 	 both_simple :s  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[36] 	 both_simple :s  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[36] 	 both_simple :s  ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[36] 	 both_simple :s  ");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[36] 	 both_simple :s  ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_veach->value)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(lex->cdf_veach->value);
	
	if (!cdf_self)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[37] 	ssqueeze   veach ");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[37] 	ssqueeze   veach ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[31] scalar{");
	return err;
}

int
cdf_ptr13551(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_has_nat_vals;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13552, cdf_ptr13553, 0), cleanup, 
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[43] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[43] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[43] 	0,:0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[43] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[43] 	0,:0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[43] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[43] 	0,:0");
	
		CHK(fill_array(arr, dat), cleanup, L"[43] 	0,:0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[43] 	0,:0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[43] 	0,:0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[43] 	0,:0");
			
				CHK(fill_array(arr, dat), cleanup, L"[43] 	0,:0");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13554, cdf_ptr13555, 1), cleanup, 
		    L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		k->fv[0] = retain_cell(lex->cdf_has_nat_vals);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[45] 	0");
	
		CHK(fill_array(arr, dat), cleanup, L"[45] 	0");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[41] chk_valid_shape{");
	return err;
}

int
cdf_ptr13552(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_rnk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rnk);
	loc->cdf_rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_rnk)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_rnk);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_rnk)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_rnk);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	return err;
}

int
cdf_ptr13553(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_rnk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rnk);
	loc->cdf_rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_rnk)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_rnk);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_rnk)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_rnk);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	return err;
}

int
cdf_ptr13554(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_has_nat_vals;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_has_nat_vals->value)
		CHK(6, cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_has_nat_vals->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	return err;
}

int
cdf_ptr13555(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_has_nat_vals;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_has_nat_vals->value)
		CHK(6, cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_has_nat_vals->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	return err;
}

int
cdf_ptr13556(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_has_nat_vals;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13557, cdf_ptr13558, 0), cleanup, 
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[43] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[43] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[43] 	0,:0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[43] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[43] 	0,:0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[43] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[43] 	0,:0");
	
		CHK(fill_array(arr, dat), cleanup, L"[43] 	0,:0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[43] 	0,:0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[43] 	0,:0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[43] 	0,:0");
			
				CHK(fill_array(arr, dat), cleanup, L"[43] 	0,:0");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13559, cdf_ptr13560, 1), cleanup, 
		    L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		k->fv[0] = retain_cell(lex->cdf_has_nat_vals);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[45] 	0");
	
		CHK(fill_array(arr, dat), cleanup, L"[45] 	0");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[41] chk_valid_shape{");
	return err;
}

int
cdf_ptr13557(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_rnk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rnk);
	loc->cdf_rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_rnk)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_rnk);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_rnk)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_rnk);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	return err;
}

int
cdf_ptr13558(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_rnk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rnk);
	loc->cdf_rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_rnk)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_rnk);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_rnk)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_rnk);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[42] 	{rnk  0rnk:0  1rnk:0  1}:SIGNAL 4");
	return err;
}

int
cdf_ptr13559(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_has_nat_vals;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_has_nat_vals->value)
		CHK(6, cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_has_nat_vals->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	return err;
}

int
cdf_ptr13560(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_has_nat_vals;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_has_nat_vals->value)
		CHK(6, cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_has_nat_vals->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[44] 	{has_nat_vals :0  1}:SIGNAL 11");
	return err;
}

int
cdf_ptr13561(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_chk_valid_shape;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_chk_valid_shape->value)
		CHK(6, cleanup, L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
	*stkhd++ = retain_cell(lex->cdf_chk_valid_shape->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_reshape_ibeam)
		CHK(6, cleanup, L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
	*stkhd++ = retain_cell(cdf_reshape_ibeam);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	return err;
}

int
cdf_ptr13562(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_chk_valid_shape;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_chk_valid_shape->value)
		CHK(6, cleanup, L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
	*stkhd++ = retain_cell(lex->cdf_chk_valid_shape->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_reshape_ibeam)
		CHK(6, cleanup, L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
	*stkhd++ = retain_cell(cdf_reshape_ibeam);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[47] reshape{chk_valid_shape :  ('reshape_ibeam')}");
	return err;
}

int
cdf_ptr13563(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
			
				CHK(fill_array(arr, dat), cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	return err;
}

int
cdf_ptr13564(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
			
				CHK(fill_array(arr, dat), cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[51] idx_rnk_check{(),:SIGNAL 4  0}");
	return err;
}

int
cdf_ptr13565(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_idx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_any;
		struct cell_func_box *cdf_is_integer;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_idx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[53] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[53] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[53] 	0,:0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[53] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[53] 	0,:0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[53] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[53] 	0,:0");
	
		CHK(fill_array(arr, dat), cleanup, L"[53] 	0,:0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[53] 	0,:0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[53] 	0,:0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[53] 	0,:0");
			
				CHK(fill_array(arr, dat), cleanup, L"[53] 	0,:0");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx);
	loc->cdf_idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
		CHK(fill_array(arr, dat), cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_any->value)
		CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
	*stkhd++ = retain_cell(lex->cdf_any->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {3};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
			
				CHK(fill_array(arr, dat), cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[55] 	any(idx<0)<idx:SIGNAL 3");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[56] 	0");
	
		CHK(fill_array(arr, dat), cleanup, L"[56] 	0");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[52] idx_rng_check{");
	return err;
}

int
cdf_ptr13566(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_idx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_any;
		struct cell_func_box *cdf_is_integer;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_idx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[53] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[53] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[53] 	0,:0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[53] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[53] 	0,:0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[53] 	0,:0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[53] 	0,:0");
	
		CHK(fill_array(arr, dat), cleanup, L"[53] 	0,:0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[53] 	0,:0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[53] 	0,:0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[53] 	0,:0");
			
				CHK(fill_array(arr, dat), cleanup, L"[53] 	0,:0");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx);
	loc->cdf_idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[54] 	0is_integeridxsqueeze :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
		CHK(fill_array(arr, dat), cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_any->value)
		CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
	*stkhd++ = retain_cell(lex->cdf_any->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[55] 	any(idx<0)<idx:SIGNAL 3");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {3};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
			
				CHK(fill_array(arr, dat), cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[55] 	any(idx<0)<idx:SIGNAL 3");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[55] 	any(idx<0)<idx:SIGNAL 3");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[56] 	0");
	
		CHK(fill_array(arr, dat), cleanup, L"[56] 	0");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[52] idx_rng_check{");
	return err;
}

int
cdf_ptr13567(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_s;
		struct cell_array *cdf_c;
		struct cell_array *cdf_i;
		struct cell_array *cdf_o;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_idx_rng_check;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_s = NULL;
	loc->cdf_c = NULL;
	loc->cdf_i = NULL;
	loc->cdf_o = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_dis)
				CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_dis);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13568, cdf_ptr13569, 2), cleanup, 
				    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
				k->fv[0] = retain_cell(lex->cdf_idx_rng_check);
				k->fv[1] = retain_cell(lex->cdf_is_span);
			
				*stkhd++ = k;
			}
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			if (!cdf_prim.cdf_dis)
				CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_dis);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_tke)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_tke);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_c);
	loc->cdf_c = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13570, cdf_ptr13571, 2), cleanup, 
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		k->fv[0] = retain_cell(lex->cdf_idx_rng_check);
		k->fv[1] = retain_cell(lex->cdf_is_span);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_i);
	loc->cdf_i = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
		CHK(fill_array(arr, dat), cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_scf)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_scf);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_o);
	loc->cdf_o = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_o)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(loc->cdf_o);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
		CHK(fill_array(arr, dat), cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_tke)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_tke);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_i)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(loc->cdf_i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_oup)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_oup);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[58] flatten_idx{");
	return err;
}

int
cdf_ptr13568(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_idx_rng_check;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_idx_rng_check->value)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(lex->cdf_idx_rng_check->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	return err;
}

int
cdf_ptr13569(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_idx_rng_check;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_idx_rng_check->value)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(lex->cdf_idx_rng_check->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	return err;
}

int
cdf_ptr13570(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_idx_rng_check;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_iot)
				CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_iot);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_idx_rng_check->value)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(lex->cdf_idx_rng_check->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	return err;
}

int
cdf_ptr13571(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_idx_rng_check;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_iot)
				CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_iot);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_idx_rng_check->value)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(lex->cdf_idx_rng_check->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	return err;
}

int
cdf_ptr13572(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_s;
		struct cell_array *cdf_c;
		struct cell_array *cdf_i;
		struct cell_array *cdf_o;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_idx_rng_check;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_s = NULL;
	loc->cdf_c = NULL;
	loc->cdf_i = NULL;
	loc->cdf_o = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_dis)
				CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_dis);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13573, cdf_ptr13574, 2), cleanup, 
				    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
				k->fv[0] = retain_cell(lex->cdf_idx_rng_check);
				k->fv[1] = retain_cell(lex->cdf_is_span);
			
				*stkhd++ = k;
			}
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			if (!cdf_prim.cdf_dis)
				CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_dis);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_tke)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_tke);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_c);
	loc->cdf_c = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13575, cdf_ptr13576, 2), cleanup, 
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		k->fv[0] = retain_cell(lex->cdf_idx_rng_check);
		k->fv[1] = retain_cell(lex->cdf_is_span);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_i);
	loc->cdf_i = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
		CHK(fill_array(arr, dat), cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_scf)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_scf);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_o);
	loc->cdf_o = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_o)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(loc->cdf_o);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
		CHK(fill_array(arr, dat), cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_tke)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_tke);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_i)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(loc->cdf_i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_oup)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_oup);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[61] 	.+(ic1o),(cs)co1,s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[61] 	.+(ic1o),(cs)co1,s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[58] flatten_idx{");
	return err;
}

int
cdf_ptr13573(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_idx_rng_check;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_idx_rng_check->value)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(lex->cdf_idx_rng_check->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	return err;
}

int
cdf_ptr13574(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_idx_rng_check;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_idx_rng_check->value)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(lex->cdf_idx_rng_check->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[59] 	(1)1s:(s){is_span :   idx_rng_check :  }");
	return err;
}

int
cdf_ptr13575(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_idx_rng_check;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_iot)
				CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_iot);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_idx_rng_check->value)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(lex->cdf_idx_rng_check->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	return err;
}

int
cdf_ptr13576(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_idx_rng_check;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_iot)
				CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_iot);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_idx_rng_check->value)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(lex->cdf_idx_rng_check->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[60] 	i{is_span :   idx_rng_check :  }(c)s");
	return err;
}

int
cdf_ptr13577(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	return err;
}

int
cdf_ptr13578(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[63] idx_shp_check{1,:0  ():0  ():SIGNAL 5  SIGNAL 4}");
	return err;
}

int
cdf_ptr13579(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array_box *cdf_idx;
		struct cell_array *cdf_proto;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_idx_shp_check;
		struct cell_func_box *cdf_flatten_idx;
		struct cell_func_box *cdf_idx_rnk_check;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_array_box(&loc->cdf_idx, NULL), cleanup, L"Init mutable variable: loc->cdf_idx");
	loc->cdf_proto = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[65] 	 idx_rnk_check :");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!lex->cdf_idx_rnk_check->value)
		CHK(6, cleanup, L"[65] 	 idx_rnk_check :");
	
	*stkhd++ = retain_cell(lex->cdf_idx_rnk_check->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[65] 	 idx_rnk_check :");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[65] 	 idx_rnk_check :");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[65] 	 idx_rnk_check :");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[66] 	idx flatten_idx ");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!lex->cdf_flatten_idx->value)
		CHK(6, cleanup, L"[66] 	idx flatten_idx ");
	
	*stkhd++ = retain_cell(lex->cdf_flatten_idx->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[66] 	idx flatten_idx ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[66] 	idx flatten_idx ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx->value);
	loc->cdf_idx->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13580, cdf_ptr13581, 2), cleanup, 
		    L"[67] 	proto{is_span idx:  idx}");
	
		k->fv[0] = retain_cell(loc->cdf_idx);
		k->fv[1] = retain_cell(lex->cdf_is_span);
	
		*stkhd++ = k;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[67] 	proto{is_span idx:  idx}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_proto);
	loc->cdf_proto = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[68] 	proto idx_shp_check :");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_idx_shp_check->value)
		CHK(6, cleanup, L"[68] 	proto idx_shp_check :");
	
	*stkhd++ = retain_cell(lex->cdf_idx_shp_check->value);
	
	if (!loc->cdf_proto)
		CHK(6, cleanup, L"[68] 	proto idx_shp_check :");
	
	*stkhd++ = retain_cell(loc->cdf_proto);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[68] 	proto idx_shp_check :");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[68] 	proto idx_shp_check :");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_idx->value)
		CHK(6, cleanup, L"[69] 	idx");
	
	*stkhd++ = retain_cell(loc->cdf_idx->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[64] set_get_idx{");
	return err;
}

int
cdf_ptr13580(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_idx->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_idx->value);
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[67] 	proto{is_span idx:  idx}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[67] 	proto{is_span idx:  idx}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_idx->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_idx->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[67] 	proto{is_span idx:  idx}");
	return err;
}

int
cdf_ptr13581(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_idx->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_idx->value);
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[67] 	proto{is_span idx:  idx}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[67] 	proto{is_span idx:  idx}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_idx->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_idx->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[67] 	proto{is_span idx:  idx}");
	return err;
}

int
cdf_ptr13582(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array_box *cdf_idx;
		struct cell_array *cdf_proto;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_idx_shp_check;
		struct cell_func_box *cdf_flatten_idx;
		struct cell_func_box *cdf_idx_rnk_check;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_array_box(&loc->cdf_idx, NULL), cleanup, L"Init mutable variable: loc->cdf_idx");
	loc->cdf_proto = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[65] 	 idx_rnk_check :");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!lex->cdf_idx_rnk_check->value)
		CHK(6, cleanup, L"[65] 	 idx_rnk_check :");
	
	*stkhd++ = retain_cell(lex->cdf_idx_rnk_check->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[65] 	 idx_rnk_check :");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[65] 	 idx_rnk_check :");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[65] 	 idx_rnk_check :");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[66] 	idx flatten_idx ");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!lex->cdf_flatten_idx->value)
		CHK(6, cleanup, L"[66] 	idx flatten_idx ");
	
	*stkhd++ = retain_cell(lex->cdf_flatten_idx->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[66] 	idx flatten_idx ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[66] 	idx flatten_idx ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx->value);
	loc->cdf_idx->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13583, cdf_ptr13584, 2), cleanup, 
		    L"[67] 	proto{is_span idx:  idx}");
	
		k->fv[0] = retain_cell(loc->cdf_idx);
		k->fv[1] = retain_cell(lex->cdf_is_span);
	
		*stkhd++ = k;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[67] 	proto{is_span idx:  idx}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_proto);
	loc->cdf_proto = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[68] 	proto idx_shp_check :");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_idx_shp_check->value)
		CHK(6, cleanup, L"[68] 	proto idx_shp_check :");
	
	*stkhd++ = retain_cell(lex->cdf_idx_shp_check->value);
	
	if (!loc->cdf_proto)
		CHK(6, cleanup, L"[68] 	proto idx_shp_check :");
	
	*stkhd++ = retain_cell(loc->cdf_proto);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[68] 	proto idx_shp_check :");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[68] 	proto idx_shp_check :");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_idx->value)
		CHK(6, cleanup, L"[69] 	idx");
	
	*stkhd++ = retain_cell(loc->cdf_idx->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[64] set_get_idx{");
	return err;
}

int
cdf_ptr13583(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_idx->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_idx->value);
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[67] 	proto{is_span idx:  idx}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[67] 	proto{is_span idx:  idx}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_idx->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_idx->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[67] 	proto{is_span idx:  idx}");
	return err;
}

int
cdf_ptr13584(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_idx->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_idx->value);
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[67] 	proto{is_span idx:  idx}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[67] 	proto{is_span idx:  idx}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_idx->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_idx->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[67] 	proto{is_span idx:  idx}");
	return err;
}

int
cdf_ptr13585(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_func_box *cdf_idx;
		struct cell_array *cdf_proto;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_idx_shp_check;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_func_box(&loc->cdf_idx, NULL), cleanup, L"Init mutable variable: loc->cdf_idx");
	loc->cdf_proto = NULL;
	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[65] 	 idx_rnk_check :");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[65] 	 idx_rnk_check :");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	CHK(2, cleanup, L"[66] 	idx flatten_idx ");
	
	release_cell(loc->cdf_idx->value);
	loc->cdf_idx->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13586, cdf_ptr13587, 2), cleanup, 
		    L"[67] 	proto{is_span idx:  idx}");
	
		k->fv[0] = retain_cell(loc->cdf_idx);
		k->fv[1] = retain_cell(lex->cdf_is_span);
	
		*stkhd++ = k;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[67] 	proto{is_span idx:  idx}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_proto);
	loc->cdf_proto = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[68] 	proto idx_shp_check :");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_idx_shp_check->value)
		CHK(6, cleanup, L"[68] 	proto idx_shp_check :");
	
	*stkhd++ = retain_cell(lex->cdf_idx_shp_check->value);
	
	if (!loc->cdf_proto)
		CHK(6, cleanup, L"[68] 	proto idx_shp_check :");
	
	*stkhd++ = retain_cell(loc->cdf_proto);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[68] 	proto idx_shp_check :");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[68] 	proto idx_shp_check :");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_idx->value)
		CHK(6, cleanup, L"[69] 	idx");
	
	*stkhd++ = retain_cell(loc->cdf_idx->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[64] set_get_idx{");
	return err;
}

int
cdf_ptr13586(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_idx;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[67] 	proto{is_span idx:  idx}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_idx->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_idx->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[67] 	proto{is_span idx:  idx}");
	return err;
}

int
cdf_ptr13587(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_idx;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[67] 	proto{is_span idx:  idx}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_idx->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_idx->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[67] 	proto{is_span idx:  idx}");
	return err;
}

int
cdf_ptr13588(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_func_box *cdf_idx;
		struct cell_array *cdf_proto;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_idx_shp_check;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_func_box(&loc->cdf_idx, NULL), cleanup, L"Init mutable variable: loc->cdf_idx");
	loc->cdf_proto = NULL;
	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[65] 	 idx_rnk_check :");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[65] 	 idx_rnk_check :");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	CHK(2, cleanup, L"[66] 	idx flatten_idx ");
	
	release_cell(loc->cdf_idx->value);
	loc->cdf_idx->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13589, cdf_ptr13590, 2), cleanup, 
		    L"[67] 	proto{is_span idx:  idx}");
	
		k->fv[0] = retain_cell(loc->cdf_idx);
		k->fv[1] = retain_cell(lex->cdf_is_span);
	
		*stkhd++ = k;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[67] 	proto{is_span idx:  idx}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_proto);
	loc->cdf_proto = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[68] 	proto idx_shp_check :");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_idx_shp_check->value)
		CHK(6, cleanup, L"[68] 	proto idx_shp_check :");
	
	*stkhd++ = retain_cell(lex->cdf_idx_shp_check->value);
	
	if (!loc->cdf_proto)
		CHK(6, cleanup, L"[68] 	proto idx_shp_check :");
	
	*stkhd++ = retain_cell(loc->cdf_proto);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[68] 	proto idx_shp_check :");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[68] 	proto idx_shp_check :");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_idx->value)
		CHK(6, cleanup, L"[69] 	idx");
	
	*stkhd++ = retain_cell(loc->cdf_idx->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[64] set_get_idx{");
	return err;
}

int
cdf_ptr13589(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_idx;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[67] 	proto{is_span idx:  idx}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_idx->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_idx->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[67] 	proto{is_span idx:  idx}");
	return err;
}

int
cdf_ptr13590(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_idx;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[67] 	proto{is_span idx:  idx}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_idx->value)
		CHK(6, cleanup, L"[67] 	proto{is_span idx:  idx}");
	
	*stkhd++ = retain_cell(lex->cdf_idx->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[67] 	proto{is_span idx:  idx}");
	return err;
}

int
cdf_ptr13591(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array_box *cdf_op;
		struct cell_array *cdf_idx;
		struct cell_array *cdf_uidx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_set_get_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_array_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_idx = NULL;
	loc->cdf_uidx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[74] mst_vals{op");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_set_get_idx->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_set_get_idx->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx);
	loc->cdf_idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_idx)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_idx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!loc->cdf_op->value)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_op->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_unq)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_unq);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_uidx);
	loc->cdf_uidx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_brk)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_brk);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_key)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_key);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13592, cdf_ptr13593, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		k->fv[0] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[74] mst_vals{op");
	return err;
}

int
cdf_ptr13592(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13593(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13594(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array_box *cdf_op;
		struct cell_array *cdf_idx;
		struct cell_array *cdf_uidx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_set_get_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_array_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_idx = NULL;
	loc->cdf_uidx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[74] mst_vals{op");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_set_get_idx->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_set_get_idx->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx);
	loc->cdf_idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_idx)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_idx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!loc->cdf_op->value)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_op->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_unq)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_unq);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_uidx);
	loc->cdf_uidx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_brk)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_brk);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_key)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_key);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13595, cdf_ptr13596, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		k->fv[0] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[74] mst_vals{op");
	return err;
}

int
cdf_ptr13595(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13596(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13597(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array_box *cdf_op;
		struct cell_array *cdf_idx;
		struct cell_array *cdf_uidx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_set_get_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_array_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_idx = NULL;
	loc->cdf_uidx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[74] mst_vals{op");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_set_get_idx->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_set_get_idx->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx);
	loc->cdf_idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_idx)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_idx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!loc->cdf_op->value)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_op->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_unq)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_unq);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_uidx);
	loc->cdf_uidx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_brk)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_brk);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_key)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_key);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13598, cdf_ptr13599, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		k->fv[0] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[74] mst_vals{op");
	return err;
}

int
cdf_ptr13598(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13599(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13600(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array_box *cdf_op;
		struct cell_array *cdf_idx;
		struct cell_array *cdf_uidx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_set_get_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_array_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_idx = NULL;
	loc->cdf_uidx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[74] mst_vals{op");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_set_get_idx->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_set_get_idx->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx);
	loc->cdf_idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_idx)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_idx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!loc->cdf_op->value)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_op->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_unq)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_unq);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_uidx);
	loc->cdf_uidx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_brk)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_brk);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_key)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_key);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13601, cdf_ptr13602, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		k->fv[0] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[74] mst_vals{op");
	return err;
}

int
cdf_ptr13601(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13602(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13603(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func_box *cdf_op;
		struct cell_array *cdf_idx;
		struct cell_array *cdf_uidx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_set_get_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_idx = NULL;
	loc->cdf_uidx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[74] mst_vals{op");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_set_get_idx->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_set_get_idx->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx);
	loc->cdf_idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_idx)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_idx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!loc->cdf_op->value)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_op->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_unq)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_unq);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_uidx);
	loc->cdf_uidx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_brk)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_brk);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_key)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_key);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13604, cdf_ptr13605, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		k->fv[0] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[74] mst_vals{op");
	return err;
}

int
cdf_ptr13604(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13605(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13606(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func_box *cdf_op;
		struct cell_array *cdf_idx;
		struct cell_array *cdf_uidx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_set_get_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_idx = NULL;
	loc->cdf_uidx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[74] mst_vals{op");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_set_get_idx->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_set_get_idx->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx);
	loc->cdf_idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_idx)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_idx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!loc->cdf_op->value)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_op->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_unq)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_unq);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_uidx);
	loc->cdf_uidx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_brk)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_brk);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_key)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_key);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13607, cdf_ptr13608, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		k->fv[0] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[74] mst_vals{op");
	return err;
}

int
cdf_ptr13607(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13608(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13609(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func_box *cdf_op;
		struct cell_array *cdf_idx;
		struct cell_array *cdf_uidx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_set_get_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_idx = NULL;
	loc->cdf_uidx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[74] mst_vals{op");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_set_get_idx->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_set_get_idx->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx);
	loc->cdf_idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_idx)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_idx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!loc->cdf_op->value)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_op->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_unq)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_unq);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_uidx);
	loc->cdf_uidx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_brk)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_brk);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_key)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_key);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13610, cdf_ptr13611, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		k->fv[0] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[74] mst_vals{op");
	return err;
}

int
cdf_ptr13610(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13611(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13612(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func_box *cdf_op;
		struct cell_array *cdf_idx;
		struct cell_array *cdf_uidx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_set_get_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_idx = NULL;
	loc->cdf_uidx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[74] mst_vals{op");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_set_get_idx->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_set_get_idx->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx);
	loc->cdf_idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[75] 	is_spanidx( set_get_idx):idx(, op)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_idx)
				CHK(6, cleanup, L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
			*stkhd++ = retain_cell(loc->cdf_idx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[75] 	is_spanidx( set_get_idx):idx(, op)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!loc->cdf_op->value)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_op->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[76] 	(,idx)((,)[,idx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[76] 	(,idx)((,)[,idx] op,)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[76] 	(,idx)((,)[,idx] op,)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_unq)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_unq);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_uidx);
	loc->cdf_uidx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!loc->cdf_op->value)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_op->value);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_brk)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_brk);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_uidx)
				CHK(6, cleanup, L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
			*stkhd++ = retain_cell(loc->cdf_uidx);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[77] 	(idx)uidxidx:uidx((,)[uidx] op,)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_key)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_key);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13613, cdf_ptr13614, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		k->fv[0] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_uidx)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(loc->cdf_uidx);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[74] mst_vals{op");
	return err;
}

int
cdf_ptr13613(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13614(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] 	uidx((uidx,idx){op}(,)[uidx],)");
	return err;
}

int
cdf_ptr13615(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array_box *cdf_i;
		struct cell_array *cdf_axis;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_flatten_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	struct opt_vars {
		struct cell_array *cdf_axis;
	} *opts;

	opts = (struct opt_vars *)cdf_self->opts;

	CHK(mk_array_box(&loc->cdf_i, NULL), cleanup, L"Init mutable variable: loc->cdf_i");
	loc->cdf_axis = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_i->value);
	loc->cdf_i->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_i->value)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_i->value);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (opts && opts->cdf_axis) {
		*stkhd++ = retain_cell(opts->cdf_axis);
	} else {
		{
			struct cell_array *arr;
		
			enum array_type typ = ARR_SINT;
			unsigned int rnk = 0;
			int16_t dat[] = {0};
		
			CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[84] 	axis0");
		
			CHK(fill_array(arr, dat), cleanup, L"[84] 	axis0");
		
			*stkhd++ = arr;
		}
		
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[85] 	axis0:{");
	
		CHK(fill_array(arr, dat), cleanup, L"[85] 	axis0:{");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[85] 	axis0:{");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[85] 	axis0:{");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[85] 	axis0:{");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[85] 	axis0:{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[89] 	}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13616, cdf_ptr13617, 3), cleanup, 
				    L"[85] 	axis0:{");
			
				k->fv[0] = retain_cell(loc->cdf_i);
				k->fv[1] = retain_cell(lex->cdf_flatten_idx);
				k->fv[2] = retain_cell(lex->cdf_is_span);
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[85] 	axis0:{");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[85] 	axis0:{");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[85] 	axis0:{");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[90] 	i  i[axis]  i");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[90] 	i  i[axis]  i");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[90] 	i  i[axis]  i");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_i->value);
	loc->cdf_i->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	CHK(2, cleanup, L"[90] 	i  i[axis]  i");
	
	*z = *--stkhd;
	goto cleanup;
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!loc->cdf_i->value)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(loc->cdf_i->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[90] 	i  i[axis]  i");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	return err;
}

int
cdf_ptr13616(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_idx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_i;
		struct cell_func_box *cdf_flatten_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_idx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_i->value)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(lex->cdf_i->value);
	
	if (!lex->cdf_flatten_idx->value)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(lex->cdf_flatten_idx->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[86] 		is_spanidx flatten_idx i:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx);
	loc->cdf_idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[86] 		is_spanidx flatten_idx i:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[86] 		is_spanidx flatten_idx i:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[85] 	axis0:{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 		0,idx:(idx)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 		0,idx:(idx)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[87] 		0,idx:(idx)");
	
		CHK(fill_array(arr, dat), cleanup, L"[87] 		0,idx:(idx)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[87] 		0,idx:(idx)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[86] 		is_spanidx flatten_idx i:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_idx)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(loc->cdf_idx);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[87] 		0,idx:(idx)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[87] 		0,idx:(idx)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_index_ibeam)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_index_ibeam);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[88] 		(idx)idx('index_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[88] 		(idx)idx('index_ibeam')");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[88] 		(idx)idx('index_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[85] 	axis0:{");
	return err;
}

int
cdf_ptr13617(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_idx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_i;
		struct cell_func_box *cdf_flatten_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_idx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_i->value)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(lex->cdf_i->value);
	
	if (!lex->cdf_flatten_idx->value)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(lex->cdf_flatten_idx->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[86] 		is_spanidx flatten_idx i:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx);
	loc->cdf_idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[86] 		is_spanidx flatten_idx i:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[86] 		is_spanidx flatten_idx i:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[88] 		(idx)idx('index_ibeam')");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 		0,idx:(idx)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 		0,idx:(idx)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[87] 		0,idx:(idx)");
	
		CHK(fill_array(arr, dat), cleanup, L"[87] 		0,idx:(idx)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[87] 		0,idx:(idx)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[86] 		is_spanidx flatten_idx i:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_idx)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(loc->cdf_idx);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[87] 		0,idx:(idx)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[87] 		0,idx:(idx)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_index_ibeam)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_index_ibeam);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[88] 		(idx)idx('index_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[88] 		(idx)idx('index_ibeam')");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[88] 		(idx)idx('index_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[85] 	axis0:{");
	return err;
}

int
cdf_ptr13618(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array_box *cdf_i;
		struct cell_array *cdf_axis;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_flatten_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	struct opt_vars {
		struct cell_array *cdf_axis;
	} *opts;

	opts = (struct opt_vars *)cdf_self->opts;

	CHK(mk_array_box(&loc->cdf_i, NULL), cleanup, L"Init mutable variable: loc->cdf_i");
	loc->cdf_axis = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_i->value);
	loc->cdf_i->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_i->value)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_i->value);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (opts && opts->cdf_axis) {
		*stkhd++ = retain_cell(opts->cdf_axis);
	} else {
		{
			struct cell_array *arr;
		
			enum array_type typ = ARR_SINT;
			unsigned int rnk = 0;
			int16_t dat[] = {0};
		
			CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[84] 	axis0");
		
			CHK(fill_array(arr, dat), cleanup, L"[84] 	axis0");
		
			*stkhd++ = arr;
		}
		
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[85] 	axis0:{");
	
		CHK(fill_array(arr, dat), cleanup, L"[85] 	axis0:{");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[85] 	axis0:{");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[85] 	axis0:{");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[85] 	axis0:{");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[85] 	axis0:{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[89] 	}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13619, cdf_ptr13620, 3), cleanup, 
				    L"[85] 	axis0:{");
			
				k->fv[0] = retain_cell(loc->cdf_i);
				k->fv[1] = retain_cell(lex->cdf_flatten_idx);
				k->fv[2] = retain_cell(lex->cdf_is_span);
			
				*stkhd++ = k;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[85] 	axis0:{");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[85] 	axis0:{");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[90] 	i  i[axis]  i");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[90] 	i  i[axis]  i");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[90] 	i  i[axis]  i");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_i->value);
	loc->cdf_i->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[90] 	i  i[axis]  i");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[90] 	i  i[axis]  i");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[90] 	i  i[axis]  i");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->cdf_i;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[90] 	i  i[axis]  i");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!loc->cdf_i->value)
		CHK(6, cleanup, L"[90] 	i  i[axis]  i");
	
	*stkhd++ = retain_cell(loc->cdf_i->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[90] 	i  i[axis]  i");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[83] sqd{  1 1:  1<i0:SIGNAL 4  ()<i:SIGNAL 5");
	return err;
}

int
cdf_ptr13619(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_idx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_i;
		struct cell_func_box *cdf_flatten_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_idx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_i->value)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(lex->cdf_i->value);
	
	if (!lex->cdf_flatten_idx->value)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(lex->cdf_flatten_idx->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[86] 		is_spanidx flatten_idx i:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx);
	loc->cdf_idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[86] 		is_spanidx flatten_idx i:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[86] 		is_spanidx flatten_idx i:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[85] 	axis0:{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 		0,idx:(idx)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 		0,idx:(idx)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[87] 		0,idx:(idx)");
	
		CHK(fill_array(arr, dat), cleanup, L"[87] 		0,idx:(idx)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[87] 		0,idx:(idx)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[86] 		is_spanidx flatten_idx i:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_idx)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(loc->cdf_idx);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[87] 		0,idx:(idx)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[87] 		0,idx:(idx)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_index_ibeam)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_index_ibeam);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[88] 		(idx)idx('index_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[88] 		(idx)idx('index_ibeam')");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[88] 		(idx)idx('index_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[85] 	axis0:{");
	return err;
}

int
cdf_ptr13620(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_idx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_i;
		struct cell_func_box *cdf_flatten_idx;
		struct cell_func_box *cdf_is_span;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_idx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_i->value)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(lex->cdf_i->value);
	
	if (!lex->cdf_flatten_idx->value)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(lex->cdf_flatten_idx->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[86] 		is_spanidx flatten_idx i:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_idx);
	loc->cdf_idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[86] 		is_spanidx flatten_idx i:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_span->value)
		CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
	
	*stkhd++ = retain_cell(lex->cdf_is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[86] 		is_spanidx flatten_idx i:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[88] 		(idx)idx('index_ibeam')");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[86] 		is_spanidx flatten_idx i:");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 		0,idx:(idx)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 		0,idx:(idx)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[87] 		0,idx:(idx)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[87] 		0,idx:(idx)");
	
		CHK(fill_array(arr, dat), cleanup, L"[87] 		0,idx:(idx)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[87] 		0,idx:(idx)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[86] 		is_spanidx flatten_idx i:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_idx)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(loc->cdf_idx);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[87] 		0,idx:(idx)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[87] 		0,idx:(idx)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[87] 		0,idx:(idx)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_index_ibeam)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_index_ibeam);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[88] 		(idx)idx('index_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_idx)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(loc->cdf_idx);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[88] 		(idx)idx('index_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[88] 		(idx)idx('index_ibeam')");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[88] 		(idx)idx('index_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[85] 	axis0:{");
	return err;
}

int
cdf_ptr13621(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_idx_rnk_check;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[94] brk{ idx_rnk_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_idx_rnk_check->value)
		CHK(6, cleanup, L"[94] brk{ idx_rnk_check :  }");
	
	*stkhd++ = retain_cell(lex->cdf_idx_rnk_check->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[94] brk{ idx_rnk_check :  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] brk{ idx_rnk_check :  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[94] brk{ idx_rnk_check :  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[94] brk{ idx_rnk_check :  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[94] brk{ idx_rnk_check :  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[94] brk{ idx_rnk_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] brk{ idx_rnk_check :  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[94] brk{ idx_rnk_check :  }");
	return err;
}

int
cdf_ptr13622(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_idx_rnk_check;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[94] brk{ idx_rnk_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_idx_rnk_check->value)
		CHK(6, cleanup, L"[94] brk{ idx_rnk_check :  }");
	
	*stkhd++ = retain_cell(lex->cdf_idx_rnk_check->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[94] brk{ idx_rnk_check :  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] brk{ idx_rnk_check :  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[94] brk{ idx_rnk_check :  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[94] brk{ idx_rnk_check :  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[94] brk{ idx_rnk_check :  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[94] brk{ idx_rnk_check :  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] brk{ idx_rnk_check :  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[94] brk{ idx_rnk_check :  }");
	return err;
}

int
cdf_ptr13623(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[97] rgt{}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[97] rgt{}");
	return err;
}

int
cdf_ptr13624(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[97] rgt{}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[97] rgt{}");
	return err;
}

int
cdf_ptr13625(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[100] lft{} ambiv {}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[100] lft{} ambiv {}");
	return err;
}

int
cdf_ptr13626(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[100] lft{} ambiv {}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[100] lft{} ambiv {}");
	return err;
}

int
cdf_ptr13627(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[100] lft{} ambiv {}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[100] lft{} ambiv {}");
	return err;
}

int
cdf_ptr13628(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[100] lft{} ambiv {}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[100] lft{} ambiv {}");
	return err;
}

int
cdf_ptr13629(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array_box *cdf_noax;
		struct cell_array *cdf_israv;
		struct cell_array_box *cdf_lr;
		struct cell_array_box *cdf_rr;
		struct cell_array_box *cdf_axis;
		struct cell_array *cdf_rk;
		struct cell_array *cdf_ar;
		struct cell_array *cdf_noscl;
		struct cell_array_box *cdf_fx;
		struct cell_array *cdf_x;
		struct cell_array *cdf_y;
		struct cell_array *cdf_m;
		struct cell_array_box *cdf_s;
		struct cell_array *cdf_ca;
		struct cell_array *cdf_cb;
		struct cell_array *cdf_cc;
		struct cell_array *cdf_lx;
		struct cell_array *cdf_rx;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_is_numeric;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	struct opt_vars {
		struct cell_array_box *cdf_axis;
	} *opts;

	opts = (struct opt_vars *)cdf_self->opts;

	CHK(mk_array_box(&loc->cdf_noax, NULL), cleanup, L"Init mutable variable: loc->cdf_noax");
	loc->cdf_israv = NULL;
	CHK(mk_array_box(&loc->cdf_lr, NULL), cleanup, L"Init mutable variable: loc->cdf_lr");
	CHK(mk_array_box(&loc->cdf_rr, NULL), cleanup, L"Init mutable variable: loc->cdf_rr");
	CHK(mk_array_box(&loc->cdf_axis, NULL), cleanup, L"Init mutable variable: loc->cdf_axis");
	loc->cdf_rk = NULL;
	loc->cdf_ar = NULL;
	loc->cdf_noscl = NULL;
	CHK(mk_array_box(&loc->cdf_fx, NULL), cleanup, L"Init mutable variable: loc->cdf_fx");
	loc->cdf_x = NULL;
	loc->cdf_y = NULL;
	loc->cdf_m = NULL;
	CHK(mk_array_box(&loc->cdf_s, NULL), cleanup, L"Init mutable variable: loc->cdf_s");
	loc->cdf_ca = NULL;
	loc->cdf_cb = NULL;
	loc->cdf_cc = NULL;
	loc->cdf_lx = NULL;
	loc->cdf_rx = NULL;
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
		CHK(fill_array(arr, dat), cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_noax->value);
	loc->cdf_noax->value = retain_cell(stkhd[-1]);
	
	release_cell(loc->cdf_israv);
	loc->cdf_israv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
		CHK(fill_array(arr, dat), cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_israv);
	loc->cdf_israv = retain_cell(stkhd[-1]);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lr->value);
	loc->cdf_lr->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rr->value);
	loc->cdf_rr->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (opts && opts->cdf_axis) {
		*stkhd++ = retain_cell(opts->cdf_axis);
	} else {
		{
			struct cell_array *arr;
		
			enum array_type typ = ARR_SINT;
			unsigned int rnk = 0;
			int16_t dat[] = {1};
		
			CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
		
			CHK(fill_array(arr, dat), cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
		
			*stkhd++ = arr;
		}
		
		release_cell(loc->cdf_noax->value);
		loc->cdf_noax->value = retain_cell(stkhd[-1]);
		
	}
	
	release_cell(loc->cdf_axis->value);
	loc->cdf_axis->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_israv)
		CHK(6, cleanup, L"[105] 	israv:{");
	
	*stkhd++ = retain_cell(loc->cdf_israv);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[105] 	israv:{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[110] 	}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13630, cdf_ptr13631, 2), cleanup, 
				    L"[105] 	israv:{");
			
				k->fv[0] = retain_cell(loc->cdf_noax);
				k->fv[1] = retain_cell(loc->cdf_axis);
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[105] 	israv:{");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_rr->value)
		CHK(6, cleanup, L"[111] 	rklrrr  axis1+rk");
	
	*stkhd++ = retain_cell(loc->cdf_rr->value);
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[111] 	rklrrr  axis1+rk");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	if (!loc->cdf_lr->value)
		CHK(6, cleanup, L"[111] 	rklrrr  axis1+rk");
	
	*stkhd++ = retain_cell(loc->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[111] 	rklrrr  axis1+rk");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rk);
	loc->cdf_rk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (opts && opts->cdf_axis) {
		*stkhd++ = retain_cell(opts->cdf_axis);
	} else {
		if (!loc->cdf_rk)
			CHK(6, cleanup, L"[111] 	rklrrr  axis1+rk");
		
		*stkhd++ = retain_cell(loc->cdf_rk);
		
		if (!cdf_prim.cdf_add)
			CHK(6, cleanup, L"[111] 	rklrrr  axis1+rk");
		
		*stkhd++ = retain_cell(cdf_prim.cdf_add);
		
		{
			struct cell_array *arr;
		
			enum array_type typ = ARR_SINT;
			unsigned int rnk = 0;
			int16_t dat[] = {-1};
		
			CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[111] 	rklrrr  axis1+rk");
		
			CHK(fill_array(arr, dat), cleanup, L"[111] 	rklrrr  axis1+rk");
		
			*stkhd++ = arr;
		}
		
		{
			struct cell_array *x = stkhd[-1];
			struct cell_func *fn = stkhd[-2];
			struct cell_array *y = stkhd[-3];
			struct cell_array *dst;
		
			CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
			    L"[111] 	rklrrr  axis1+rk");
		
			release_array(x);
			release_func(fn);
			release_array(y);
		
			stkhd -= 3;
			*stkhd++ = dst;
		}
		
	}
	
	release_cell(loc->cdf_axis->value);
	loc->cdf_axis->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_rr->value)
		CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
	*stkhd++ = retain_cell(loc->cdf_rr->value);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
		CHK(fill_array(arr, dat), cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[112] 	(0lr)(0rr):(,),,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!loc->cdf_lr->value)
		CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
	*stkhd++ = retain_cell(loc->cdf_lr->value);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
		CHK(fill_array(arr, dat), cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[112] 	(0lr)(0rr):(,),,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[112] 	(0lr)(0rr):(,),,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[112] 	(0lr)(0rr):(,),,");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[112] 	(0lr)(0rr):(,),,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[112] 	(0lr)(0rr):(,),,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[112] 	(0lr)(0rr):(,),,");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_axis->value)
		CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
	*stkhd++ = retain_cell(loc->cdf_axis->value);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_ar);
	loc->cdf_ar = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
				CHK(fill_array(arr, dat), cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_axis->value)
		CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
	*stkhd++ = retain_cell(loc->cdf_axis->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		CHK(fill_array(arr, dat), cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
				CHK(fill_array(arr, dat), cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_axis->value)
		CHK(6, cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
	*stkhd++ = retain_cell(loc->cdf_axis->value);
	
	if (!lex->cdf_is_numeric->value)
		CHK(6, cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lte)
		CHK(6, cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lte);
	
	if (!loc->cdf_axis->value)
		CHK(6, cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
	*stkhd++ = retain_cell(loc->cdf_axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_rk)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_rk);
	
	if (!cdf_prim.cdf_gte)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_gte);
	
	if (!loc->cdf_axis->value)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!loc->cdf_rr->value)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!loc->cdf_lr->value)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_noscl);
	loc->cdf_noscl = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!loc->cdf_rr->value)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_rr->value);
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_lr->value)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_axis->value)
		CHK(6, cleanup, L"[116] 	axisfxaxis:{");
	
	*stkhd++ = retain_cell(loc->cdf_axis->value);
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[116] 	axisfxaxis:{");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[116] 	axisfxaxis:{");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_fx->value);
	loc->cdf_fx->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[116] 	axisfxaxis:{");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!loc->cdf_axis->value)
		CHK(6, cleanup, L"[116] 	axisfxaxis:{");
	
	*stkhd++ = retain_cell(loc->cdf_axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[116] 	axisfxaxis:{");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[116] 	axisfxaxis:{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[119] 	}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13632, cdf_ptr13633, 4), cleanup, 
				    L"[116] 	axisfxaxis:{");
			
				k->fv[0] = retain_cell(loc->cdf_fx);
				k->fv[1] = retain_cell(loc->cdf_rr);
				k->fv[2] = retain_cell(loc->cdf_lr);
				k->fv[3] = retain_cell(loc->cdf_axis);
			
				*stkhd++ = k;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[116] 	axisfxaxis:{");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[116] 	axisfxaxis:{");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		CHK(fill_array(arr, dat), cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lte)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lte);
	
	if (!loc->cdf_rr->value)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		CHK(fill_array(arr, dat), cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lte)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lte);
	
	if (!loc->cdf_lr->value)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13634, cdf_ptr13635, 0), cleanup, 
				    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
			
				*stkhd++ = k;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13636, cdf_ptr13637, 3), cleanup, 
		    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		k->fv[0] = retain_cell(loc->cdf_fx);
		k->fv[1] = retain_cell(loc->cdf_rr);
		k->fv[2] = retain_cell(loc->cdf_lr);
	
		*stkhd++ = k;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_x);
	loc->cdf_x = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13638, cdf_ptr13639, 3), cleanup, 
		    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		k->fv[0] = retain_cell(loc->cdf_fx);
		k->fv[1] = retain_cell(loc->cdf_rr);
		k->fv[2] = retain_cell(loc->cdf_lr);
	
		*stkhd++ = k;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_y);
	loc->cdf_y = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_rk)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_rk);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_m);
	loc->cdf_m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!cdf_prim.cdf_dot)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dot);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_x)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_x);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[123] 	(mx).mymfxrk:SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_x)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(loc->cdf_x);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s->value);
	loc->cdf_s->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!loc->cdf_x)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(loc->cdf_x);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->cdf_s;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_s->value);
	
	if (!cdf_prim.cdf_tke)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_tke);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_ca);
	loc->cdf_ca = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_s->value);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_cb);
	loc->cdf_cb = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_s->value);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		CHK(fill_array(arr, dat), cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_cc);
	loc->cdf_cc = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_x)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_x);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lx);
	loc->cdf_lx = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rx);
	loc->cdf_rx = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_cc)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_cc);
	
	if (!loc->cdf_cb)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_cb);
	
	if (!loc->cdf_ca)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_ca);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_x)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_x);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_cc)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_cc);
	
	if (!loc->cdf_lx)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_lx);
	
	if (!loc->cdf_ca)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_ca);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	if (!loc->cdf_lx)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_lx);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_cc)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_cc);
	
	if (!loc->cdf_rx)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_rx);
	
	if (!loc->cdf_ca)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_ca);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	if (!loc->cdf_rx)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_rx);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_lx)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_lx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[127] 	sz");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[127] 	sz");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_s->value)
		CHK(6, cleanup, L"[127] 	sz");
	
	*stkhd++ = retain_cell(loc->cdf_s->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[127] 	sz");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[103] cat{");
	return err;
}

int
cdf_ptr13630(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_s;
		struct cell_array *cdf_pr;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_noax;
		struct cell_array_box *cdf_axis;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_s = NULL;
	loc->cdf_pr = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_noax->value)
		CHK(6, cleanup, L"[106] 		noax:'ravel_ibeam' ");
	
	*stkhd++ = retain_cell(lex->cdf_noax->value);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[105] 	israv:{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[106] 		noax:'ravel_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_ravel_ibeam)
				CHK(6, cleanup, L"[106] 		noax:'ravel_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_ravel_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[106] 		noax:'ravel_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[107] 		1,axis:SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[107] 		1,axis:SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[107] 		1,axis:SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[107] 		1,axis:SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[107] 		1,axis:SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[106] 		noax:'ravel_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[107] 		1,axis:SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[107] 		1,axis:SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[107] 		1,axis:SIGNAL 16");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[108] 		axis=axis:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[108] 		axis=axis:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[107] 		1,axis:SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[108] 		axis=axis:");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_pr);
	loc->cdf_pr = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[109] 		((prs),1,(praxis)s)");
	
		CHK(fill_array(arr, dat), cleanup, L"[109] 		((prs),1,(praxis)s)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_tke)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_tke);
	
	if (!loc->cdf_pr)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(loc->cdf_pr);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[105] 	israv:{");
	return err;
}

int
cdf_ptr13631(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_s;
		struct cell_array *cdf_pr;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_noax;
		struct cell_array_box *cdf_axis;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_s = NULL;
	loc->cdf_pr = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_noax->value)
		CHK(6, cleanup, L"[106] 		noax:'ravel_ibeam' ");
	
	*stkhd++ = retain_cell(lex->cdf_noax->value);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[106] 		noax:'ravel_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_ravel_ibeam)
				CHK(6, cleanup, L"[106] 		noax:'ravel_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_ravel_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[106] 		noax:'ravel_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[107] 		1,axis:SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[107] 		1,axis:SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[107] 		1,axis:SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[107] 		1,axis:SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[107] 		1,axis:SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[106] 		noax:'ravel_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[107] 		1,axis:SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[107] 		1,axis:SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[107] 		1,axis:SIGNAL 16");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[108] 		axis=axis:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[108] 		axis=axis:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[107] 		1,axis:SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[108] 		axis=axis:");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_pr);
	loc->cdf_pr = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[109] 		((prs),1,(praxis)s)");
	
		CHK(fill_array(arr, dat), cleanup, L"[109] 		((prs),1,(praxis)s)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_tke)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_tke);
	
	if (!loc->cdf_pr)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(loc->cdf_pr);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[105] 	israv:{");
	return err;
}

int
cdf_ptr13632(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_fx;
		struct cell_array_box *cdf_rr;
		struct cell_array_box *cdf_lr;
		struct cell_array_box *cdf_axis;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[116] 	axisfxaxis:{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_pow)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_pow);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_fx->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_fx->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_pow)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_pow);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[116] 	axisfxaxis:{");
	return err;
}

int
cdf_ptr13633(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_fx;
		struct cell_array_box *cdf_rr;
		struct cell_array_box *cdf_lr;
		struct cell_array_box *cdf_axis;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_pow)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_pow);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_fx->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_fx->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_pow)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_pow);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[116] 	axisfxaxis:{");
	return err;
}

int
cdf_ptr13634(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_rc;
		struct cell_array *cdf_lc;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_rc = NULL;
	loc->cdf_lc = NULL;
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rc);
	loc->cdf_rc = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lc);
	loc->cdf_lc = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!loc->cdf_rc)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_rc);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_lc)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_lc);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	return err;
}

int
cdf_ptr13635(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_rc;
		struct cell_array *cdf_lc;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_rc = NULL;
	loc->cdf_lc = NULL;
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rc);
	loc->cdf_rc = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lc);
	loc->cdf_lc = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!loc->cdf_rc)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_rc);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_lc)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_lc);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	return err;
}

int
cdf_ptr13636(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array_box *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_fx;
		struct cell_array_box *cdf_rr;
		struct cell_array_box *cdf_lr;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	CHK(mk_array_box(&loc->cdf_s, NULL), cleanup, L"Init mutable variable: loc->cdf_s");
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->cdf_s->value);
			loc->cdf_s->value = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_set)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_set);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array_box *bx = loc->cdf_s;
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *orig = bx->value;
			
				CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(orig);
				release_array(x);
				release_func(fn);
				stkhd -= 2;
			}
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s->value)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(loc->cdf_s->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *aa = stkhd[-1];
				struct cell_array *axis = stkhd[-2];
				struct cell_func *dst;
			
				CHK(derive_func_opts(&dst, aa, 1), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				dst->opts[0] = axis;
			
				release_func(aa);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	return err;
}

int
cdf_ptr13637(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array_box *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_fx;
		struct cell_array_box *cdf_rr;
		struct cell_array_box *cdf_lr;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	CHK(mk_array_box(&loc->cdf_s, NULL), cleanup, L"Init mutable variable: loc->cdf_s");
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->cdf_s->value);
			loc->cdf_s->value = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_set)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_set);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array_box *bx = loc->cdf_s;
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *orig = bx->value;
			
				CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(orig);
				release_array(x);
				release_func(fn);
				stkhd -= 2;
			}
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s->value)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(loc->cdf_s->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *aa = stkhd[-1];
				struct cell_array *axis = stkhd[-2];
				struct cell_func *dst;
			
				CHK(derive_func_opts(&dst, aa, 1), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				dst->opts[0] = axis;
			
				release_func(aa);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	return err;
}

int
cdf_ptr13638(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array_box *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_fx;
		struct cell_array_box *cdf_rr;
		struct cell_array_box *cdf_lr;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	CHK(mk_array_box(&loc->cdf_s, NULL), cleanup, L"Init mutable variable: loc->cdf_s");
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->cdf_s->value);
			loc->cdf_s->value = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_set)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_set);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array_box *bx = loc->cdf_s;
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *orig = bx->value;
			
				CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(orig);
				release_array(x);
				release_func(fn);
				stkhd -= 2;
			}
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s->value)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(loc->cdf_s->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *aa = stkhd[-1];
				struct cell_array *axis = stkhd[-2];
				struct cell_func *dst;
			
				CHK(derive_func_opts(&dst, aa, 1), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				dst->opts[0] = axis;
			
				release_func(aa);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	return err;
}

int
cdf_ptr13639(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array_box *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_fx;
		struct cell_array_box *cdf_rr;
		struct cell_array_box *cdf_lr;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	CHK(mk_array_box(&loc->cdf_s, NULL), cleanup, L"Init mutable variable: loc->cdf_s");
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->cdf_s->value);
			loc->cdf_s->value = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_set)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_set);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array_box *bx = loc->cdf_s;
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *orig = bx->value;
			
				CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(orig);
				release_array(x);
				release_func(fn);
				stkhd -= 2;
			}
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s->value)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(loc->cdf_s->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *aa = stkhd[-1];
				struct cell_array *axis = stkhd[-2];
				struct cell_func *dst;
			
				CHK(derive_func_opts(&dst, aa, 1), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				dst->opts[0] = axis;
			
				release_func(aa);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	return err;
}

int
cdf_ptr13640(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array_box *cdf_noax;
		struct cell_array *cdf_israv;
		struct cell_array_box *cdf_lr;
		struct cell_array_box *cdf_rr;
		struct cell_array_box *cdf_axis;
		struct cell_array *cdf_rk;
		struct cell_array *cdf_ar;
		struct cell_array *cdf_noscl;
		struct cell_array_box *cdf_fx;
		struct cell_array *cdf_x;
		struct cell_array *cdf_y;
		struct cell_array *cdf_m;
		struct cell_array_box *cdf_s;
		struct cell_array *cdf_ca;
		struct cell_array *cdf_cb;
		struct cell_array *cdf_cc;
		struct cell_array *cdf_lx;
		struct cell_array *cdf_rx;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_is_numeric;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	struct opt_vars {
		struct cell_array_box *cdf_axis;
	} *opts;

	opts = (struct opt_vars *)cdf_self->opts;

	CHK(mk_array_box(&loc->cdf_noax, NULL), cleanup, L"Init mutable variable: loc->cdf_noax");
	loc->cdf_israv = NULL;
	CHK(mk_array_box(&loc->cdf_lr, NULL), cleanup, L"Init mutable variable: loc->cdf_lr");
	CHK(mk_array_box(&loc->cdf_rr, NULL), cleanup, L"Init mutable variable: loc->cdf_rr");
	CHK(mk_array_box(&loc->cdf_axis, NULL), cleanup, L"Init mutable variable: loc->cdf_axis");
	loc->cdf_rk = NULL;
	loc->cdf_ar = NULL;
	loc->cdf_noscl = NULL;
	CHK(mk_array_box(&loc->cdf_fx, NULL), cleanup, L"Init mutable variable: loc->cdf_fx");
	loc->cdf_x = NULL;
	loc->cdf_y = NULL;
	loc->cdf_m = NULL;
	CHK(mk_array_box(&loc->cdf_s, NULL), cleanup, L"Init mutable variable: loc->cdf_s");
	loc->cdf_ca = NULL;
	loc->cdf_cb = NULL;
	loc->cdf_cc = NULL;
	loc->cdf_lx = NULL;
	loc->cdf_rx = NULL;
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
		CHK(fill_array(arr, dat), cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_noax->value);
	loc->cdf_noax->value = retain_cell(stkhd[-1]);
	
	release_cell(loc->cdf_israv);
	loc->cdf_israv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lr->value);
	loc->cdf_lr->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rr->value);
	loc->cdf_rr->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (opts && opts->cdf_axis) {
		*stkhd++ = retain_cell(opts->cdf_axis);
	} else {
		{
			struct cell_array *arr;
		
			enum array_type typ = ARR_SINT;
			unsigned int rnk = 0;
			int16_t dat[] = {1};
		
			CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
		
			CHK(fill_array(arr, dat), cleanup, L"[104] 	isravnoax0  israv1  lr  rr  axisnoax1");
		
			*stkhd++ = arr;
		}
		
		release_cell(loc->cdf_noax->value);
		loc->cdf_noax->value = retain_cell(stkhd[-1]);
		
	}
	
	release_cell(loc->cdf_axis->value);
	loc->cdf_axis->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_israv)
		CHK(6, cleanup, L"[105] 	israv:{");
	
	*stkhd++ = retain_cell(loc->cdf_israv);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[105] 	israv:{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[110] 	}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13641, cdf_ptr13642, 2), cleanup, 
				    L"[105] 	israv:{");
			
				k->fv[0] = retain_cell(loc->cdf_noax);
				k->fv[1] = retain_cell(loc->cdf_axis);
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[105] 	israv:{");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_rr->value)
		CHK(6, cleanup, L"[111] 	rklrrr  axis1+rk");
	
	*stkhd++ = retain_cell(loc->cdf_rr->value);
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[111] 	rklrrr  axis1+rk");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	if (!loc->cdf_lr->value)
		CHK(6, cleanup, L"[111] 	rklrrr  axis1+rk");
	
	*stkhd++ = retain_cell(loc->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[111] 	rklrrr  axis1+rk");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rk);
	loc->cdf_rk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (opts && opts->cdf_axis) {
		*stkhd++ = retain_cell(opts->cdf_axis);
	} else {
		if (!loc->cdf_rk)
			CHK(6, cleanup, L"[111] 	rklrrr  axis1+rk");
		
		*stkhd++ = retain_cell(loc->cdf_rk);
		
		if (!cdf_prim.cdf_add)
			CHK(6, cleanup, L"[111] 	rklrrr  axis1+rk");
		
		*stkhd++ = retain_cell(cdf_prim.cdf_add);
		
		{
			struct cell_array *arr;
		
			enum array_type typ = ARR_SINT;
			unsigned int rnk = 0;
			int16_t dat[] = {-1};
		
			CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[111] 	rklrrr  axis1+rk");
		
			CHK(fill_array(arr, dat), cleanup, L"[111] 	rklrrr  axis1+rk");
		
			*stkhd++ = arr;
		}
		
		{
			struct cell_array *x = stkhd[-1];
			struct cell_func *fn = stkhd[-2];
			struct cell_array *y = stkhd[-3];
			struct cell_array *dst;
		
			CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
			    L"[111] 	rklrrr  axis1+rk");
		
			release_array(x);
			release_func(fn);
			release_array(y);
		
			stkhd -= 3;
			*stkhd++ = dst;
		}
		
	}
	
	release_cell(loc->cdf_axis->value);
	loc->cdf_axis->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_rr->value)
		CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
	*stkhd++ = retain_cell(loc->cdf_rr->value);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
		CHK(fill_array(arr, dat), cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[112] 	(0lr)(0rr):(,),,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!loc->cdf_lr->value)
		CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
	*stkhd++ = retain_cell(loc->cdf_lr->value);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
		CHK(fill_array(arr, dat), cleanup, L"[112] 	(0lr)(0rr):(,),,");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[112] 	(0lr)(0rr):(,),,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[112] 	(0lr)(0rr):(,),,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[112] 	(0lr)(0rr):(,),,");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[112] 	(0lr)(0rr):(,),,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[112] 	(0lr)(0rr):(,),,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[112] 	(0lr)(0rr):(,),,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[112] 	(0lr)(0rr):(,),,");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_axis->value)
		CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
	*stkhd++ = retain_cell(loc->cdf_axis->value);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_ar);
	loc->cdf_ar = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
				CHK(fill_array(arr, dat), cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_axis->value)
		CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
	*stkhd++ = retain_cell(loc->cdf_axis->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		CHK(fill_array(arr, dat), cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
				CHK(fill_array(arr, dat), cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[113] 	araxis:SIGNAL 4  1,axis:SIGNAL 5 ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_axis->value)
		CHK(6, cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
	*stkhd++ = retain_cell(loc->cdf_axis->value);
	
	if (!lex->cdf_is_numeric->value)
		CHK(6, cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lte)
		CHK(6, cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lte);
	
	if (!loc->cdf_axis->value)
		CHK(6, cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
	*stkhd++ = retain_cell(loc->cdf_axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[114] 	~is_numeric axis:SIGNAL 11  axis1:SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_rk)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_rk);
	
	if (!cdf_prim.cdf_gte)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_gte);
	
	if (!loc->cdf_axis->value)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!loc->cdf_rr->value)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!loc->cdf_lr->value)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_noscl);
	loc->cdf_noscl = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!loc->cdf_rr->value)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_rr->value);
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_lr->value)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[115] 	axisrk:SIGNAL 4  (1<|lr-rr)noscl(lr0)rr0:SIGNAL 4");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_axis->value)
		CHK(6, cleanup, L"[116] 	axisfxaxis:{");
	
	*stkhd++ = retain_cell(loc->cdf_axis->value);
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[116] 	axisfxaxis:{");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[116] 	axisfxaxis:{");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_fx->value);
	loc->cdf_fx->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[116] 	axisfxaxis:{");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!loc->cdf_axis->value)
		CHK(6, cleanup, L"[116] 	axisfxaxis:{");
	
	*stkhd++ = retain_cell(loc->cdf_axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[116] 	axisfxaxis:{");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[116] 	axisfxaxis:{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[119] 	}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13643, cdf_ptr13644, 4), cleanup, 
				    L"[116] 	axisfxaxis:{");
			
				k->fv[0] = retain_cell(loc->cdf_fx);
				k->fv[1] = retain_cell(loc->cdf_rr);
				k->fv[2] = retain_cell(loc->cdf_lr);
				k->fv[3] = retain_cell(loc->cdf_axis);
			
				*stkhd++ = k;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[116] 	axisfxaxis:{");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[116] 	axisfxaxis:{");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		CHK(fill_array(arr, dat), cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lte)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lte);
	
	if (!loc->cdf_rr->value)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		CHK(fill_array(arr, dat), cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lte)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lte);
	
	if (!loc->cdf_lr->value)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13645, cdf_ptr13646, 0), cleanup, 
				    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
			
				*stkhd++ = k;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13647, cdf_ptr13648, 3), cleanup, 
		    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		k->fv[0] = retain_cell(loc->cdf_fx);
		k->fv[1] = retain_cell(loc->cdf_rr);
		k->fv[2] = retain_cell(loc->cdf_lr);
	
		*stkhd++ = k;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_x);
	loc->cdf_x = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13649, cdf_ptr13650, 3), cleanup, 
		    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		k->fv[0] = retain_cell(loc->cdf_fx);
		k->fv[1] = retain_cell(loc->cdf_rr);
		k->fv[2] = retain_cell(loc->cdf_lr);
	
		*stkhd++ = k;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_y);
	loc->cdf_y = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_rk)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_rk);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_m);
	loc->cdf_m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!cdf_prim.cdf_dot)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dot);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_x)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_x);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[123] 	(mx).mymfxrk:SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[123] 	(mx).mymfxrk:SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[123] 	(mx).mymfxrk:SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_x)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(loc->cdf_x);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s->value);
	loc->cdf_s->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!loc->cdf_x)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(loc->cdf_x);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->cdf_s;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[124] 	s[fx](x)[fx]+(y)[fx]sx");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_s->value);
	
	if (!cdf_prim.cdf_tke)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_tke);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_ca);
	loc->cdf_ca = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_s->value);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_cb);
	loc->cdf_cb = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_s->value);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		CHK(fill_array(arr, dat), cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_cc);
	loc->cdf_cc = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_x)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_x);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lx);
	loc->cdf_lx = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!loc->cdf_fx->value)
		CHK(6, cleanup, L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
	*stkhd++ = retain_cell(loc->cdf_fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[125] 	cafxs  cbfxs  cc(fx+1)s  lxfxx  rxfxy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rx);
	loc->cdf_rx = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_cc)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_cc);
	
	if (!loc->cdf_cb)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_cb);
	
	if (!loc->cdf_ca)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_ca);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_x)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_x);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_cc)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_cc);
	
	if (!loc->cdf_lx)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_lx);
	
	if (!loc->cdf_ca)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_ca);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	if (!loc->cdf_lx)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_lx);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_cc)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_cc);
	
	if (!loc->cdf_rx)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_rx);
	
	if (!loc->cdf_ca)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_ca);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	if (!loc->cdf_rx)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_rx);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_lx)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(loc->cdf_lx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[126] 	zca cb cc0  z[;lx;]ca lx ccx  z[;lx+rx;]ca rx ccy");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[127] 	sz");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[127] 	sz");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_s->value)
		CHK(6, cleanup, L"[127] 	sz");
	
	*stkhd++ = retain_cell(loc->cdf_s->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[127] 	sz");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[103] cat{");
	return err;
}

int
cdf_ptr13641(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_s;
		struct cell_array *cdf_pr;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_noax;
		struct cell_array_box *cdf_axis;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_s = NULL;
	loc->cdf_pr = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_noax->value)
		CHK(6, cleanup, L"[106] 		noax:'ravel_ibeam' ");
	
	*stkhd++ = retain_cell(lex->cdf_noax->value);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[105] 	israv:{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[106] 		noax:'ravel_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_ravel_ibeam)
				CHK(6, cleanup, L"[106] 		noax:'ravel_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_ravel_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[106] 		noax:'ravel_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[107] 		1,axis:SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[107] 		1,axis:SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[107] 		1,axis:SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[107] 		1,axis:SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[107] 		1,axis:SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[106] 		noax:'ravel_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[107] 		1,axis:SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[107] 		1,axis:SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[107] 		1,axis:SIGNAL 16");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[108] 		axis=axis:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[108] 		axis=axis:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[107] 		1,axis:SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[108] 		axis=axis:");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_pr);
	loc->cdf_pr = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[109] 		((prs),1,(praxis)s)");
	
		CHK(fill_array(arr, dat), cleanup, L"[109] 		((prs),1,(praxis)s)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_tke)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_tke);
	
	if (!loc->cdf_pr)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(loc->cdf_pr);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[105] 	israv:{");
	return err;
}

int
cdf_ptr13642(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_s;
		struct cell_array *cdf_pr;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_noax;
		struct cell_array_box *cdf_axis;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_s = NULL;
	loc->cdf_pr = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_noax->value)
		CHK(6, cleanup, L"[106] 		noax:'ravel_ibeam' ");
	
	*stkhd++ = retain_cell(lex->cdf_noax->value);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[106] 		noax:'ravel_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_ravel_ibeam)
				CHK(6, cleanup, L"[106] 		noax:'ravel_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_ravel_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[106] 		noax:'ravel_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[107] 		1,axis:SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[107] 		1,axis:SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[107] 		1,axis:SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[107] 		1,axis:SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[107] 		1,axis:SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[106] 		noax:'ravel_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[107] 		1,axis:SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[107] 		1,axis:SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[107] 		1,axis:SIGNAL 16");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[107] 		1,axis:SIGNAL 16");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[108] 		axis=axis:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[108] 		axis=axis:");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[108] 		axis=axis:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[107] 		1,axis:SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[108] 		axis=axis:");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_pr);
	loc->cdf_pr = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[109] 		((prs),1,(praxis)s)");
	
		CHK(fill_array(arr, dat), cleanup, L"[109] 		((prs),1,(praxis)s)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_tke)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_tke);
	
	if (!loc->cdf_pr)
		CHK(6, cleanup, L"[109] 		((prs),1,(praxis)s)");
	
	*stkhd++ = retain_cell(loc->cdf_pr);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[109] 		((prs),1,(praxis)s)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[105] 	israv:{");
	return err;
}

int
cdf_ptr13643(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_fx;
		struct cell_array_box *cdf_rr;
		struct cell_array_box *cdf_lr;
		struct cell_array_box *cdf_axis;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[116] 	axisfxaxis:{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_pow)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_pow);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_fx->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_fx->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_pow)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_pow);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[116] 	axisfxaxis:{");
	return err;
}

int
cdf_ptr13644(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_fx;
		struct cell_array_box *cdf_rr;
		struct cell_array_box *cdf_lr;
		struct cell_array_box *cdf_axis;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[117] 		(lr0)(rr0)lrrr:SIGNAL 4");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_pow)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_pow);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_fx->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_fx->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_pow)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_pow);
	
	if (!lex->cdf_axis->value)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(lex->cdf_axis->value);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[118] 		(,[axis](lr0)),[fx],[axis](rr0)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[116] 	axisfxaxis:{");
	return err;
}

int
cdf_ptr13645(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_rc;
		struct cell_array *cdf_lc;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_rc = NULL;
	loc->cdf_lc = NULL;
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rc);
	loc->cdf_rc = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lc);
	loc->cdf_lc = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!loc->cdf_rc)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_rc);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_lc)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_lc);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	return err;
}

int
cdf_ptr13646(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_rc;
		struct cell_array *cdf_lc;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_rc = NULL;
	loc->cdf_lc = NULL;
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rc);
	loc->cdf_rc = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lc);
	loc->cdf_lc = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!loc->cdf_rc)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_rc);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_lc)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_lc);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[120] 	(lr1)rr1:{z((lc)+rc)  z[lc+rc]  z}");
	return err;
}

int
cdf_ptr13647(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array_box *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_fx;
		struct cell_array_box *cdf_rr;
		struct cell_array_box *cdf_lr;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	CHK(mk_array_box(&loc->cdf_s, NULL), cleanup, L"Init mutable variable: loc->cdf_s");
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->cdf_s->value);
			loc->cdf_s->value = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_set)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_set);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array_box *bx = loc->cdf_s;
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *orig = bx->value;
			
				CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(orig);
				release_array(x);
				release_func(fn);
				stkhd -= 2;
			}
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s->value)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(loc->cdf_s->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *aa = stkhd[-1];
				struct cell_array *axis = stkhd[-2];
				struct cell_func *dst;
			
				CHK(derive_func_opts(&dst, aa, 1), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				dst->opts[0] = axis;
			
				release_func(aa);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	return err;
}

int
cdf_ptr13648(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array_box *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_fx;
		struct cell_array_box *cdf_rr;
		struct cell_array_box *cdf_lr;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	CHK(mk_array_box(&loc->cdf_s, NULL), cleanup, L"Init mutable variable: loc->cdf_s");
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->cdf_s->value);
			loc->cdf_s->value = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_set)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_set);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array_box *bx = loc->cdf_s;
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *orig = bx->value;
			
				CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(orig);
				release_array(x);
				release_func(fn);
				stkhd -= 2;
			}
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s->value)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(loc->cdf_s->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *aa = stkhd[-1];
				struct cell_array *axis = stkhd[-2];
				struct cell_func *dst;
			
				CHK(derive_func_opts(&dst, aa, 1), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				dst->opts[0] = axis;
			
				release_func(aa);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[121] 	x{lr0:ss[fx]1s  lr<rr:,[fx-.5]  }");
	return err;
}

int
cdf_ptr13649(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array_box *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_fx;
		struct cell_array_box *cdf_rr;
		struct cell_array_box *cdf_lr;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	CHK(mk_array_box(&loc->cdf_s, NULL), cleanup, L"Init mutable variable: loc->cdf_s");
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->cdf_s->value);
			loc->cdf_s->value = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_set)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_set);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array_box *bx = loc->cdf_s;
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *orig = bx->value;
			
				CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(orig);
				release_array(x);
				release_func(fn);
				stkhd -= 2;
			}
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s->value)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(loc->cdf_s->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *aa = stkhd[-1];
				struct cell_array *axis = stkhd[-2];
				struct cell_func *dst;
			
				CHK(derive_func_opts(&dst, aa, 1), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				dst->opts[0] = axis;
			
				release_func(aa);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	return err;
}

int
cdf_ptr13650(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array_box *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *cdf_fx;
		struct cell_array_box *cdf_rr;
		struct cell_array_box *cdf_lr;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	CHK(mk_array_box(&loc->cdf_s, NULL), cleanup, L"Init mutable variable: loc->cdf_s");
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->cdf_s->value);
			loc->cdf_s->value = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_set)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_set);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array_box *bx = loc->cdf_s;
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *orig = bx->value;
			
				CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(orig);
				release_array(x);
				release_func(fn);
				stkhd -= 2;
			}
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s->value)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(loc->cdf_s->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->cdf_lr->value)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_lr->value);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!lex->cdf_rr->value)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(lex->cdf_rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				CHK(fill_array(arr, dat), cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			if (!lex->cdf_fx->value)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(lex->cdf_fx->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *aa = stkhd[-1];
				struct cell_array *axis = stkhd[-2];
				struct cell_func *dst;
			
				CHK(derive_func_opts(&dst, aa, 1), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				dst->opts[0] = axis;
			
				release_func(aa);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[122] 	y{rr0:ss[fx]1s  rr<lr:,[fx-.5]  }");
	return err;
}

int
cdf_ptr13651(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[131] ctf{,[0]}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[131] ctf{,[0]}");
	
		CHK(fill_array(arr, dat), cleanup, L"[131] ctf{,[0]}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[131] ctf{,[0]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[131] ctf{,[0]}");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[131] ctf{,[0]}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[131] ctf{,[0]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[131] ctf{,[0]}");
	return err;
}

int
cdf_ptr13652(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[131] ctf{,[0]}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[131] ctf{,[0]}");
	
		CHK(fill_array(arr, dat), cleanup, L"[131] ctf{,[0]}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[131] ctf{,[0]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[131] ctf{,[0]}");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[131] ctf{,[0]}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[131] ctf{,[0]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[131] ctf{,[0]}");
	return err;
}

int
cdf_ptr13653(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_d;
		struct cell_array *cdf_pd;
		struct cell_array *cdf_mx;
		struct cell_array *cdf_nd;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_is_simple;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_d = NULL;
	loc->cdf_pd = NULL;
	loc->cdf_mx = NULL;
	loc->cdf_nd = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_simple->value)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(lex->cdf_is_simple->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[135]    is_simple :{0:0  1}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[135]    is_simple :{0:0  1}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13654, cdf_ptr13655, 0), cleanup, 
				    L"[135]    is_simple :{0:0  1}");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[135]    is_simple :{0:0  1}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[136]    0,:(d)+d");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[136]    0,:(d)+d");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[136]    0,:(d)+d");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[136]    0,:(d)+d");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[136]    0,:(d)+d");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[136]    0,:(d)+d");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[136]    0,:(d)+d");
	
		CHK(fill_array(arr, dat), cleanup, L"[136]    0,:(d)+d");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[136]    0,:(d)+d");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[136]    0,:(d)+d");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[136]    0,:(d)+d");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_dis)
				CHK(6, cleanup, L"[136]    0,:(d)+d");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_dis);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[136]    0,:(d)+d");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_self)
				CHK(6, cleanup, L"[136]    0,:(d)+d");
			
			*stkhd++ = retain_cell(cdf_self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[136]    0,:(d)+d");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->cdf_d);
			loc->cdf_d = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[136]    0,:(d)+d");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			if (!loc->cdf_d)
				CHK(6, cleanup, L"[136]    0,:(d)+d");
			
			*stkhd++ = retain_cell(loc->cdf_d);
			
			if (!cdf_prim.cdf_mul)
				CHK(6, cleanup, L"[136]    0,:(d)+d");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_mul);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[136]    0,:(d)+d");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[136]    0,:(d)+d");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[137]    nd1+mxpd|d,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_self)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[137]    nd1+mxpd|d,");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[137]    nd1+mxpd|d,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_d);
	loc->cdf_d = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[137]    nd1+mxpd|d,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_pd);
	loc->cdf_pd = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[137]    nd1+mxpd|d,");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[137]    nd1+mxpd|d,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_mx);
	loc->cdf_mx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137]    nd1+mxpd|d,");
	
		CHK(fill_array(arr, dat), cleanup, L"[137]    nd1+mxpd|d,");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[137]    nd1+mxpd|d,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_nd);
	loc->cdf_nd = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_mx)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(loc->cdf_mx);
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!loc->cdf_pd)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(loc->cdf_pd);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[138]    (d<0)pdmx:-nd");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[138]    (d<0)pdmx:-nd");
	
		CHK(fill_array(arr, dat), cleanup, L"[138]    (d<0)pdmx:-nd");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!loc->cdf_d)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(loc->cdf_d);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[138]    (d<0)pdmx:-nd");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[138]    (d<0)pdmx:-nd");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[138]    (d<0)pdmx:-nd");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[138]    (d<0)pdmx:-nd");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[138]    (d<0)pdmx:-nd");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!loc->cdf_nd)
				CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
			
			*stkhd++ = retain_cell(loc->cdf_nd);
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[138]    (d<0)pdmx:-nd");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_nd)
		CHK(6, cleanup, L"[139]    nd");
	
	*stkhd++ = retain_cell(loc->cdf_nd);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[134] depth{");
	return err;
}

int
cdf_ptr13654(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[135]    is_simple :{0:0  1}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[135]    is_simple :{0:0  1}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[135]    is_simple :{0:0  1}");
	
		CHK(fill_array(arr, dat), cleanup, L"[135]    is_simple :{0:0  1}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[135]    is_simple :{0:0  1}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[135]    is_simple :{0:0  1}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[135]    is_simple :{0:0  1}");
			
				CHK(fill_array(arr, dat), cleanup, L"[135]    is_simple :{0:0  1}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[135]    is_simple :{0:0  1}");
	
		CHK(fill_array(arr, dat), cleanup, L"[135]    is_simple :{0:0  1}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[135]    is_simple :{0:0  1}");
	return err;
}

int
cdf_ptr13655(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[135]    is_simple :{0:0  1}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[135]    is_simple :{0:0  1}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[135]    is_simple :{0:0  1}");
	
		CHK(fill_array(arr, dat), cleanup, L"[135]    is_simple :{0:0  1}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[135]    is_simple :{0:0  1}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[135]    is_simple :{0:0  1}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[135]    is_simple :{0:0  1}");
			
				CHK(fill_array(arr, dat), cleanup, L"[135]    is_simple :{0:0  1}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[135]    is_simple :{0:0  1}");
	
		CHK(fill_array(arr, dat), cleanup, L"[135]    is_simple :{0:0  1}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[135]    is_simple :{0:0  1}");
	return err;
}

int
cdf_ptr13656(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_d;
		struct cell_array *cdf_pd;
		struct cell_array *cdf_mx;
		struct cell_array *cdf_nd;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_is_simple;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_d = NULL;
	loc->cdf_pd = NULL;
	loc->cdf_mx = NULL;
	loc->cdf_nd = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_simple->value)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(lex->cdf_is_simple->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[135]    is_simple :{0:0  1}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[135]    is_simple :{0:0  1}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13657, cdf_ptr13658, 0), cleanup, 
				    L"[135]    is_simple :{0:0  1}");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[135]    is_simple :{0:0  1}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[136]    0,:(d)+d");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[136]    0,:(d)+d");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[136]    0,:(d)+d");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[136]    0,:(d)+d");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[136]    0,:(d)+d");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[136]    0,:(d)+d");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[136]    0,:(d)+d");
	
		CHK(fill_array(arr, dat), cleanup, L"[136]    0,:(d)+d");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[136]    0,:(d)+d");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[136]    0,:(d)+d");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[136]    0,:(d)+d");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_dis)
				CHK(6, cleanup, L"[136]    0,:(d)+d");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_dis);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[136]    0,:(d)+d");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_self)
				CHK(6, cleanup, L"[136]    0,:(d)+d");
			
			*stkhd++ = retain_cell(cdf_self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[136]    0,:(d)+d");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->cdf_d);
			loc->cdf_d = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[136]    0,:(d)+d");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			if (!loc->cdf_d)
				CHK(6, cleanup, L"[136]    0,:(d)+d");
			
			*stkhd++ = retain_cell(loc->cdf_d);
			
			if (!cdf_prim.cdf_mul)
				CHK(6, cleanup, L"[136]    0,:(d)+d");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_mul);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[136]    0,:(d)+d");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[136]    0,:(d)+d");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[137]    nd1+mxpd|d,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_self)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[137]    nd1+mxpd|d,");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[137]    nd1+mxpd|d,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_d);
	loc->cdf_d = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[137]    nd1+mxpd|d,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_pd);
	loc->cdf_pd = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[137]    nd1+mxpd|d,");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[137]    nd1+mxpd|d,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_mx);
	loc->cdf_mx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[137]    nd1+mxpd|d,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137]    nd1+mxpd|d,");
	
		CHK(fill_array(arr, dat), cleanup, L"[137]    nd1+mxpd|d,");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[137]    nd1+mxpd|d,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_nd);
	loc->cdf_nd = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_mx)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(loc->cdf_mx);
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!loc->cdf_pd)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(loc->cdf_pd);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[138]    (d<0)pdmx:-nd");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[138]    (d<0)pdmx:-nd");
	
		CHK(fill_array(arr, dat), cleanup, L"[138]    (d<0)pdmx:-nd");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!loc->cdf_d)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(loc->cdf_d);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[138]    (d<0)pdmx:-nd");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[138]    (d<0)pdmx:-nd");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[138]    (d<0)pdmx:-nd");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[138]    (d<0)pdmx:-nd");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[138]    (d<0)pdmx:-nd");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!loc->cdf_nd)
				CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
			
			*stkhd++ = retain_cell(loc->cdf_nd);
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[138]    (d<0)pdmx:-nd");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[138]    (d<0)pdmx:-nd");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_nd)
		CHK(6, cleanup, L"[139]    nd");
	
	*stkhd++ = retain_cell(loc->cdf_nd);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[134] depth{");
	return err;
}

int
cdf_ptr13657(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[135]    is_simple :{0:0  1}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[135]    is_simple :{0:0  1}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[135]    is_simple :{0:0  1}");
	
		CHK(fill_array(arr, dat), cleanup, L"[135]    is_simple :{0:0  1}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[135]    is_simple :{0:0  1}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[135]    is_simple :{0:0  1}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[135]    is_simple :{0:0  1}");
			
				CHK(fill_array(arr, dat), cleanup, L"[135]    is_simple :{0:0  1}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[135]    is_simple :{0:0  1}");
	
		CHK(fill_array(arr, dat), cleanup, L"[135]    is_simple :{0:0  1}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[135]    is_simple :{0:0  1}");
	return err;
}

int
cdf_ptr13658(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[135]    is_simple :{0:0  1}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[135]    is_simple :{0:0  1}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[135]    is_simple :{0:0  1}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[135]    is_simple :{0:0  1}");
	
		CHK(fill_array(arr, dat), cleanup, L"[135]    is_simple :{0:0  1}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[135]    is_simple :{0:0  1}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[135]    is_simple :{0:0  1}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[135]    is_simple :{0:0  1}");
			
				CHK(fill_array(arr, dat), cleanup, L"[135]    is_simple :{0:0  1}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[135]    is_simple :{0:0  1}");
	
		CHK(fill_array(arr, dat), cleanup, L"[135]    is_simple :{0:0  1}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[135]    is_simple :{0:0  1}");
	return err;
}

int
cdf_ptr13659(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
			
				CHK(fill_array(arr, dat), cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	return err;
}

int
cdf_ptr13660(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
			
				CHK(fill_array(arr, dat), cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[145] nqv{:1  } ambiv ('nqv_ibeam')");
	return err;
}

int
cdf_ptr13661(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_chk_valid_shape;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[149] 	chk_valid_shape : ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_chk_valid_shape->value)
		CHK(6, cleanup, L"[149] 	chk_valid_shape : ");
	
	*stkhd++ = retain_cell(lex->cdf_chk_valid_shape->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[149] 	chk_valid_shape : ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[149] 	chk_valid_shape : ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[150] 	0,:");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[150] 	0,:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[150] 	0,:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[150] 	0,:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[150] 	0,:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[150] 	0,:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	0,:");
	
		CHK(fill_array(arr, dat), cleanup, L"[150] 	0,:");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[150] 	0,:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[150] 	0,:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	0,:");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[150] 	0,:");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_par)
				CHK(6, cleanup, L"[150] 	0,:");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_par);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[150] 	0,:");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[151] 	(,0),:");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[151] 	(,0),:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[151] 	(,0),:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[151] 	(,0),:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[151] 	(,0),:");
	
		CHK(fill_array(arr, dat), cleanup, L"[151] 	(,0),:");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[151] 	(,0),:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[151] 	(,0),:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[151] 	(,0),:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[151] 	(,0),:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[151] 	(,0),:");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[151] 	(,0),:");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[152] 	1,:'index_gen_vec' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[152] 	1,:'index_gen_vec' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[152] 	1,:'index_gen_vec' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[152] 	1,:'index_gen_vec' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[152] 	1,:'index_gen_vec' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[152] 	1,:'index_gen_vec' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[152] 	1,:'index_gen_vec' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[152] 	1,:'index_gen_vec' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[152] 	1,:'index_gen_vec' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[152] 	1,:'index_gen_vec' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[152] 	1,:'index_gen_vec' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_index_gen_vec)
				CHK(6, cleanup, L"[152] 	1,:'index_gen_vec' ");
			
			*stkhd++ = retain_cell(cdf_index_gen_vec);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[152] 	1,:'index_gen_vec' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[153] 	SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[153] 	SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[153] 	SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[153] 	SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[148] index_gen{");
	return err;
}

int
cdf_ptr13662(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_chk_valid_shape;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[149] 	chk_valid_shape : ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_chk_valid_shape->value)
		CHK(6, cleanup, L"[149] 	chk_valid_shape : ");
	
	*stkhd++ = retain_cell(lex->cdf_chk_valid_shape->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[149] 	chk_valid_shape : ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[149] 	chk_valid_shape : ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[150] 	0,:");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[150] 	0,:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[150] 	0,:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[150] 	0,:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[150] 	0,:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[150] 	0,:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	0,:");
	
		CHK(fill_array(arr, dat), cleanup, L"[150] 	0,:");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[150] 	0,:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[150] 	0,:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	0,:");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[150] 	0,:");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_par)
				CHK(6, cleanup, L"[150] 	0,:");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_par);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[150] 	0,:");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[151] 	(,0),:");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[151] 	(,0),:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[151] 	(,0),:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[151] 	(,0),:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[151] 	(,0),:");
	
		CHK(fill_array(arr, dat), cleanup, L"[151] 	(,0),:");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[151] 	(,0),:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[151] 	(,0),:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[151] 	(,0),:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[151] 	(,0),:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[151] 	(,0),:");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[151] 	(,0),:");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[152] 	1,:'index_gen_vec' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[152] 	1,:'index_gen_vec' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[152] 	1,:'index_gen_vec' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[152] 	1,:'index_gen_vec' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[152] 	1,:'index_gen_vec' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[152] 	1,:'index_gen_vec' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[152] 	1,:'index_gen_vec' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[152] 	1,:'index_gen_vec' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[152] 	1,:'index_gen_vec' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[152] 	1,:'index_gen_vec' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[152] 	1,:'index_gen_vec' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_index_gen_vec)
				CHK(6, cleanup, L"[152] 	1,:'index_gen_vec' ");
			
			*stkhd++ = retain_cell(cdf_index_gen_vec);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[152] 	1,:'index_gen_vec' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[153] 	SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[153] 	SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[153] 	SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[153] 	SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[148] index_gen{");
	return err;
}

int
cdf_ptr13663(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[155] index_of{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[155] index_of{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[155] index_of{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[155] index_of{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[155] index_of{SIGNAL 16}");
	return err;
}

int
cdf_ptr13664(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[155] index_of{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[155] index_of{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[155] index_of{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[155] index_of{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[155] index_of{SIGNAL 16}");
	return err;
}

int
cdf_ptr13665(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[159] dis('disclose_ibeam') ambiv {SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[159] dis('disclose_ibeam') ambiv {SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[159] dis('disclose_ibeam') ambiv {SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[159] dis('disclose_ibeam') ambiv {SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[159] dis('disclose_ibeam') ambiv {SIGNAL 16}");
	return err;
}

int
cdf_ptr13666(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[159] dis('disclose_ibeam') ambiv {SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[159] dis('disclose_ibeam') ambiv {SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[159] dis('disclose_ibeam') ambiv {SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[159] dis('disclose_ibeam') ambiv {SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[159] dis('disclose_ibeam') ambiv {SIGNAL 16}");
	return err;
}

int
cdf_ptr13667(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[163] 	0:");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[163] 	0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[163] 	0:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[163] 	0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[163] 	0:");
	
		CHK(fill_array(arr, dat), cleanup, L"[163] 	0:");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[163] 	0:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[163] 	0:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[163] 	0:");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[164] 	'enclose_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_enclose_ibeam)
		CHK(6, cleanup, L"[164] 	'enclose_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_enclose_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[164] 	'enclose_ibeam' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[162] enclose{");
	return err;
}

int
cdf_ptr13668(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[163] 	0:");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[163] 	0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[163] 	0:");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[163] 	0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[163] 	0:");
	
		CHK(fill_array(arr, dat), cleanup, L"[163] 	0:");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[163] 	0:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[163] 	0:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[163] 	0:");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[164] 	'enclose_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_enclose_ibeam)
		CHK(6, cleanup, L"[164] 	'enclose_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_enclose_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[164] 	'enclose_ibeam' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[162] enclose{");
	return err;
}

int
cdf_ptr13669(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[166] parenclose ambiv {SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[166] parenclose ambiv {SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[166] parenclose ambiv {SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[166] parenclose ambiv {SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[166] parenclose ambiv {SIGNAL 16}");
	return err;
}

int
cdf_ptr13670(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[166] parenclose ambiv {SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[166] parenclose ambiv {SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[166] parenclose ambiv {SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[166] parenclose ambiv {SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[166] parenclose ambiv {SIGNAL 16}");
	return err;
}

int
cdf_ptr13671(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
		CHK(fill_array(arr, dat), cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_conjugate_vec_ibeam)
				CHK(6, cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
			
			*stkhd++ = retain_cell(cdf_conjugate_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	return err;
}

int
cdf_ptr13672(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
		CHK(fill_array(arr, dat), cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_conjugate_vec_ibeam)
				CHK(6, cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
			
			*stkhd++ = retain_cell(cdf_conjugate_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[169] conjugate{1289DR squeeze :'conjugate_vec_ibeam'   }");
	return err;
}

int
cdf_ptr13673(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	return err;
}

int
cdf_ptr13674(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[173] sub{0-} ambiv ('sub_vec_ibeam' numeric scalar)");
	return err;
}

int
cdf_ptr13675(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[177] 	1289=DR :|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[177] 	1289=DR :|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[177] 	1289=DR :|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[177] 	1289=DR :|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[177] 	1289=DR :|");
	
		CHK(fill_array(arr, dat), cleanup, L"[177] 	1289=DR :|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[177] 	1289=DR :|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[177] 	1289=DR :|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[177] 	1289=DR :|");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_res)
				CHK(6, cleanup, L"[177] 	1289=DR :|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[177] 	1289=DR :|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_div)
				CHK(6, cleanup, L"[177] 	1289=DR :|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_div);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[177] 	1289=DR :|");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[177] 	1289=DR :|");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[178] 	(-<0)+0<");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[178] 	(-<0)+0<");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[178] 	(-<0)+0<");
	
		CHK(fill_array(arr, dat), cleanup, L"[178] 	(-<0)+0<");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] 	(-<0)+0<");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[178] 	(-<0)+0<");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[178] 	(-<0)+0<");
	
		CHK(fill_array(arr, dat), cleanup, L"[178] 	(-<0)+0<");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[178] 	(-<0)+0<");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[178] 	(-<0)+0<");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] 	(-<0)+0<");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[178] 	(-<0)+0<");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[178] 	(-<0)+0<");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] 	(-<0)+0<");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[176] sign{");
	return err;
}

int
cdf_ptr13676(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[177] 	1289=DR :|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[177] 	1289=DR :|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[177] 	1289=DR :|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[177] 	1289=DR :|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[177] 	1289=DR :|");
	
		CHK(fill_array(arr, dat), cleanup, L"[177] 	1289=DR :|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[177] 	1289=DR :|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[177] 	1289=DR :|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[177] 	1289=DR :|");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_res)
				CHK(6, cleanup, L"[177] 	1289=DR :|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[177] 	1289=DR :|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_div)
				CHK(6, cleanup, L"[177] 	1289=DR :|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_div);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[177] 	1289=DR :|");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[177] 	1289=DR :|");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[178] 	(-<0)+0<");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[178] 	(-<0)+0<");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[178] 	(-<0)+0<");
	
		CHK(fill_array(arr, dat), cleanup, L"[178] 	(-<0)+0<");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] 	(-<0)+0<");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[178] 	(-<0)+0<");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[178] 	(-<0)+0<");
	
		CHK(fill_array(arr, dat), cleanup, L"[178] 	(-<0)+0<");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[178] 	(-<0)+0<");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[178] 	(-<0)+0<");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] 	(-<0)+0<");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[178] 	(-<0)+0<");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[178] 	(-<0)+0<");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] 	(-<0)+0<");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[176] sign{");
	return err;
}

int
cdf_ptr13677(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_div)
		CHK(6, cleanup, L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_div);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	return err;
}

int
cdf_ptr13678(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_div)
		CHK(6, cleanup, L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_div);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[183] div{1} ambiv ('div_vec_ibeam' numeric scalar)");
	return err;
}

int
cdf_ptr13679(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_is_numeric;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[187] 	0is_numeric :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_numeric->value)
		CHK(6, cleanup, L"[187] 	0is_numeric :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[187] 	0is_numeric :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[187] 	0is_numeric :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[187] 	0is_numeric :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[187] 	0is_numeric :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[187] 	0is_numeric :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[187] 	0is_numeric :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[187] 	0is_numeric :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[187] 	0is_numeric :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[187] 	0is_numeric :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[187] 	0is_numeric :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[188] 	1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[188] 	1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[188] 	1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[188] 	1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[188] 	1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[188] 	1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[188] 	1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[188] 	1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[188] 	1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[188] 	1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[188] 	1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[188] 	1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[189] 	'abs_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_abs_vec_ibeam)
		CHK(6, cleanup, L"[189] 	'abs_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_abs_vec_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[189] 	'abs_vec_ibeam' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[186] absolute{");
	return err;
}

int
cdf_ptr13680(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_is_numeric;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[187] 	0is_numeric :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_numeric->value)
		CHK(6, cleanup, L"[187] 	0is_numeric :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[187] 	0is_numeric :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[187] 	0is_numeric :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[187] 	0is_numeric :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[187] 	0is_numeric :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[187] 	0is_numeric :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[187] 	0is_numeric :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[187] 	0is_numeric :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[187] 	0is_numeric :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[187] 	0is_numeric :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[187] 	0is_numeric :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[188] 	1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[188] 	1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[188] 	1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[188] 	1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[188] 	1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[188] 	1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[188] 	1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[188] 	1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[188] 	1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[188] 	1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[188] 	1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[188] 	1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[189] 	'abs_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_abs_vec_ibeam)
		CHK(6, cleanup, L"[189] 	'abs_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_abs_vec_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[189] 	'abs_vec_ibeam' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[186] absolute{");
	return err;
}

int
cdf_ptr13681(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[191] residue{-+0=}");
	
		CHK(fill_array(arr, dat), cleanup, L"[191] residue{-+0=}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[191] residue{-+0=}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[191] residue{-+0=}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_div)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_div);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[191] residue{-+0=}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_min)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[191] residue{-+0=}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[191] residue{-+0=}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[191] residue{-+0=}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[191] residue{-+0=}");
	return err;
}

int
cdf_ptr13682(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[191] residue{-+0=}");
	
		CHK(fill_array(arr, dat), cleanup, L"[191] residue{-+0=}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[191] residue{-+0=}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[191] residue{-+0=}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_div)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_div);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[191] residue{-+0=}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_min)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[191] residue{-+0=}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[191] residue{-+0=}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[191] residue{-+0=}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[191] residue{-+0=}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[191] residue{-+0=}");
	return err;
}

int
cdf_ptr13683(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[196] 	is_integer :");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[196] 	is_integer :");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[196] 	is_integer :");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[196] 	is_integer :");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[196] 	is_integer :");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[197] 	1289=DR :SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[197] 	1289=DR :SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[197] 	1289=DR :SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[197] 	1289=DR :SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[197] 	1289=DR :SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[197] 	1289=DR :SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[197] 	1289=DR :SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[197] 	1289=DR :SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[197] 	1289=DR :SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[197] 	1289=DR :SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[197] 	1289=DR :SIGNAL 16");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[197] 	1289=DR :SIGNAL 16");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[198] 	'floor_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_floor_vec_ibeam)
		CHK(6, cleanup, L"[198] 	'floor_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_floor_vec_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[198] 	'floor_vec_ibeam' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[195] floor_array{");
	return err;
}

int
cdf_ptr13684(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[196] 	is_integer :");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[196] 	is_integer :");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[196] 	is_integer :");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[196] 	is_integer :");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[196] 	is_integer :");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[197] 	1289=DR :SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[197] 	1289=DR :SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[197] 	1289=DR :SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[197] 	1289=DR :SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[197] 	1289=DR :SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[197] 	1289=DR :SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[197] 	1289=DR :SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[197] 	1289=DR :SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[197] 	1289=DR :SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[197] 	1289=DR :SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[197] 	1289=DR :SIGNAL 16");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[197] 	1289=DR :SIGNAL 16");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[198] 	'floor_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_floor_vec_ibeam)
		CHK(6, cleanup, L"[198] 	'floor_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_floor_vec_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[198] 	'floor_vec_ibeam' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[195] floor_array{");
	return err;
}

int
cdf_ptr13685(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[204] 	is_integer :");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[204] 	is_integer :");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[204] 	is_integer :");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[204] 	is_integer :");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[204] 	is_integer :");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[205] 	1289=DR :--");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[205] 	1289=DR :--");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[205] 	1289=DR :--");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[205] 	1289=DR :--");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[205] 	1289=DR :--");
	
		CHK(fill_array(arr, dat), cleanup, L"[205] 	1289=DR :--");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[205] 	1289=DR :--");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[205] 	1289=DR :--");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[205] 	1289=DR :--");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[205] 	1289=DR :--");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[205] 	1289=DR :--");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_min)
				CHK(6, cleanup, L"[205] 	1289=DR :--");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_min);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[205] 	1289=DR :--");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[205] 	1289=DR :--");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[205] 	1289=DR :--");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[206] 	'ceil_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_ceil_vec_ibeam)
		CHK(6, cleanup, L"[206] 	'ceil_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_ceil_vec_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[206] 	'ceil_vec_ibeam' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[203] ceil_array{");
	return err;
}

int
cdf_ptr13686(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[204] 	is_integer :");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[204] 	is_integer :");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[204] 	is_integer :");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[204] 	is_integer :");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[204] 	is_integer :");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[205] 	1289=DR :--");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[205] 	1289=DR :--");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[205] 	1289=DR :--");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[205] 	1289=DR :--");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[205] 	1289=DR :--");
	
		CHK(fill_array(arr, dat), cleanup, L"[205] 	1289=DR :--");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[205] 	1289=DR :--");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[205] 	1289=DR :--");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[205] 	1289=DR :--");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[205] 	1289=DR :--");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[205] 	1289=DR :--");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_min)
				CHK(6, cleanup, L"[205] 	1289=DR :--");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_min);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[205] 	1289=DR :--");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[205] 	1289=DR :--");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[205] 	1289=DR :--");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[206] 	'ceil_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_ceil_vec_ibeam)
		CHK(6, cleanup, L"[206] 	'ceil_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_ceil_vec_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[206] 	'ceil_vec_ibeam' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[203] ceil_array{");
	return err;
}

int
cdf_ptr13687(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[217] pitimes{3.14159265358979323846}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[217] pitimes{3.14159265358979323846}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_DBL;
		unsigned int rnk = 0;
		double dat[] = {3.141592653589793};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[217] pitimes{3.14159265358979323846}");
	
		CHK(fill_array(arr, dat), cleanup, L"[217] pitimes{3.14159265358979323846}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[217] pitimes{3.14159265358979323846}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[217] pitimes{3.14159265358979323846}");
	return err;
}

int
cdf_ptr13688(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[217] pitimes{3.14159265358979323846}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[217] pitimes{3.14159265358979323846}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_DBL;
		unsigned int rnk = 0;
		double dat[] = {3.141592653589793};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[217] pitimes{3.14159265358979323846}");
	
		CHK(fill_array(arr, dat), cleanup, L"[217] pitimes{3.14159265358979323846}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[217] pitimes{3.14159265358979323846}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[217] pitimes{3.14159265358979323846}");
	return err;
}

int
cdf_ptr13689(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[219] 	0: ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[219] 	0: ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[219] 	0: ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[219] 	0: ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[219] 	0: ");
	
		CHK(fill_array(arr, dat), cleanup, L"[219] 	0: ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[219] 	0: ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[219] 	0: ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[219] 	0: ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[219] 	0: ");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!cdf_self)
				CHK(6, cleanup, L"[219] 	0: ");
			
			*stkhd++ = retain_cell(cdf_self);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[219] 	0: ");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[219] 	0: ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[219] 	0: ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[220] 	0=:(1-*2)*.5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[220] 	0=:(1-*2)*.5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[220] 	0=:(1-*2)*.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[220] 	0=:(1-*2)*.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[220] 	0=:(1-*2)*.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[220] 	0=:(1-*2)*.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[220] 	0=:(1-*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[220] 	0=:(1-*2)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[220] 	0=:(1-*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[220] 	0=:(1-*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[220] 	0=:(1-*2)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[220] 	0=:(1-*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[220] 	0=:(1-*2)*.5");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[220] 	0=:(1-*2)*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[220] 	0=:(1-*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[220] 	0=:(1-*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[220] 	0=:(1-*2)*.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[220] 	0=:(1-*2)*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[220] 	0=:(1-*2)*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[221] 	1=:'sin_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[221] 	1=:'sin_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[221] 	1=:'sin_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[221] 	1=:'sin_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[221] 	1=:'sin_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[221] 	1=:'sin_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[221] 	1=:'sin_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_sin_vec_ibeam)
				CHK(6, cleanup, L"[221] 	1=:'sin_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_sin_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[221] 	1=:'sin_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[222] 	1=:'arcsin_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[222] 	1=:'arcsin_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	1=:'arcsin_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[222] 	1=:'arcsin_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[222] 	1=:'arcsin_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[222] 	1=:'arcsin_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[222] 	1=:'arcsin_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_arcsin_vec_ibeam)
				CHK(6, cleanup, L"[222] 	1=:'arcsin_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_arcsin_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[222] 	1=:'arcsin_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[223] 	2=:'cos_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[223] 	2=:'cos_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[223] 	2=:'cos_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[223] 	2=:'cos_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[223] 	2=:'cos_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[223] 	2=:'cos_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[223] 	2=:'cos_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_cos_vec_ibeam)
				CHK(6, cleanup, L"[223] 	2=:'cos_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_cos_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[223] 	2=:'cos_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[224] 	2=:'arccos_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[224] 	2=:'arccos_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[224] 	2=:'arccos_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[224] 	2=:'arccos_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[224] 	2=:'arccos_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[224] 	2=:'arccos_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[224] 	2=:'arccos_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_arccos_vec_ibeam)
				CHK(6, cleanup, L"[224] 	2=:'arccos_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_arccos_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[224] 	2=:'arccos_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[225] 	3=:'tan_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[225] 	3=:'tan_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[225] 	3=:'tan_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[225] 	3=:'tan_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[225] 	3=:'tan_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[225] 	3=:'tan_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[225] 	3=:'tan_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_tan_vec_ibeam)
				CHK(6, cleanup, L"[225] 	3=:'tan_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_tan_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[225] 	3=:'tan_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[226] 	3=:'arctan_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[226] 	3=:'arctan_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[226] 	3=:'arctan_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[226] 	3=:'arctan_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[226] 	3=:'arctan_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[226] 	3=:'arctan_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[226] 	3=:'arctan_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_arctan_vec_ibeam)
				CHK(6, cleanup, L"[226] 	3=:'arctan_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_arctan_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[226] 	3=:'arctan_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[227] 	4=:(1+*2)*.5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[227] 	4=:(1+*2)*.5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[227] 	4=:(1+*2)*.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[227] 	4=:(1+*2)*.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[227] 	4=:(1+*2)*.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[227] 	4=:(1+*2)*.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[227] 	4=:(1+*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[227] 	4=:(1+*2)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[227] 	4=:(1+*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[227] 	4=:(1+*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[227] 	4=:(1+*2)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[227] 	4=:(1+*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[227] 	4=:(1+*2)*.5");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[227] 	4=:(1+*2)*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[227] 	4=:(1+*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[227] 	4=:(1+*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[227] 	4=:(1+*2)*.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[227] 	4=:(1+*2)*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[227] 	4=:(1+*2)*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[228] 	4=:(+1)((-1)+1)*0.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[228] 	4=:(+1)((-1)+1)*0.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_div)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_div);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_mul)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_mul);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[229] 	5=:'sinh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[229] 	5=:'sinh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {5};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[229] 	5=:'sinh_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[229] 	5=:'sinh_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[229] 	5=:'sinh_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[229] 	5=:'sinh_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[229] 	5=:'sinh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_sinh_vec_ibeam)
				CHK(6, cleanup, L"[229] 	5=:'sinh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_sinh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[229] 	5=:'sinh_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[230] 	5=:'arcsinh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[230] 	5=:'arcsinh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-5};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[230] 	5=:'arcsinh_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[230] 	5=:'arcsinh_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[230] 	5=:'arcsinh_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[230] 	5=:'arcsinh_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[230] 	5=:'arcsinh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_arcsinh_vec_ibeam)
				CHK(6, cleanup, L"[230] 	5=:'arcsinh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_arcsinh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[230] 	5=:'arcsinh_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[231] 	6=:'cosh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[231] 	6=:'cosh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {6};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[231] 	6=:'cosh_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[231] 	6=:'cosh_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[231] 	6=:'cosh_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[231] 	6=:'cosh_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[231] 	6=:'cosh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_cosh_vec_ibeam)
				CHK(6, cleanup, L"[231] 	6=:'cosh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_cosh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[231] 	6=:'cosh_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[232] 	6=:'arccosh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[232] 	6=:'arccosh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-6};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[232] 	6=:'arccosh_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[232] 	6=:'arccosh_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[232] 	6=:'arccosh_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[232] 	6=:'arccosh_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[232] 	6=:'arccosh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_arccosh_vec_ibeam)
				CHK(6, cleanup, L"[232] 	6=:'arccosh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_arccosh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[232] 	6=:'arccosh_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[233] 	7=:'tanh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[233] 	7=:'tanh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {7};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[233] 	7=:'tanh_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[233] 	7=:'tanh_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[233] 	7=:'tanh_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[233] 	7=:'tanh_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[233] 	7=:'tanh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_tanh_vec_ibeam)
				CHK(6, cleanup, L"[233] 	7=:'tanh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_tanh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[233] 	7=:'tanh_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[234] 	7=:'arctanh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[234] 	7=:'arctanh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-7};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[234] 	7=:'arctanh_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[234] 	7=:'arctanh_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[234] 	7=:'arctanh_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[234] 	7=:'arctanh_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[234] 	7=:'arctanh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_arctanh_vec_ibeam)
				CHK(6, cleanup, L"[234] 	7=:'arctanh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_arctanh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[234] 	7=:'arctanh_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[235] 	8=:(-1+*2)*0.5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[235] 	8=:(-1+*2)*0.5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {8};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[235] 	8=:(-1+*2)*0.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[235] 	8=:(-1+*2)*0.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[235] 	8=:(-1+*2)*0.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[235] 	8=:(-1+*2)*0.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[235] 	8=:(-1+*2)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[235] 	8=:(-1+*2)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[235] 	8=:(-1+*2)*0.5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[235] 	8=:(-1+*2)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[236] 	8=:-8");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[236] 	8=:-8");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-8};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[236] 	8=:-8");
	
		CHK(fill_array(arr, dat), cleanup, L"[236] 	8=:-8");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[236] 	8=:-8");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[236] 	8=:-8");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[236] 	8=:-8");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cir)
				CHK(6, cleanup, L"[236] 	8=:-8");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cir);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {8};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[236] 	8=:-8");
			
				CHK(fill_array(arr, dat), cleanup, L"[236] 	8=:-8");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[236] 	8=:-8");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[236] 	8=:-8");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[236] 	8=:-8");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {9};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		CHK(fill_array(arr, dat), cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13690, cdf_ptr13691, 0), cleanup, 
				    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[238] 	9=:");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[238] 	9=:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-9};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[238] 	9=:");
	
		CHK(fill_array(arr, dat), cleanup, L"[238] 	9=:");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[238] 	9=:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[238] 	9=:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[238] 	9=:");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[239] 	10=:|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[239] 	10=:|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {10};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[239] 	10=:|");
	
		CHK(fill_array(arr, dat), cleanup, L"[239] 	10=:|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[239] 	10=:|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[239] 	10=:|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[239] 	10=:|");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_res)
				CHK(6, cleanup, L"[239] 	10=:|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[239] 	10=:|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[240] 	10=:+");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[240] 	10=:+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-10};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[240] 	10=:+");
	
		CHK(fill_array(arr, dat), cleanup, L"[240] 	10=:+");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[240] 	10=:+");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[240] 	10=:+");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[240] 	10=:+");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[240] 	10=:+");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[240] 	10=:+");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13692, cdf_ptr13693, 0), cleanup, 
				    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[242] 	11=:0J1");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[242] 	11=:0J1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[242] 	11=:0J1");
	
		CHK(fill_array(arr, dat), cleanup, L"[242] 	11=:0J1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[242] 	11=:0J1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[242] 	11=:0J1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CMPX;
				unsigned int rnk = 0;
				struct apl_cmpx dat[] = {{0, 1}};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[242] 	11=:0J1");
			
				CHK(fill_array(arr, dat), cleanup, L"[242] 	11=:0J1");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_mul)
				CHK(6, cleanup, L"[242] 	11=:0J1");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_mul);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[242] 	11=:0J1");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[242] 	11=:0J1");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CHAR16;
				unsigned int rnk = 1;
				uint16_t dat[] = {80, 72, 65, 83, 69, 40, 9077, 41, 32, 78, 79, 84, 32, 73, 77, 80, 76, 69, 77, 69, 78, 84, 69, 68};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
			
				arr->shape[0] = 24;
			
				CHK(fill_array(arr, dat), cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[244] 	12=:*0J1");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[244] 	12=:*0J1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[244] 	12=:*0J1");
	
		CHK(fill_array(arr, dat), cleanup, L"[244] 	12=:*0J1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[244] 	12=:*0J1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[244] 	12=:*0J1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CMPX;
				unsigned int rnk = 0;
				struct apl_cmpx dat[] = {{0, 1}};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[244] 	12=:*0J1");
			
				CHK(fill_array(arr, dat), cleanup, L"[244] 	12=:*0J1");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_mul)
				CHK(6, cleanup, L"[244] 	12=:*0J1");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_mul);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[244] 	12=:*0J1");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[244] 	12=:*0J1");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[244] 	12=:*0J1");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[244] 	12=:*0J1");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[245] 	SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[245] 	SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[245] 	SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[245] 	SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[218] trig{");
	return err;
}

int
cdf_ptr13690(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		CHK(fill_array(arr, dat), cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_realpart_vec_ibeam)
				CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
			*stkhd++ = retain_cell(cdf_realpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	return err;
}

int
cdf_ptr13691(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		CHK(fill_array(arr, dat), cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_realpart_vec_ibeam)
				CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
			*stkhd++ = retain_cell(cdf_realpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	return err;
}

int
cdf_ptr13692(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_imagpart_vec_ibeam)
				CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
			*stkhd++ = retain_cell(cdf_imagpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	return err;
}

int
cdf_ptr13693(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_imagpart_vec_ibeam)
				CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
			*stkhd++ = retain_cell(cdf_imagpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	return err;
}

int
cdf_ptr13694(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[219] 	0: ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[219] 	0: ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[219] 	0: ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[219] 	0: ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[219] 	0: ");
	
		CHK(fill_array(arr, dat), cleanup, L"[219] 	0: ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[219] 	0: ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[219] 	0: ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[219] 	0: ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[219] 	0: ");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			if (!cdf_self)
				CHK(6, cleanup, L"[219] 	0: ");
			
			*stkhd++ = retain_cell(cdf_self);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[219] 	0: ");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[219] 	0: ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[219] 	0: ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[220] 	0=:(1-*2)*.5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[220] 	0=:(1-*2)*.5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[220] 	0=:(1-*2)*.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[220] 	0=:(1-*2)*.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[220] 	0=:(1-*2)*.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[220] 	0=:(1-*2)*.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[220] 	0=:(1-*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[220] 	0=:(1-*2)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[220] 	0=:(1-*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[220] 	0=:(1-*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[220] 	0=:(1-*2)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[220] 	0=:(1-*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[220] 	0=:(1-*2)*.5");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[220] 	0=:(1-*2)*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[220] 	0=:(1-*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[220] 	0=:(1-*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[220] 	0=:(1-*2)*.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[220] 	0=:(1-*2)*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[220] 	0=:(1-*2)*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[221] 	1=:'sin_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[221] 	1=:'sin_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[221] 	1=:'sin_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[221] 	1=:'sin_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[221] 	1=:'sin_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[221] 	1=:'sin_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[221] 	1=:'sin_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_sin_vec_ibeam)
				CHK(6, cleanup, L"[221] 	1=:'sin_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_sin_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[221] 	1=:'sin_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[222] 	1=:'arcsin_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[222] 	1=:'arcsin_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	1=:'arcsin_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[222] 	1=:'arcsin_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[222] 	1=:'arcsin_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[222] 	1=:'arcsin_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[222] 	1=:'arcsin_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_arcsin_vec_ibeam)
				CHK(6, cleanup, L"[222] 	1=:'arcsin_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_arcsin_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[222] 	1=:'arcsin_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[223] 	2=:'cos_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[223] 	2=:'cos_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[223] 	2=:'cos_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[223] 	2=:'cos_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[223] 	2=:'cos_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[223] 	2=:'cos_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[223] 	2=:'cos_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_cos_vec_ibeam)
				CHK(6, cleanup, L"[223] 	2=:'cos_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_cos_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[223] 	2=:'cos_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[224] 	2=:'arccos_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[224] 	2=:'arccos_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[224] 	2=:'arccos_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[224] 	2=:'arccos_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[224] 	2=:'arccos_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[224] 	2=:'arccos_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[224] 	2=:'arccos_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_arccos_vec_ibeam)
				CHK(6, cleanup, L"[224] 	2=:'arccos_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_arccos_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[224] 	2=:'arccos_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[225] 	3=:'tan_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[225] 	3=:'tan_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[225] 	3=:'tan_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[225] 	3=:'tan_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[225] 	3=:'tan_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[225] 	3=:'tan_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[225] 	3=:'tan_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_tan_vec_ibeam)
				CHK(6, cleanup, L"[225] 	3=:'tan_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_tan_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[225] 	3=:'tan_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[226] 	3=:'arctan_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[226] 	3=:'arctan_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[226] 	3=:'arctan_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[226] 	3=:'arctan_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[226] 	3=:'arctan_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[226] 	3=:'arctan_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[226] 	3=:'arctan_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_arctan_vec_ibeam)
				CHK(6, cleanup, L"[226] 	3=:'arctan_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_arctan_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[226] 	3=:'arctan_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[227] 	4=:(1+*2)*.5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[227] 	4=:(1+*2)*.5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[227] 	4=:(1+*2)*.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[227] 	4=:(1+*2)*.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[227] 	4=:(1+*2)*.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[227] 	4=:(1+*2)*.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[227] 	4=:(1+*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[227] 	4=:(1+*2)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[227] 	4=:(1+*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[227] 	4=:(1+*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[227] 	4=:(1+*2)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[227] 	4=:(1+*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[227] 	4=:(1+*2)*.5");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[227] 	4=:(1+*2)*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[227] 	4=:(1+*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[227] 	4=:(1+*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[227] 	4=:(1+*2)*.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[227] 	4=:(1+*2)*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[227] 	4=:(1+*2)*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[228] 	4=:(+1)((-1)+1)*0.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[228] 	4=:(+1)((-1)+1)*0.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_div)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_div);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_mul)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_mul);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[228] 	4=:(+1)((-1)+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[228] 	4=:(+1)((-1)+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[229] 	5=:'sinh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[229] 	5=:'sinh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {5};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[229] 	5=:'sinh_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[229] 	5=:'sinh_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[229] 	5=:'sinh_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[229] 	5=:'sinh_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[229] 	5=:'sinh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_sinh_vec_ibeam)
				CHK(6, cleanup, L"[229] 	5=:'sinh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_sinh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[229] 	5=:'sinh_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[230] 	5=:'arcsinh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[230] 	5=:'arcsinh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-5};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[230] 	5=:'arcsinh_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[230] 	5=:'arcsinh_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[230] 	5=:'arcsinh_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[230] 	5=:'arcsinh_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[230] 	5=:'arcsinh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_arcsinh_vec_ibeam)
				CHK(6, cleanup, L"[230] 	5=:'arcsinh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_arcsinh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[230] 	5=:'arcsinh_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[231] 	6=:'cosh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[231] 	6=:'cosh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {6};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[231] 	6=:'cosh_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[231] 	6=:'cosh_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[231] 	6=:'cosh_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[231] 	6=:'cosh_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[231] 	6=:'cosh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_cosh_vec_ibeam)
				CHK(6, cleanup, L"[231] 	6=:'cosh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_cosh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[231] 	6=:'cosh_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[232] 	6=:'arccosh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[232] 	6=:'arccosh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-6};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[232] 	6=:'arccosh_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[232] 	6=:'arccosh_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[232] 	6=:'arccosh_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[232] 	6=:'arccosh_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[232] 	6=:'arccosh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_arccosh_vec_ibeam)
				CHK(6, cleanup, L"[232] 	6=:'arccosh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_arccosh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[232] 	6=:'arccosh_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[233] 	7=:'tanh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[233] 	7=:'tanh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {7};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[233] 	7=:'tanh_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[233] 	7=:'tanh_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[233] 	7=:'tanh_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[233] 	7=:'tanh_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[233] 	7=:'tanh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_tanh_vec_ibeam)
				CHK(6, cleanup, L"[233] 	7=:'tanh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_tanh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[233] 	7=:'tanh_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[234] 	7=:'arctanh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[234] 	7=:'arctanh_vec_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-7};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[234] 	7=:'arctanh_vec_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[234] 	7=:'arctanh_vec_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[234] 	7=:'arctanh_vec_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[234] 	7=:'arctanh_vec_ibeam' ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[234] 	7=:'arctanh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_arctanh_vec_ibeam)
				CHK(6, cleanup, L"[234] 	7=:'arctanh_vec_ibeam' ");
			
			*stkhd++ = retain_cell(cdf_arctanh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[234] 	7=:'arctanh_vec_ibeam' ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[235] 	8=:(-1+*2)*0.5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[235] 	8=:(-1+*2)*0.5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {8};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[235] 	8=:(-1+*2)*0.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[235] 	8=:(-1+*2)*0.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[235] 	8=:(-1+*2)*0.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[235] 	8=:(-1+*2)*0.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[235] 	8=:(-1+*2)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[235] 	8=:(-1+*2)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[235] 	8=:(-1+*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[235] 	8=:(-1+*2)*0.5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[235] 	8=:(-1+*2)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[236] 	8=:-8");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[236] 	8=:-8");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-8};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[236] 	8=:-8");
	
		CHK(fill_array(arr, dat), cleanup, L"[236] 	8=:-8");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[236] 	8=:-8");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[236] 	8=:-8");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[236] 	8=:-8");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cir)
				CHK(6, cleanup, L"[236] 	8=:-8");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cir);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {8};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[236] 	8=:-8");
			
				CHK(fill_array(arr, dat), cleanup, L"[236] 	8=:-8");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[236] 	8=:-8");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[236] 	8=:-8");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[236] 	8=:-8");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {9};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		CHK(fill_array(arr, dat), cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13695, cdf_ptr13696, 0), cleanup, 
				    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[238] 	9=:");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[238] 	9=:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-9};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[238] 	9=:");
	
		CHK(fill_array(arr, dat), cleanup, L"[238] 	9=:");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[238] 	9=:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[238] 	9=:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[238] 	9=:");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[239] 	10=:|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[239] 	10=:|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {10};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[239] 	10=:|");
	
		CHK(fill_array(arr, dat), cleanup, L"[239] 	10=:|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[239] 	10=:|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[239] 	10=:|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[239] 	10=:|");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_res)
				CHK(6, cleanup, L"[239] 	10=:|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[239] 	10=:|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[240] 	10=:+");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[240] 	10=:+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-10};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[240] 	10=:+");
	
		CHK(fill_array(arr, dat), cleanup, L"[240] 	10=:+");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[240] 	10=:+");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[240] 	10=:+");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[240] 	10=:+");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[240] 	10=:+");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[240] 	10=:+");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13697, cdf_ptr13698, 0), cleanup, 
				    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[242] 	11=:0J1");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[242] 	11=:0J1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[242] 	11=:0J1");
	
		CHK(fill_array(arr, dat), cleanup, L"[242] 	11=:0J1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[242] 	11=:0J1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[242] 	11=:0J1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CMPX;
				unsigned int rnk = 0;
				struct apl_cmpx dat[] = {{0, 1}};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[242] 	11=:0J1");
			
				CHK(fill_array(arr, dat), cleanup, L"[242] 	11=:0J1");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_mul)
				CHK(6, cleanup, L"[242] 	11=:0J1");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_mul);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[242] 	11=:0J1");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[242] 	11=:0J1");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CHAR16;
				unsigned int rnk = 1;
				uint16_t dat[] = {80, 72, 65, 83, 69, 40, 9077, 41, 32, 78, 79, 84, 32, 73, 77, 80, 76, 69, 77, 69, 78, 84, 69, 68};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
			
				arr->shape[0] = 24;
			
				CHK(fill_array(arr, dat), cleanup, L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[243] 	12=:'PHASE() NOT IMPLEMENTED'SIGNAL 16");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[244] 	12=:*0J1");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[244] 	12=:*0J1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[244] 	12=:*0J1");
	
		CHK(fill_array(arr, dat), cleanup, L"[244] 	12=:*0J1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[244] 	12=:*0J1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[244] 	12=:*0J1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CMPX;
				unsigned int rnk = 0;
				struct apl_cmpx dat[] = {{0, 1}};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[244] 	12=:*0J1");
			
				CHK(fill_array(arr, dat), cleanup, L"[244] 	12=:*0J1");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_mul)
				CHK(6, cleanup, L"[244] 	12=:*0J1");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_mul);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[244] 	12=:*0J1");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[244] 	12=:*0J1");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_exp)
				CHK(6, cleanup, L"[244] 	12=:*0J1");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_exp);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[244] 	12=:*0J1");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[245] 	SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[245] 	SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[245] 	SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[245] 	SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[218] trig{");
	return err;
}

int
cdf_ptr13695(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		CHK(fill_array(arr, dat), cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_realpart_vec_ibeam)
				CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
			*stkhd++ = retain_cell(cdf_realpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	return err;
}

int
cdf_ptr13696(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		CHK(fill_array(arr, dat), cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_realpart_vec_ibeam)
				CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
			*stkhd++ = retain_cell(cdf_realpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[237] 	9=:{1289DR :'realpart_vec_ibeam'   }");
	return err;
}

int
cdf_ptr13697(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_imagpart_vec_ibeam)
				CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
			*stkhd++ = retain_cell(cdf_imagpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	return err;
}

int
cdf_ptr13698(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_imagpart_vec_ibeam)
				CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
			*stkhd++ = retain_cell(cdf_imagpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[241] 	11=:{1289DR :'imagpart_vec_ibeam'   ()0}");
	return err;
}

int
cdf_ptr13699(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_min)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_min)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[251] 	,(=)(<0):SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[252] 	(!)(!)!-");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_fac)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[252] 	(!)(!)!-");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_fac)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[252] 	(!)(!)!-");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[252] 	(!)(!)!-");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_div)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_div);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_fac)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[252] 	(!)(!)!-");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[252] 	(!)(!)!-");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[250] binomial{");
	return err;
}

int
cdf_ptr13700(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_min)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_min)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[251] 	,(=)(<0):SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[251] 	,(=)(<0):SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[251] 	,(=)(<0):SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[252] 	(!)(!)!-");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_fac)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[252] 	(!)(!)!-");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_fac)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[252] 	(!)(!)!-");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[252] 	(!)(!)!-");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_div)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_div);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_fac)
		CHK(6, cleanup, L"[252] 	(!)(!)!-");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[252] 	(!)(!)!-");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[252] 	(!)(!)!-");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[250] binomial{");
	return err;
}

int
cdf_ptr13701(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_is_bool;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_bool->value)
		CHK(6, cleanup, L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->cdf_is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_not_vec_ibeam)
				CHK(6, cleanup, L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_not_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	return err;
}

int
cdf_ptr13702(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_is_bool;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_bool->value)
		CHK(6, cleanup, L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->cdf_is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_not_vec_ibeam)
				CHK(6, cleanup, L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_not_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[257] notscl{is_bool :'not_vec_ibeam'   SIGNAL 11}");
	return err;
}

int
cdf_ptr13703(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[258] without{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[258] without{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[258] without{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[258] without{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[258] without{SIGNAL 16}");
	return err;
}

int
cdf_ptr13704(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[258] without{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[258] without{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[258] without{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[258] without{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[258] without{SIGNAL 16}");
	return err;
}

int
cdf_ptr13705(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_both_bool;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_z = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[263] 	 both_bool :('and_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_bool->value)
		CHK(6, cleanup, L"[263] 	 both_bool :('and_vec_ibeam')");
	
	*stkhd++ = retain_cell(lex->cdf_both_bool->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[263] 	 both_bool :('and_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[263] 	 both_bool :('and_vec_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[263] 	 both_bool :('and_vec_ibeam')");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[263] 	 both_bool :('and_vec_ibeam')");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_and_vec_ibeam)
				CHK(6, cleanup, L"[263] 	 both_bool :('and_vec_ibeam')");
			
			*stkhd++ = retain_cell(cdf_and_vec_ibeam);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[263] 	 both_bool :('and_vec_ibeam')");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[263] 	 both_bool :('and_vec_ibeam')");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[264] 	z+0=z");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z);
	loc->cdf_z = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[264] 	z+0=z");
	
		CHK(fill_array(arr, dat), cleanup, L"[264] 	z+0=z");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[264] 	z+0=z");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_z)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(loc->cdf_z);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[264] 	z+0=z");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_div)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_div);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[264] 	z+0=z");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[264] 	z+0=z");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[262] logand{");
	return err;
}

int
cdf_ptr13706(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_both_bool;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_z = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[263] 	 both_bool :('and_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_bool->value)
		CHK(6, cleanup, L"[263] 	 both_bool :('and_vec_ibeam')");
	
	*stkhd++ = retain_cell(lex->cdf_both_bool->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[263] 	 both_bool :('and_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[263] 	 both_bool :('and_vec_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[263] 	 both_bool :('and_vec_ibeam')");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[263] 	 both_bool :('and_vec_ibeam')");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_and_vec_ibeam)
				CHK(6, cleanup, L"[263] 	 both_bool :('and_vec_ibeam')");
			
			*stkhd++ = retain_cell(cdf_and_vec_ibeam);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[263] 	 both_bool :('and_vec_ibeam')");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[263] 	 both_bool :('and_vec_ibeam')");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[264] 	z+0=z");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z);
	loc->cdf_z = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[264] 	z+0=z");
	
		CHK(fill_array(arr, dat), cleanup, L"[264] 	z+0=z");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[264] 	z+0=z");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_z)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(loc->cdf_z);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[264] 	z+0=z");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_div)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_div);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[264] 	z+0=z");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[264] 	z+0=z");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[264] 	z+0=z");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[262] logand{");
	return err;
}

int
cdf_ptr13707(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	return err;
}

int
cdf_ptr13708(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[266] and{SIGNAL 2}ambiv (logand numeric scalar)");
	return err;
}

int
cdf_ptr13709(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_both_bool;
		struct cell_func_box *cdf_both_integer;
		struct cell_func_box *cdf_is_bool;
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[270] 	 both_bool :('lor_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_bool->value)
		CHK(6, cleanup, L"[270] 	 both_bool :('lor_vec_ibeam')");
	
	*stkhd++ = retain_cell(lex->cdf_both_bool->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[270] 	 both_bool :('lor_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[270] 	 both_bool :('lor_vec_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[270] 	 both_bool :('lor_vec_ibeam')");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[270] 	 both_bool :('lor_vec_ibeam')");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_lor_vec_ibeam)
				CHK(6, cleanup, L"[270] 	 both_bool :('lor_vec_ibeam')");
			
			*stkhd++ = retain_cell(cdf_lor_vec_ibeam);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[270] 	 both_bool :('lor_vec_ibeam')");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[270] 	 both_bool :('lor_vec_ibeam')");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[271] 	(is_bool )is_integer :+(~)|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_bool->value)
		CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(lex->cdf_is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[271] 	(is_bool )is_integer :+(~)|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[271] 	(is_bool )is_integer :+(~)|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[271] 	(is_bool )is_integer :+(~)|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_res)
				CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[271] 	(is_bool )is_integer :+(~)|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_mul)
				CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_mul);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_not)
				CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[271] 	(is_bool )is_integer :+(~)|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[271] 	(is_bool )is_integer :+(~)|");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[271] 	(is_bool )is_integer :+(~)|");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[272] 	(is_bool )is_integer :+(~)|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_bool->value)
		CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(lex->cdf_is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[272] 	(is_bool )is_integer :+(~)|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[272] 	(is_bool )is_integer :+(~)|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[272] 	(is_bool )is_integer :+(~)|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_res)
				CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[272] 	(is_bool )is_integer :+(~)|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_mul)
				CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_mul);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_not)
				CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[272] 	(is_bool )is_integer :+(~)|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[272] 	(is_bool )is_integer :+(~)|");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[272] 	(is_bool )is_integer :+(~)|");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_integer->value)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(lex->cdf_both_integer->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_res)
				CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13710, cdf_ptr13711, 0), cleanup, 
				    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
				*stkhd++ = k;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_res)
				CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13712, cdf_ptr13713, 0), cleanup, 
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		*stkhd++ = k;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[269] logor{");
	return err;
}

int
cdf_ptr13710(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_m);
	loc->cdf_m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_self)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_self);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	return err;
}

int
cdf_ptr13711(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_m);
	loc->cdf_m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_self)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_self);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	return err;
}

int
cdf_ptr13712(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_DBL;
		unsigned int rnk = 0;
		double dat[] = {1E-12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		CHK(fill_array(arr, dat), cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_gth)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_gth);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_m);
	loc->cdf_m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_self)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_self);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	return err;
}

int
cdf_ptr13713(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_DBL;
		unsigned int rnk = 0;
		double dat[] = {1E-12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		CHK(fill_array(arr, dat), cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_gth)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_gth);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_m);
	loc->cdf_m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_self)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_self);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	return err;
}

int
cdf_ptr13714(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_both_bool;
		struct cell_func_box *cdf_both_integer;
		struct cell_func_box *cdf_is_bool;
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[270] 	 both_bool :('lor_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_bool->value)
		CHK(6, cleanup, L"[270] 	 both_bool :('lor_vec_ibeam')");
	
	*stkhd++ = retain_cell(lex->cdf_both_bool->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[270] 	 both_bool :('lor_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[270] 	 both_bool :('lor_vec_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[270] 	 both_bool :('lor_vec_ibeam')");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[270] 	 both_bool :('lor_vec_ibeam')");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_lor_vec_ibeam)
				CHK(6, cleanup, L"[270] 	 both_bool :('lor_vec_ibeam')");
			
			*stkhd++ = retain_cell(cdf_lor_vec_ibeam);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[270] 	 both_bool :('lor_vec_ibeam')");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[270] 	 both_bool :('lor_vec_ibeam')");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[271] 	(is_bool )is_integer :+(~)|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_bool->value)
		CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(lex->cdf_is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[271] 	(is_bool )is_integer :+(~)|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[271] 	(is_bool )is_integer :+(~)|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[271] 	(is_bool )is_integer :+(~)|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_res)
				CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[271] 	(is_bool )is_integer :+(~)|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_mul)
				CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_mul);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_not)
				CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[271] 	(is_bool )is_integer :+(~)|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[271] 	(is_bool )is_integer :+(~)|");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[271] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[271] 	(is_bool )is_integer :+(~)|");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[272] 	(is_bool )is_integer :+(~)|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_is_bool->value)
		CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
	
	*stkhd++ = retain_cell(lex->cdf_is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[272] 	(is_bool )is_integer :+(~)|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[272] 	(is_bool )is_integer :+(~)|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[272] 	(is_bool )is_integer :+(~)|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_res)
				CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[272] 	(is_bool )is_integer :+(~)|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_mul)
				CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_mul);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_not)
				CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[272] 	(is_bool )is_integer :+(~)|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[272] 	(is_bool )is_integer :+(~)|");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[272] 	(is_bool )is_integer :+(~)|");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[272] 	(is_bool )is_integer :+(~)|");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_integer->value)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(lex->cdf_both_integer->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_res)
				CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13715, cdf_ptr13716, 0), cleanup, 
				    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
				*stkhd++ = k;
			}
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_res)
				CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13717, cdf_ptr13718, 0), cleanup, 
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		*stkhd++ = k;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[269] logor{");
	return err;
}

int
cdf_ptr13715(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_m);
	loc->cdf_m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_self)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_self);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	return err;
}

int
cdf_ptr13716(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_neq)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_neq);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_m);
	loc->cdf_m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_self)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_self);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[273] 	 both_integer :(|){~m0:  ((~m)+m)(~m)+m|}|");
	return err;
}

int
cdf_ptr13717(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_DBL;
		unsigned int rnk = 0;
		double dat[] = {1E-12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		CHK(fill_array(arr, dat), cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_gth)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_gth);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_m);
	loc->cdf_m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_self)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_self);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	return err;
}

int
cdf_ptr13718(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_DBL;
		unsigned int rnk = 0;
		double dat[] = {1E-12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		CHK(fill_array(arr, dat), cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_gth)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_gth);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_m);
	loc->cdf_m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_self)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_self);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_m)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(loc->cdf_m);
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[274] 	(|){~m>1e12:  ((~m)+m)(~m)+m|}|");
	return err;
}

int
cdf_ptr13719(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	return err;
}

int
cdf_ptr13720(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[276] lor{SIGNAL 2}ambiv (logor numeric scalar)");
	return err;
}

int
cdf_ptr13721(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	return err;
}

int
cdf_ptr13722(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	return err;
}

int
cdf_ptr13723(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_both_bool;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_bool->value)
		CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->cdf_both_bool->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_and)
				CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_and);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_not)
				CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	return err;
}

int
cdf_ptr13724(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_both_bool;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_bool->value)
		CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->cdf_both_bool->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_and)
				CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_and);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_not)
				CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[279] nan{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	return err;
}

int
cdf_ptr13725(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	return err;
}

int
cdf_ptr13726(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	return err;
}

int
cdf_ptr13727(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_both_bool;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_bool->value)
		CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->cdf_both_bool->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_lor)
				CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lor);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_not)
				CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	return err;
}

int
cdf_ptr13728(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_both_bool;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_bool->value)
		CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->cdf_both_bool->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_lor)
				CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lor);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_not)
				CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[282] nor{SIGNAL 2}ambiv{ both_bool :~  SIGNAL 11}");
	return err;
}

int
cdf_ptr13729(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[287] 	('lth_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_lth_vec_ibeam)
		CHK(6, cleanup, L"[287] 	('lth_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_lth_vec_ibeam);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[287] 	('lth_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[287] 	('lth_vec_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[285] lessthan{");
	return err;
}

int
cdf_ptr13730(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[286] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[287] 	('lth_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_lth_vec_ibeam)
		CHK(6, cleanup, L"[287] 	('lth_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_lth_vec_ibeam);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[287] 	('lth_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[287] 	('lth_vec_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[285] lessthan{");
	return err;
}

int
cdf_ptr13731(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	return err;
}

int
cdf_ptr13732(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[289] lth{SIGNAL 2} ambiv (lessthan numeric scalar)");
	return err;
}

int
cdf_ptr13733(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[294] 	('lte_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_lte_vec_ibeam)
		CHK(6, cleanup, L"[294] 	('lte_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_lte_vec_ibeam);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[294] 	('lte_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[294] 	('lte_vec_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[292] lesseql{");
	return err;
}

int
cdf_ptr13734(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[293] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[294] 	('lte_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_lte_vec_ibeam)
		CHK(6, cleanup, L"[294] 	('lte_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_lte_vec_ibeam);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[294] 	('lte_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[294] 	('lte_vec_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[292] lesseql{");
	return err;
}

int
cdf_ptr13735(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	return err;
}

int
cdf_ptr13736(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[296] lte{SIGNAL 2}ambiv (lesseql numeric scalar)");
	return err;
}

int
cdf_ptr13737(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_eql_vec;
		struct cell_func_box *cdf_both_char;
		struct cell_func_box *cdf_both_numeric;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[301] 	 both_numeric : eql_vec ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_numeric->value)
		CHK(6, cleanup, L"[301] 	 both_numeric : eql_vec ");
	
	*stkhd++ = retain_cell(lex->cdf_both_numeric->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[301] 	 both_numeric : eql_vec ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[301] 	 both_numeric : eql_vec ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[301] 	 both_numeric : eql_vec ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[301] 	 both_numeric : eql_vec ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_eql_vec->value)
				CHK(6, cleanup, L"[301] 	 both_numeric : eql_vec ");
			
			*stkhd++ = retain_cell(lex->cdf_eql_vec->value);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[301] 	 both_numeric : eql_vec ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[301] 	 both_numeric : eql_vec ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[302] 	 both_char : eql_vec ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_char->value)
		CHK(6, cleanup, L"[302] 	 both_char : eql_vec ");
	
	*stkhd++ = retain_cell(lex->cdf_both_char->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[302] 	 both_char : eql_vec ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[302] 	 both_char : eql_vec ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[302] 	 both_char : eql_vec ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[302] 	 both_char : eql_vec ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_eql_vec->value)
				CHK(6, cleanup, L"[302] 	 both_char : eql_vec ");
			
			*stkhd++ = retain_cell(lex->cdf_eql_vec->value);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[302] 	 both_char : eql_vec ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[302] 	 both_char : eql_vec ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[303] 	0");
	
		CHK(fill_array(arr, dat), cleanup, L"[303] 	0");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[300] equal{");
	return err;
}

int
cdf_ptr13738(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_eql_vec;
		struct cell_func_box *cdf_both_char;
		struct cell_func_box *cdf_both_numeric;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[301] 	 both_numeric : eql_vec ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_numeric->value)
		CHK(6, cleanup, L"[301] 	 both_numeric : eql_vec ");
	
	*stkhd++ = retain_cell(lex->cdf_both_numeric->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[301] 	 both_numeric : eql_vec ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[301] 	 both_numeric : eql_vec ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[301] 	 both_numeric : eql_vec ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[301] 	 both_numeric : eql_vec ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_eql_vec->value)
				CHK(6, cleanup, L"[301] 	 both_numeric : eql_vec ");
			
			*stkhd++ = retain_cell(lex->cdf_eql_vec->value);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[301] 	 both_numeric : eql_vec ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[301] 	 both_numeric : eql_vec ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[302] 	 both_char : eql_vec ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_char->value)
		CHK(6, cleanup, L"[302] 	 both_char : eql_vec ");
	
	*stkhd++ = retain_cell(lex->cdf_both_char->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[302] 	 both_char : eql_vec ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[302] 	 both_char : eql_vec ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[302] 	 both_char : eql_vec ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[302] 	 both_char : eql_vec ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_eql_vec->value)
				CHK(6, cleanup, L"[302] 	 both_char : eql_vec ");
			
			*stkhd++ = retain_cell(lex->cdf_eql_vec->value);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[302] 	 both_char : eql_vec ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[302] 	 both_char : eql_vec ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[303] 	0");
	
		CHK(fill_array(arr, dat), cleanup, L"[303] 	0");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[300] equal{");
	return err;
}

int
cdf_ptr13739(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	return err;
}

int
cdf_ptr13740(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[305] eql{SIGNAL 2}ambiv (equal scalar)");
	return err;
}

int
cdf_ptr13741(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[310] 	('gte_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_gte_vec_ibeam)
		CHK(6, cleanup, L"[310] 	('gte_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_gte_vec_ibeam);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[310] 	('gte_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[310] 	('gte_vec_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[308] greatereql{");
	return err;
}

int
cdf_ptr13742(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[309] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[310] 	('gte_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_gte_vec_ibeam)
		CHK(6, cleanup, L"[310] 	('gte_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_gte_vec_ibeam);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[310] 	('gte_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[310] 	('gte_vec_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[308] greatereql{");
	return err;
}

int
cdf_ptr13743(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	return err;
}

int
cdf_ptr13744(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[312] gte{SIGNAL 2}ambiv (greatereql numeric scalar)");
	return err;
}

int
cdf_ptr13745(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[317] 	('gth_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_gth_vec_ibeam)
		CHK(6, cleanup, L"[317] 	('gth_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_gth_vec_ibeam);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[317] 	('gth_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[317] 	('gth_vec_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[315] greaterthan{");
	return err;
}

int
cdf_ptr13746(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_q_dr)
		CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[316] 	1289DR :SIGNAL 11  1289DR :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[317] 	('gth_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_gth_vec_ibeam)
		CHK(6, cleanup, L"[317] 	('gth_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_gth_vec_ibeam);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[317] 	('gth_vec_ibeam')");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[317] 	('gth_vec_ibeam')");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[315] greaterthan{");
	return err;
}

int
cdf_ptr13747(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	return err;
}

int
cdf_ptr13748(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[319] gth{SIGNAL 2}ambiv (greaterthan numeric scalar)");
	return err;
}

int
cdf_ptr13749(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[322] firstocc{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[322] firstocc{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[322] firstocc{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[322] firstocc{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[322] firstocc{SIGNAL 16}");
	return err;
}

int
cdf_ptr13750(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[322] firstocc{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[322] firstocc{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[322] firstocc{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[322] firstocc{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[322] firstocc{SIGNAL 16}");
	return err;
}

int
cdf_ptr13751(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_neq_vec;
		struct cell_func_box *cdf_both_char;
		struct cell_func_box *cdf_both_numeric;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[325] 	 both_numeric : neq_vec ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_numeric->value)
		CHK(6, cleanup, L"[325] 	 both_numeric : neq_vec ");
	
	*stkhd++ = retain_cell(lex->cdf_both_numeric->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[325] 	 both_numeric : neq_vec ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[325] 	 both_numeric : neq_vec ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[325] 	 both_numeric : neq_vec ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[325] 	 both_numeric : neq_vec ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_neq_vec->value)
				CHK(6, cleanup, L"[325] 	 both_numeric : neq_vec ");
			
			*stkhd++ = retain_cell(lex->cdf_neq_vec->value);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[325] 	 both_numeric : neq_vec ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[325] 	 both_numeric : neq_vec ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[326] 	 both_char : neq_vec ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_char->value)
		CHK(6, cleanup, L"[326] 	 both_char : neq_vec ");
	
	*stkhd++ = retain_cell(lex->cdf_both_char->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[326] 	 both_char : neq_vec ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[326] 	 both_char : neq_vec ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[326] 	 both_char : neq_vec ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[326] 	 both_char : neq_vec ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_neq_vec->value)
				CHK(6, cleanup, L"[326] 	 both_char : neq_vec ");
			
			*stkhd++ = retain_cell(lex->cdf_neq_vec->value);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[326] 	 both_char : neq_vec ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[326] 	 both_char : neq_vec ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[327] 	1");
	
		CHK(fill_array(arr, dat), cleanup, L"[327] 	1");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[324] noteq{");
	return err;
}

int
cdf_ptr13752(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_neq_vec;
		struct cell_func_box *cdf_both_char;
		struct cell_func_box *cdf_both_numeric;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[325] 	 both_numeric : neq_vec ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_numeric->value)
		CHK(6, cleanup, L"[325] 	 both_numeric : neq_vec ");
	
	*stkhd++ = retain_cell(lex->cdf_both_numeric->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[325] 	 both_numeric : neq_vec ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[325] 	 both_numeric : neq_vec ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[325] 	 both_numeric : neq_vec ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[325] 	 both_numeric : neq_vec ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_neq_vec->value)
				CHK(6, cleanup, L"[325] 	 both_numeric : neq_vec ");
			
			*stkhd++ = retain_cell(lex->cdf_neq_vec->value);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[325] 	 both_numeric : neq_vec ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[325] 	 both_numeric : neq_vec ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[326] 	 both_char : neq_vec ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_char->value)
		CHK(6, cleanup, L"[326] 	 both_char : neq_vec ");
	
	*stkhd++ = retain_cell(lex->cdf_both_char->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[326] 	 both_char : neq_vec ");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[326] 	 both_char : neq_vec ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[326] 	 both_char : neq_vec ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[326] 	 both_char : neq_vec ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!lex->cdf_neq_vec->value)
				CHK(6, cleanup, L"[326] 	 both_char : neq_vec ");
			
			*stkhd++ = retain_cell(lex->cdf_neq_vec->value);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[326] 	 both_char : neq_vec ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[326] 	 both_char : neq_vec ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[327] 	1");
	
		CHK(fill_array(arr, dat), cleanup, L"[327] 	1");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[324] noteq{");
	return err;
}

int
cdf_ptr13753(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[332] mix{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[332] mix{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[332] mix{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[332] mix{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[332] mix{SIGNAL 16}");
	return err;
}

int
cdf_ptr13754(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[332] mix{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[332] mix{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[332] mix{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[332] mix{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[332] mix{SIGNAL 16}");
	return err;
}

int
cdf_ptr13755(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[333] take{()}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[333] take{()}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[333] take{()}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[333] take{()}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[333] take{()}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[333] take{()}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[333] take{()}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[333] take{()}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[333] take{()}");
	return err;
}

int
cdf_ptr13756(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[333] take{()}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[333] take{()}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[333] take{()}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[333] take{()}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[333] take{()}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[333] take{()}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[333] take{()}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[333] take{()}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[333] take{()}");
	return err;
}

int
cdf_ptr13757(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_axis;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct opt_vars {
		struct cell_array *cdf_axis;
	} *opts;

	opts = (struct opt_vars *)cdf_self->opts;

	loc->cdf_axis = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[337] drp{");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[338] 	1 1:SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[338] 	1 1:SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[338] 	1 1:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[338] 	1 1:SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[338] 	1 1:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[338] 	1 1:SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[338] 	1 1:SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[338] 	1 1:SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[338] 	1 1:SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[338] 	1 1:SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[338] 	1 1:SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[338] 	1 1:SIGNAL 16");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[338] 	1 1:SIGNAL 16");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (opts && opts->cdf_axis) {
		*stkhd++ = retain_cell(opts->cdf_axis);
	} else {
		{
			struct cell_array *arr;
		
			enum array_type typ = ARR_SINT;
			unsigned int rnk = 0;
			int16_t dat[] = {0};
		
			CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[339] 	axis0");
		
			CHK(fill_array(arr, dat), cleanup, L"[339] 	axis0");
		
			*stkhd++ = arr;
		}
		
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[340] 	axis0:(+()-)");
	
		CHK(fill_array(arr, dat), cleanup, L"[340] 	axis0:(+()-)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[340] 	axis0:(+()-)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[340] 	axis0:(+()-)");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[340] 	axis0:(+()-)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[340] 	axis0:(+()-)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[340] 	axis0:(+()-)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_sqd)
				CHK(6, cleanup, L"[340] 	axis0:(+()-)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[340] 	axis0:(+()-)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			CHK(2, cleanup, L"[340] 	axis0:(+()-)");
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[340] 	axis0:(+()-)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[341] 	(+()-)[axis]	");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[341] 	(+()-)[axis]	");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[341] 	(+()-)[axis]	");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[341] 	(+()-)[axis]	");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	(+()-)[axis]	");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	CHK(2, cleanup, L"[341] 	(+()-)[axis]	");
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	(+()-)[axis]	");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[337] drp{");
	return err;
}

int
cdf_ptr13758(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_axis;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct opt_vars {
		struct cell_array *cdf_axis;
	} *opts;

	opts = (struct opt_vars *)cdf_self->opts;

	loc->cdf_axis = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[338] 	1 1:SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[338] 	1 1:SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[338] 	1 1:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[338] 	1 1:SIGNAL 16");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[338] 	1 1:SIGNAL 16");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[338] 	1 1:SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[338] 	1 1:SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[338] 	1 1:SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[338] 	1 1:SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[338] 	1 1:SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[338] 	1 1:SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[338] 	1 1:SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[338] 	1 1:SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[338] 	1 1:SIGNAL 16");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[338] 	1 1:SIGNAL 16");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (opts && opts->cdf_axis) {
		*stkhd++ = retain_cell(opts->cdf_axis);
	} else {
		{
			struct cell_array *arr;
		
			enum array_type typ = ARR_SINT;
			unsigned int rnk = 0;
			int16_t dat[] = {0};
		
			CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[339] 	axis0");
		
			CHK(fill_array(arr, dat), cleanup, L"[339] 	axis0");
		
			*stkhd++ = arr;
		}
		
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[340] 	axis0:(+()-)");
	
		CHK(fill_array(arr, dat), cleanup, L"[340] 	axis0:(+()-)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[340] 	axis0:(+()-)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[340] 	axis0:(+()-)");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[340] 	axis0:(+()-)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[340] 	axis0:(+()-)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[340] 	axis0:(+()-)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_sqd)
				CHK(6, cleanup, L"[340] 	axis0:(+()-)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[340] 	axis0:(+()-)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_sub)
				CHK(6, cleanup, L"[340] 	axis0:(+()-)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_sub);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[340] 	axis0:(+()-)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_nqv)
				CHK(6, cleanup, L"[340] 	axis0:(+()-)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[340] 	axis0:(+()-)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[340] 	axis0:(+()-)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_iot)
				CHK(6, cleanup, L"[340] 	axis0:(+()-)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_iot);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[340] 	axis0:(+()-)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[340] 	axis0:(+()-)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[340] 	axis0:(+()-)");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[340] 	axis0:(+()-)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_par)
				CHK(6, cleanup, L"[340] 	axis0:(+()-)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_par);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[340] 	axis0:(+()-)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[340] 	axis0:(+()-)");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[341] 	(+()-)[axis]	");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[341] 	(+()-)[axis]	");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[341] 	(+()-)[axis]	");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[341] 	(+()-)[axis]	");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[341] 	(+()-)[axis]	");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[341] 	(+()-)[axis]	");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[341] 	(+()-)[axis]	");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[341] 	(+()-)[axis]	");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	(+()-)[axis]	");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[341] 	(+()-)[axis]	");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[341] 	(+()-)[axis]	");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	(+()-)[axis]	");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[341] 	(+()-)[axis]	");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[341] 	(+()-)[axis]	");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[341] 	(+()-)[axis]	");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[341] 	(+()-)[axis]	");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	(+()-)[axis]	");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[341] 	(+()-)[axis]	");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[337] drp{");
	return err;
}

int
cdf_ptr13759(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[345] rtf{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[345] rtf{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[345] rtf{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[345] rtf{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[345] rtf{SIGNAL 16}");
	return err;
}

int
cdf_ptr13760(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[345] rtf{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[345] rtf{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[345] rtf{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[345] rtf{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[345] rtf{SIGNAL 16}");
	return err;
}

int
cdf_ptr13761(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[348] reverse_last{(()-1+)}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[348] reverse_last{(()-1+)}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[348] reverse_last{(()-1+)}");
	
		CHK(fill_array(arr, dat), cleanup, L"[348] reverse_last{(()-1+)}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[348] reverse_last{(()-1+)}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[348] reverse_last{(()-1+)}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[348] reverse_last{(()-1+)}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[348] reverse_last{(()-1+)}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[348] reverse_last{(()-1+)}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[348] reverse_last{(()-1+)}");
	return err;
}

int
cdf_ptr13762(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[348] reverse_last{(()-1+)}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[348] reverse_last{(()-1+)}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[348] reverse_last{(()-1+)}");
	
		CHK(fill_array(arr, dat), cleanup, L"[348] reverse_last{(()-1+)}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[348] reverse_last{(()-1+)}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[348] reverse_last{(()-1+)}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[348] reverse_last{(()-1+)}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[348] reverse_last{(()-1+)}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[348] reverse_last{(()-1+)}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[348] reverse_last{(()-1+)}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[348] reverse_last{(()-1+)}");
	return err;
}

int
cdf_ptr13763(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rotate_last{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rotate_last{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[349] rotate_last{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rotate_last{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[349] rotate_last{SIGNAL 16}");
	return err;
}

int
cdf_ptr13764(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rotate_last{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rotate_last{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[349] rotate_last{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rotate_last{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[349] rotate_last{SIGNAL 16}");
	return err;
}

int
cdf_ptr13765(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[353] trn{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[353] trn{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[353] trn{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[353] trn{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[353] trn{SIGNAL 16}");
	return err;
}

int
cdf_ptr13766(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[353] trn{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[353] trn{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[353] trn{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[353] trn{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[353] trn{SIGNAL 16}");
	return err;
}

int
cdf_ptr13767(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[356] gdu{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[356] gdu{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[356] gdu{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[356] gdu{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[356] gdu{SIGNAL 16}");
	return err;
}

int
cdf_ptr13768(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[356] gdu{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[356] gdu{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[356] gdu{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[356] gdu{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[356] gdu{SIGNAL 16}");
	return err;
}

int
cdf_ptr13769(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[359] gdd{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[359] gdd{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[359] gdd{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[359] gdd{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[359] gdd{SIGNAL 16}");
	return err;
}

int
cdf_ptr13770(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[359] gdd{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[359] gdd{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[359] gdd{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[359] gdd{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[359] gdd{SIGNAL 16}");
	return err;
}

int
cdf_ptr13771(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[362] enc{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[362] enc{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[362] enc{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[362] enc{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[362] enc{SIGNAL 16}");
	return err;
}

int
cdf_ptr13772(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[362] enc{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[362] enc{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[362] enc{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[362] enc{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[362] enc{SIGNAL 16}");
	return err;
}

int
cdf_ptr13773(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array_box *cdf_lc;
		struct cell_array_box *cdf_rc;
		struct cell_array *cdf_s;
		struct cell_array *cdf_lv;
		struct cell_array *cdf_rv;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_both_numeric;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	CHK(mk_array_box(&loc->cdf_lc, NULL), cleanup, L"Init mutable variable: loc->cdf_lc");
	CHK(mk_array_box(&loc->cdf_rc, NULL), cleanup, L"Init mutable variable: loc->cdf_rc");
	loc->cdf_s = NULL;
	loc->cdf_lv = NULL;
	loc->cdf_rv = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lc->value);
	loc->cdf_lc->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rc->value);
	loc->cdf_rc->value = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!loc->cdf_lc->value)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_lc->value);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[367] 	s(1),1");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[367] 	s(1),1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[367] 	s(1),1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[367] 	s(1),1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[367] 	s(1),1");
	
		CHK(fill_array(arr, dat), cleanup, L"[367] 	s(1),1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[367] 	s(1),1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[367] 	s(1),1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[367] 	s(1),1");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[367] 	s(1),1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[367] 	s(1),1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[367] 	s(1),1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[367] 	s(1),1");
	
		CHK(fill_array(arr, dat), cleanup, L"[367] 	s(1),1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[367] 	s(1),1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[367] 	s(1),1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[368] 	(0,)0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[368] 	(0,)0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[368] 	(0,)0,:s0");
	
		CHK(fill_array(arr, dat), cleanup, L"[368] 	(0,)0,:s0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[368] 	(0,)0,:s0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[368] 	(0,)0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[368] 	(0,)0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[368] 	(0,)0,:s0");
	
		CHK(fill_array(arr, dat), cleanup, L"[368] 	(0,)0,:s0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[368] 	(0,)0,:s0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[368] 	(0,)0,:s0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[368] 	(0,)0,:s0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[368] 	(0,)0,:s0");
			
				CHK(fill_array(arr, dat), cleanup, L"[368] 	(0,)0,:s0");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[368] 	(0,)0,:s0");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[368] 	(0,)0,:s0");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[368] 	(0,)0,:s0");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_both_numeric->value)
		CHK(6, cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_both_numeric->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13774, cdf_ptr13775, 2), cleanup, 
		    L"[370] 	lv{1lc:rc/  }");
	
		k->fv[0] = retain_cell(loc->cdf_rc);
		k->fv[1] = retain_cell(loc->cdf_lc);
	
		*stkhd++ = k;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[370] 	lv{1lc:rc/  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lv);
	loc->cdf_lv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13776, cdf_ptr13777, 2), cleanup, 
		    L"[371] 	rv{1rc:lc  }");
	
		k->fv[0] = retain_cell(loc->cdf_rc);
		k->fv[1] = retain_cell(loc->cdf_lc);
	
		*stkhd++ = k;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[371] 	rv{1rc:lc  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rv);
	loc->cdf_rv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_lv)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(loc->cdf_lv);
	
	if (!loc->cdf_lv)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(loc->cdf_lv);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
		CHK(fill_array(arr, dat), cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
		CHK(fill_array(arr, dat), cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
		CHK(fill_array(arr, dat), cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_scn)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_scn);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_prim.cdf_dot)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dot);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_rv)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(loc->cdf_rv);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[365] dec{");
	return err;
}

int
cdf_ptr13774(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_lc;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_lc->value)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(lex->cdf_lc->value);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[370] 	lv{1lc:rc/  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[370] 	lv{1lc:rc/  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[370] 	lv{1lc:rc/  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[370] 	lv{1lc:rc/  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_rep)
				CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rep);
			
			if (!lex->cdf_rc->value)
				CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
			
			*stkhd++ = retain_cell(lex->cdf_rc->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[370] 	lv{1lc:rc/  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[370] 	lv{1lc:rc/  }");
	return err;
}

int
cdf_ptr13775(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_lc;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_lc->value)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(lex->cdf_lc->value);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[370] 	lv{1lc:rc/  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[370] 	lv{1lc:rc/  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[370] 	lv{1lc:rc/  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[370] 	lv{1lc:rc/  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_rep)
				CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rep);
			
			if (!lex->cdf_rc->value)
				CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
			
			*stkhd++ = retain_cell(lex->cdf_rc->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[370] 	lv{1lc:rc/  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[370] 	lv{1lc:rc/  }");
	return err;
}

int
cdf_ptr13776(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_lc;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[371] 	rv{1rc:lc  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[371] 	rv{1rc:lc  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[371] 	rv{1rc:lc  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[371] 	rv{1rc:lc  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rpf)
				CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
			
			if (!lex->cdf_lc->value)
				CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
			
			*stkhd++ = retain_cell(lex->cdf_lc->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[371] 	rv{1rc:lc  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[371] 	rv{1rc:lc  }");
	return err;
}

int
cdf_ptr13777(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_lc;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[371] 	rv{1rc:lc  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[371] 	rv{1rc:lc  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[371] 	rv{1rc:lc  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[371] 	rv{1rc:lc  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rpf)
				CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
			
			if (!lex->cdf_lc->value)
				CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
			
			*stkhd++ = retain_cell(lex->cdf_lc->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[371] 	rv{1rc:lc  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[371] 	rv{1rc:lc  }");
	return err;
}

int
cdf_ptr13778(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array_box *cdf_lc;
		struct cell_array_box *cdf_rc;
		struct cell_array *cdf_s;
		struct cell_array *cdf_lv;
		struct cell_array *cdf_rv;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_both_numeric;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	CHK(mk_array_box(&loc->cdf_lc, NULL), cleanup, L"Init mutable variable: loc->cdf_lc");
	CHK(mk_array_box(&loc->cdf_rc, NULL), cleanup, L"Init mutable variable: loc->cdf_rc");
	loc->cdf_s = NULL;
	loc->cdf_lv = NULL;
	loc->cdf_rv = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lc->value);
	loc->cdf_lc->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rc->value);
	loc->cdf_rc->value = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!loc->cdf_lc->value)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->cdf_lc->value);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[366] 	(0)(0)(1lc)(1rc)(rc)lc1:SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[367] 	s(1),1");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[367] 	s(1),1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[367] 	s(1),1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[367] 	s(1),1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[367] 	s(1),1");
	
		CHK(fill_array(arr, dat), cleanup, L"[367] 	s(1),1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[367] 	s(1),1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[367] 	s(1),1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[367] 	s(1),1");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[367] 	s(1),1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[367] 	s(1),1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[367] 	s(1),1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[367] 	s(1),1");
	
		CHK(fill_array(arr, dat), cleanup, L"[367] 	s(1),1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[367] 	s(1),1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[367] 	s(1),1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[368] 	(0,)0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[368] 	(0,)0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[368] 	(0,)0,:s0");
	
		CHK(fill_array(arr, dat), cleanup, L"[368] 	(0,)0,:s0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[368] 	(0,)0,:s0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[368] 	(0,)0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[368] 	(0,)0,:s0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[368] 	(0,)0,:s0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[368] 	(0,)0,:s0");
	
		CHK(fill_array(arr, dat), cleanup, L"[368] 	(0,)0,:s0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[368] 	(0,)0,:s0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[368] 	(0,)0,:s0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[368] 	(0,)0,:s0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[368] 	(0,)0,:s0");
			
				CHK(fill_array(arr, dat), cleanup, L"[368] 	(0,)0,:s0");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[368] 	(0,)0,:s0");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_s)
				CHK(6, cleanup, L"[368] 	(0,)0,:s0");
			
			*stkhd++ = retain_cell(loc->cdf_s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[368] 	(0,)0,:s0");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_both_numeric->value)
		CHK(6, cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_both_numeric->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[369] 	~(squeeze )both_numeric squeeze :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13779, cdf_ptr13780, 2), cleanup, 
		    L"[370] 	lv{1lc:rc/  }");
	
		k->fv[0] = retain_cell(loc->cdf_rc);
		k->fv[1] = retain_cell(loc->cdf_lc);
	
		*stkhd++ = k;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[370] 	lv{1lc:rc/  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_lv);
	loc->cdf_lv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13781, cdf_ptr13782, 2), cleanup, 
		    L"[371] 	rv{1rc:lc  }");
	
		k->fv[0] = retain_cell(loc->cdf_rc);
		k->fv[1] = retain_cell(loc->cdf_lc);
	
		*stkhd++ = k;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[371] 	rv{1rc:lc  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rv);
	loc->cdf_rv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_lv)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(loc->cdf_lv);
	
	if (!loc->cdf_lv)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(loc->cdf_lv);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
		CHK(fill_array(arr, dat), cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
		CHK(fill_array(arr, dat), cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
		CHK(fill_array(arr, dat), cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_scn)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_scn);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_com)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_com);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_prim.cdf_dot)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dot);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_rv)
		CHK(6, cleanup, L"[372] 	rv+.\\1,1[1+lv]lv");
	
	*stkhd++ = retain_cell(loc->cdf_rv);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	rv+.\\1,1[1+lv]lv");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[365] dec{");
	return err;
}

int
cdf_ptr13779(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_lc;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_lc->value)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(lex->cdf_lc->value);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[370] 	lv{1lc:rc/  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[370] 	lv{1lc:rc/  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[370] 	lv{1lc:rc/  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[370] 	lv{1lc:rc/  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_rep)
				CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rep);
			
			if (!lex->cdf_rc->value)
				CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
			
			*stkhd++ = retain_cell(lex->cdf_rc->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[370] 	lv{1lc:rc/  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[370] 	lv{1lc:rc/  }");
	return err;
}

int
cdf_ptr13780(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_lc;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_lc->value)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(lex->cdf_lc->value);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[370] 	lv{1lc:rc/  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[370] 	lv{1lc:rc/  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[370] 	lv{1lc:rc/  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[370] 	lv{1lc:rc/  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alpha)
				CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			if (!cdf_prim.cdf_rep)
				CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rep);
			
			if (!lex->cdf_rc->value)
				CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
			
			*stkhd++ = retain_cell(lex->cdf_rc->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[370] 	lv{1lc:rc/  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[370] 	lv{1lc:rc/  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[370] 	lv{1lc:rc/  }");
	return err;
}

int
cdf_ptr13781(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_lc;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[371] 	rv{1rc:lc  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[371] 	rv{1rc:lc  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[371] 	rv{1rc:lc  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[371] 	rv{1rc:lc  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rpf)
				CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
			
			if (!lex->cdf_lc->value)
				CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
			
			*stkhd++ = retain_cell(lex->cdf_lc->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[371] 	rv{1rc:lc  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[371] 	rv{1rc:lc  }");
	return err;
}

int
cdf_ptr13782(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_lc;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[371] 	rv{1rc:lc  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[371] 	rv{1rc:lc  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[371] 	rv{1rc:lc  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[371] 	rv{1rc:lc  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rpf)
				CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
			
			if (!lex->cdf_lc->value)
				CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
			
			*stkhd++ = retain_cell(lex->cdf_lc->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[371] 	rv{1rc:lc  }");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[371] 	rv{1rc:lc  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[371] 	rv{1rc:lc  }");
	return err;
}

int
cdf_ptr13783(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[376] mem{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[376] mem{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[376] mem{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[376] mem{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[376] mem{SIGNAL 16}");
	return err;
}

int
cdf_ptr13784(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[376] mem{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[376] mem{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[376] mem{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[376] mem{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[376] mem{SIGNAL 16}");
	return err;
}

int
cdf_ptr13785(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[379] fnd{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[379] fnd{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[379] fnd{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[379] fnd{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[379] fnd{SIGNAL 16}");
	return err;
}

int
cdf_ptr13786(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[379] fnd{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[379] fnd{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[379] fnd{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[379] fnd{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[379] fnd{SIGNAL 16}");
	return err;
}

int
cdf_ptr13787(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[382] unq{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[382] unq{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[382] unq{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[382] unq{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[382] unq{SIGNAL 16}");
	return err;
}

int
cdf_ptr13788(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[382] unq{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[382] unq{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[382] unq{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[382] unq{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[382] unq{SIGNAL 16}");
	return err;
}

int
cdf_ptr13789(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[385] int{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[385] int{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[385] int{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[385] int{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[385] int{SIGNAL 16}");
	return err;
}

int
cdf_ptr13790(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[385] int{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[385] int{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[385] int{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[385] int{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[385] int{SIGNAL 16}");
	return err;
}

int
cdf_ptr13791(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array_box *cdf_d;
		struct cell_array *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_both_integer;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	CHK(mk_array_box(&loc->cdf_d, NULL), cleanup, L"Init mutable variable: loc->cdf_d");
	loc->cdf_s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[390] 	~ both_integer :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_integer->value)
		CHK(6, cleanup, L"[390] 	~ both_integer :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_both_integer->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[390] 	~ both_integer :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[390] 	~ both_integer :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[390] 	~ both_integer :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[390] 	~ both_integer :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[390] 	~ both_integer :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[390] 	~ both_integer :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[390] 	~ both_integer :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[390] 	~ both_integer :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[390] 	~ both_integer :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		CHK(fill_array(arr, dat), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		CHK(fill_array(arr, dat), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_gth)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_gth);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
			
				CHK(fill_array(arr, dat), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		CHK(fill_array(arr, dat), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_d->value);
	loc->cdf_d->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rol)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rol);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13792, cdf_ptr13793, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		k->fv[0] = retain_cell(loc->cdf_d);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[388] deal{");
	return err;
}

int
cdf_ptr13792(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_d;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_d->value)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(lex->cdf_d->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = lex->cdf_d;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	return err;
}

int
cdf_ptr13793(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_d;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_d->value)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(lex->cdf_d->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = lex->cdf_d;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	return err;
}

int
cdf_ptr13794(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array_box *cdf_d;
		struct cell_array *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_both_integer;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	CHK(mk_array_box(&loc->cdf_d, NULL), cleanup, L"Init mutable variable: loc->cdf_d");
	loc->cdf_s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[389] 	(0squeeze )(0squeeze ):SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[390] 	~ both_integer :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_both_integer->value)
		CHK(6, cleanup, L"[390] 	~ both_integer :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_both_integer->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[390] 	~ both_integer :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[390] 	~ both_integer :SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[390] 	~ both_integer :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[390] 	~ both_integer :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[390] 	~ both_integer :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[390] 	~ both_integer :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[390] 	~ both_integer :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[390] 	~ both_integer :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[390] 	~ both_integer :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		CHK(fill_array(arr, dat), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		CHK(fill_array(arr, dat), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_gth)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_gth);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
			
				CHK(fill_array(arr, dat), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		CHK(fill_array(arr, dat), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[391] 	(>)(<0)<0:SIGNAL 11  0:");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_d->value);
	loc->cdf_d->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rol)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rol);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13795, cdf_ptr13796, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		k->fv[0] = retain_cell(loc->cdf_d);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[388] deal{");
	return err;
}

int
cdf_ptr13795(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_d;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_d->value)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(lex->cdf_d->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = lex->cdf_d;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	return err;
}

int
cdf_ptr13796(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_d;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_d->value)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(lex->cdf_d->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = lex->cdf_d;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[392] 	d  s{d[ ]d[ ]}s+?-s");
	return err;
}

int
cdf_ptr13797(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct {
		struct cell_array *cdf_rnd;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_any;
		struct cell_func_box *cdf_is_integer;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_rnd = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[395] 	~is_integer squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[395] 	~is_integer squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[395] 	~is_integer squeeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[395] 	~is_integer squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[395] 	~is_integer squeeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[395] 	~is_integer squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[395] 	~is_integer squeeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[395] 	~is_integer squeeze :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[395] 	~is_integer squeeze :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[395] 	~is_integer squeeze :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[395] 	~is_integer squeeze :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[395] 	~is_integer squeeze :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[396] 	0,:()");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[396] 	0,:()");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[396] 	0,:()");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[396] 	0,:()");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[396] 	0,:()");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[396] 	0,:()");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[396] 	0,:()");
	
		CHK(fill_array(arr, dat), cleanup, L"[396] 	0,:()");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[396] 	0,:()");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[396] 	0,:()");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[396] 	0,:()");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[396] 	0,:()");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[396] 	0,:()");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[396] 	0,:()");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[396] 	0,:()");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[396] 	0,:()");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[396] 	0,:()");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[397] 	any <0:SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[397] 	any <0:SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[397] 	any <0:SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[397] 	any <0:SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[397] 	any <0:SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_any->value)
		CHK(6, cleanup, L"[397] 	any <0:SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_any->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[397] 	any <0:SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[397] 	any <0:SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[397] 	any <0:SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[397] 	any <0:SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[397] 	any <0:SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[397] 	any <0:SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_roll_ibeam)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_roll_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rnd);
	loc->cdf_rnd = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_min)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_rnd)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(loc->cdf_rnd);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[394] roll{");
	return err;
}

int
cdf_ptr13798(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *cdf_rnd;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_any;
		struct cell_func_box *cdf_is_integer;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	loc->cdf_rnd = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[395] 	~is_integer squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[395] 	~is_integer squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[395] 	~is_integer squeeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[395] 	~is_integer squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[395] 	~is_integer squeeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_not)
		CHK(6, cleanup, L"[395] 	~is_integer squeeze :SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[395] 	~is_integer squeeze :SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[395] 	~is_integer squeeze :SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[395] 	~is_integer squeeze :SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[395] 	~is_integer squeeze :SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[395] 	~is_integer squeeze :SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[395] 	~is_integer squeeze :SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[396] 	0,:()");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[396] 	0,:()");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[396] 	0,:()");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[396] 	0,:()");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[396] 	0,:()");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[396] 	0,:()");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[396] 	0,:()");
	
		CHK(fill_array(arr, dat), cleanup, L"[396] 	0,:()");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[396] 	0,:()");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[396] 	0,:()");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[396] 	0,:()");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[396] 	0,:()");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[396] 	0,:()");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[396] 	0,:()");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[396] 	0,:()");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[396] 	0,:()");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[396] 	0,:()");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[397] 	any <0:SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[397] 	any <0:SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[397] 	any <0:SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[397] 	any <0:SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[397] 	any <0:SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_any->value)
		CHK(6, cleanup, L"[397] 	any <0:SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->cdf_any->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[397] 	any <0:SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[397] 	any <0:SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[397] 	any <0:SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[397] 	any <0:SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[397] 	any <0:SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[397] 	any <0:SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_roll_ibeam)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_roll_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rnd);
	loc->cdf_rnd = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_min)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		CHK(fill_array(arr, dat), cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!loc->cdf_rnd)
		CHK(6, cleanup, L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
	*stkhd++ = retain_cell(loc->cdf_rnd);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[398] 	(rnd=0)+rnd()'roll_ibeam' ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[394] roll{");
	return err;
}

int
cdf_ptr13799(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[403] mdv{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[403] mdv{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[403] mdv{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[403] mdv{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[403] mdv{SIGNAL 16}");
	return err;
}

int
cdf_ptr13800(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[403] mdv{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[403] mdv{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[403] mdv{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[403] mdv{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[403] mdv{SIGNAL 16}");
	return err;
}

int
cdf_ptr13801(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[406] com{2=NC'':      }");
	
		arr->shape[0] = 1;
	
		CHK(fill_array(arr, dat), cleanup, L"[406] com{2=NC'':      }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[406] com{2=NC'':      }");
	
		CHK(fill_array(arr, dat), cleanup, L"[406] com{2=NC'':      }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[406] com{2=NC'':      }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[406] com{2=NC'':      }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[406] com{2=NC'':      }");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[406] com{2=NC'':      }");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[406] com{2=NC'':      }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[406] com{2=NC'':      }");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[406] com{2=NC'':      }");
	return err;
}

int
cdf_ptr13802(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[406] com{2=NC'':      }");
	
		arr->shape[0] = 1;
	
		CHK(fill_array(arr, dat), cleanup, L"[406] com{2=NC'':      }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[406] com{2=NC'':      }");
	
		CHK(fill_array(arr, dat), cleanup, L"[406] com{2=NC'':      }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[406] com{2=NC'':      }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[406] com{2=NC'':      }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[406] com{2=NC'':      }");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[406] com{2=NC'':      }");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[406] com{2=NC'':      }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[406] com{2=NC'':      }");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[406] com{2=NC'':      }");
	return err;
}

int
cdf_ptr13803(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[406] com{2=NC'':      }");
	
		arr->shape[0] = 1;
	
		CHK(fill_array(arr, dat), cleanup, L"[406] com{2=NC'':      }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[406] com{2=NC'':      }");
	
		CHK(fill_array(arr, dat), cleanup, L"[406] com{2=NC'':      }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[406] com{2=NC'':      }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[406] com{2=NC'':      }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[406] com{2=NC'':      }");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[406] com{2=NC'':      }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[406] com{2=NC'':      }");
	return err;
}

int
cdf_ptr13804(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[406] com{2=NC'':      }");
	
		arr->shape[0] = 1;
	
		CHK(fill_array(arr, dat), cleanup, L"[406] com{2=NC'':      }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eql)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[406] com{2=NC'':      }");
	
		CHK(fill_array(arr, dat), cleanup, L"[406] com{2=NC'':      }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[406] com{2=NC'':      }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[406] com{2=NC'':      }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[406] com{2=NC'':      }");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[406] com{2=NC'':      }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[406] com{2=NC'':      }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[406] com{2=NC'':      }");
	return err;
}

int
cdf_ptr13805(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_veach;
		struct cell_func_box *cdf_chk_scl;
		struct cell_func_box *cdf_max_shp;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_chk_scl->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_chk_scl->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_max_shp->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_max_shp->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_veach->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_veach->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	return err;
}

int
cdf_ptr13806(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_veach;
		struct cell_func_box *cdf_chk_scl;
		struct cell_func_box *cdf_max_shp;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_chk_scl->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_chk_scl->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_max_shp->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_max_shp->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_veach->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_veach->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	return err;
}

int
cdf_ptr13807(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_veach;
		struct cell_func_box *cdf_chk_scl;
		struct cell_func_box *cdf_max_shp;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_chk_scl->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_chk_scl->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_max_shp->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_max_shp->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_veach->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_veach->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	return err;
}

int
cdf_ptr13808(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_veach;
		struct cell_func_box *cdf_chk_scl;
		struct cell_func_box *cdf_max_shp;
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_chk_scl->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_chk_scl->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_max_shp->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_max_shp->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_veach->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_veach->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[409] map{   chk_scl :  s max_shp   ssqueeze   veach }");
	return err;
}

int
cdf_ptr13809(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct lex_vars {
		struct cell_doper_box *cdf_eq;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[413] 	 eq + :0");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[413] 	 eq + :0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[413] 	 eq + :0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[413] 	 eq + :0");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[413] 	 eq + :0");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_fam, op->fptr_fad, x, y), cleanup,
		    L"[413] 	 eq + :0");
	
		release_array(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[413] 	 eq + :0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[413] 	 eq + :0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[413] 	 eq + :0");
			
				CHK(fill_array(arr, dat), cleanup, L"[413] 	 eq + :0");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[414] 	 eq  :1");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[414] 	 eq  :1");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[414] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[414] 	 eq  :1");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[414] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_fam, op->fptr_fad, x, y), cleanup,
		    L"[414] 	 eq  :1");
	
		release_array(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[414] 	 eq  :1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[414] 	 eq  :1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[414] 	 eq  :1");
			
				CHK(fill_array(arr, dat), cleanup, L"[414] 	 eq  :1");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[415] 	 eq  :0");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[415] 	 eq  :0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[415] 	 eq  :0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[415] 	 eq  :0");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[415] 	 eq  :0");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_fam, op->fptr_fad, x, y), cleanup,
		    L"[415] 	 eq  :0");
	
		release_array(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[415] 	 eq  :0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[415] 	 eq  :0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[415] 	 eq  :0");
			
				CHK(fill_array(arr, dat), cleanup, L"[415] 	 eq  :0");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[416] 	 eq  :1");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[416] 	 eq  :1");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[416] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[416] 	 eq  :1");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[416] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_fam, op->fptr_fad, x, y), cleanup,
		    L"[416] 	 eq  :1");
	
		release_array(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[416] 	 eq  :1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[416] 	 eq  :1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[416] 	 eq  :1");
			
				CHK(fill_array(arr, dat), cleanup, L"[416] 	 eq  :1");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[417] 	SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[417] 	SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[417] 	SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[417] 	SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[412] identity{");
	return err;
}

int
cdf_ptr13810(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct lex_vars {
		struct cell_doper_box *cdf_eq;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[413] 	 eq + :0");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[413] 	 eq + :0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[413] 	 eq + :0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[413] 	 eq + :0");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[413] 	 eq + :0");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_fam, op->fptr_fad, x, y), cleanup,
		    L"[413] 	 eq + :0");
	
		release_array(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[413] 	 eq + :0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[413] 	 eq + :0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[413] 	 eq + :0");
			
				CHK(fill_array(arr, dat), cleanup, L"[413] 	 eq + :0");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[414] 	 eq  :1");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[414] 	 eq  :1");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[414] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[414] 	 eq  :1");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[414] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_fam, op->fptr_fad, x, y), cleanup,
		    L"[414] 	 eq  :1");
	
		release_array(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[414] 	 eq  :1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[414] 	 eq  :1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[414] 	 eq  :1");
			
				CHK(fill_array(arr, dat), cleanup, L"[414] 	 eq  :1");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[415] 	 eq  :0");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[415] 	 eq  :0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[415] 	 eq  :0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[415] 	 eq  :0");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[415] 	 eq  :0");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_fam, op->fptr_fad, x, y), cleanup,
		    L"[415] 	 eq  :0");
	
		release_array(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[415] 	 eq  :0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[415] 	 eq  :0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[415] 	 eq  :0");
			
				CHK(fill_array(arr, dat), cleanup, L"[415] 	 eq  :0");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[416] 	 eq  :1");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[416] 	 eq  :1");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[416] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[416] 	 eq  :1");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[416] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_fam, op->fptr_fad, x, y), cleanup,
		    L"[416] 	 eq  :1");
	
		release_array(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[416] 	 eq  :1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[416] 	 eq  :1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[416] 	 eq  :1");
			
				CHK(fill_array(arr, dat), cleanup, L"[416] 	 eq  :1");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[417] 	SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[417] 	SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[417] 	SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[417] 	SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[412] identity{");
	return err;
}

int
cdf_ptr13811(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct lex_vars {
		struct cell_doper_box *cdf_eq;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[413] 	 eq + :0");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[413] 	 eq + :0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[413] 	 eq + :0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[413] 	 eq + :0");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[413] 	 eq + :0");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[413] 	 eq + :0");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[413] 	 eq + :0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[413] 	 eq + :0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[413] 	 eq + :0");
			
				CHK(fill_array(arr, dat), cleanup, L"[413] 	 eq + :0");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[414] 	 eq  :1");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[414] 	 eq  :1");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[414] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[414] 	 eq  :1");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[414] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[414] 	 eq  :1");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[414] 	 eq  :1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[414] 	 eq  :1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[414] 	 eq  :1");
			
				CHK(fill_array(arr, dat), cleanup, L"[414] 	 eq  :1");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[415] 	 eq  :0");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[415] 	 eq  :0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[415] 	 eq  :0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[415] 	 eq  :0");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[415] 	 eq  :0");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[415] 	 eq  :0");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[415] 	 eq  :0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[415] 	 eq  :0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[415] 	 eq  :0");
			
				CHK(fill_array(arr, dat), cleanup, L"[415] 	 eq  :0");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[416] 	 eq  :1");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[416] 	 eq  :1");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[416] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[416] 	 eq  :1");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[416] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[416] 	 eq  :1");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[416] 	 eq  :1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[416] 	 eq  :1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[416] 	 eq  :1");
			
				CHK(fill_array(arr, dat), cleanup, L"[416] 	 eq  :1");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[417] 	SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[417] 	SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[417] 	SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[417] 	SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[412] identity{");
	return err;
}

int
cdf_ptr13812(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct lex_vars {
		struct cell_doper_box *cdf_eq;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[413] 	 eq + :0");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[413] 	 eq + :0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[413] 	 eq + :0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[413] 	 eq + :0");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[413] 	 eq + :0");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[413] 	 eq + :0");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[413] 	 eq + :0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[413] 	 eq + :0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[413] 	 eq + :0");
			
				CHK(fill_array(arr, dat), cleanup, L"[413] 	 eq + :0");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[414] 	 eq  :1");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[414] 	 eq  :1");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[414] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[414] 	 eq  :1");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[414] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[414] 	 eq  :1");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[414] 	 eq  :1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[414] 	 eq  :1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[414] 	 eq  :1");
			
				CHK(fill_array(arr, dat), cleanup, L"[414] 	 eq  :1");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[415] 	 eq  :0");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[415] 	 eq  :0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_lor)
		CHK(6, cleanup, L"[415] 	 eq  :0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lor);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[415] 	 eq  :0");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[415] 	 eq  :0");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[415] 	 eq  :0");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[415] 	 eq  :0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[415] 	 eq  :0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[415] 	 eq  :0");
			
				CHK(fill_array(arr, dat), cleanup, L"[415] 	 eq  :0");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[416] 	 eq  :1");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[416] 	 eq  :1");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_and)
		CHK(6, cleanup, L"[416] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_and);
	
	if (!lex->cdf_eq->value)
		CHK(6, cleanup, L"[416] 	 eq  :1");
	
	*stkhd++ = retain_cell(lex->cdf_eq->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[416] 	 eq  :1");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[416] 	 eq  :1");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[416] 	 eq  :1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[416] 	 eq  :1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[416] 	 eq  :1");
			
				CHK(fill_array(arr, dat), cleanup, L"[416] 	 eq  :1");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[417] 	SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[417] 	SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[417] 	SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[417] 	SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[412] identity{");
	return err;
}

int
cdf_ptr13813(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_axis;
		struct cell_array *cdf_s;
		struct cell_array *cdf_c;
		struct cell_array *cdf_zs;
		struct cell_func_box *cdf_op;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_identity;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	loc->cdf_s = NULL;
	loc->cdf_c = NULL;
	loc->cdf_zs = NULL;
	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[419] reduce{axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_self)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_c);
	loc->cdf_c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_zs);
	loc->cdf_zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				*stkhd++ = arr;
			}
			
			if (!lex->cdf_identity->value)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(lex->cdf_identity->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13814, cdf_ptr13815, 2), cleanup, 
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		k->fv[0] = retain_cell(loc->cdf_z);
		k->fv[1] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[419] reduce{axis");
	return err;
}

int
cdf_ptr13814(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13815(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13816(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_axis;
		struct cell_array *cdf_s;
		struct cell_array *cdf_c;
		struct cell_array *cdf_zs;
		struct cell_func_box *cdf_op;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_identity;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	loc->cdf_s = NULL;
	loc->cdf_c = NULL;
	loc->cdf_zs = NULL;
	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[419] reduce{axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_self)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_c);
	loc->cdf_c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_zs);
	loc->cdf_zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				*stkhd++ = arr;
			}
			
			if (!lex->cdf_identity->value)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(lex->cdf_identity->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13817, cdf_ptr13818, 2), cleanup, 
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		k->fv[0] = retain_cell(loc->cdf_z);
		k->fv[1] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[419] reduce{axis");
	return err;
}

int
cdf_ptr13817(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13818(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13819(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_axis;
		struct cell_array *cdf_s;
		struct cell_array *cdf_c;
		struct cell_array *cdf_zs;
		struct cell_func_box *cdf_op;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_identity;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	loc->cdf_s = NULL;
	loc->cdf_c = NULL;
	loc->cdf_zs = NULL;
	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[419] reduce{axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_self)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_c);
	loc->cdf_c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_zs);
	loc->cdf_zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				*stkhd++ = arr;
			}
			
			if (!lex->cdf_identity->value)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(lex->cdf_identity->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13820, cdf_ptr13821, 2), cleanup, 
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		k->fv[0] = retain_cell(loc->cdf_z);
		k->fv[1] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[419] reduce{axis");
	return err;
}

int
cdf_ptr13820(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13821(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13822(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_axis;
		struct cell_array *cdf_s;
		struct cell_array *cdf_c;
		struct cell_array *cdf_zs;
		struct cell_func_box *cdf_op;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_identity;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	loc->cdf_s = NULL;
	loc->cdf_c = NULL;
	loc->cdf_zs = NULL;
	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[419] reduce{axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_self)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_c);
	loc->cdf_c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_zs);
	loc->cdf_zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				*stkhd++ = arr;
			}
			
			if (!lex->cdf_identity->value)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(lex->cdf_identity->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13823, cdf_ptr13824, 2), cleanup, 
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		k->fv[0] = retain_cell(loc->cdf_z);
		k->fv[1] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[419] reduce{axis");
	return err;
}

int
cdf_ptr13823(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13824(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13825(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func *cdf_axis;
		struct cell_array *cdf_s;
		struct cell_array *cdf_c;
		struct cell_array *cdf_zs;
		struct cell_func_box *cdf_op;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_identity;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	loc->cdf_s = NULL;
	loc->cdf_c = NULL;
	loc->cdf_zs = NULL;
	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[419] reduce{axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_self)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_c);
	loc->cdf_c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_zs);
	loc->cdf_zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				*stkhd++ = arr;
			}
			
			if (!lex->cdf_identity->value)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(lex->cdf_identity->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13826, cdf_ptr13827, 2), cleanup, 
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		k->fv[0] = retain_cell(loc->cdf_z);
		k->fv[1] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[419] reduce{axis");
	return err;
}

int
cdf_ptr13826(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13827(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13828(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func *cdf_axis;
		struct cell_array *cdf_s;
		struct cell_array *cdf_c;
		struct cell_array *cdf_zs;
		struct cell_func_box *cdf_op;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_identity;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	loc->cdf_s = NULL;
	loc->cdf_c = NULL;
	loc->cdf_zs = NULL;
	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[419] reduce{axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_self)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_c);
	loc->cdf_c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_zs);
	loc->cdf_zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				*stkhd++ = arr;
			}
			
			if (!lex->cdf_identity->value)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(lex->cdf_identity->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13829, cdf_ptr13830, 2), cleanup, 
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		k->fv[0] = retain_cell(loc->cdf_z);
		k->fv[1] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[419] reduce{axis");
	return err;
}

int
cdf_ptr13829(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13830(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13831(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func *cdf_axis;
		struct cell_array *cdf_s;
		struct cell_array *cdf_c;
		struct cell_array *cdf_zs;
		struct cell_func_box *cdf_op;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_identity;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	loc->cdf_s = NULL;
	loc->cdf_c = NULL;
	loc->cdf_zs = NULL;
	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[419] reduce{axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_self)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_c);
	loc->cdf_c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_zs);
	loc->cdf_zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				*stkhd++ = arr;
			}
			
			if (!lex->cdf_identity->value)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(lex->cdf_identity->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13832, cdf_ptr13833, 2), cleanup, 
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		k->fv[0] = retain_cell(loc->cdf_z);
		k->fv[1] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[419] reduce{axis");
	return err;
}

int
cdf_ptr13832(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13833(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13834(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func *cdf_axis;
		struct cell_array *cdf_s;
		struct cell_array *cdf_c;
		struct cell_array *cdf_zs;
		struct cell_func_box *cdf_op;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *cdf_identity;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	loc->cdf_s = NULL;
	loc->cdf_c = NULL;
	loc->cdf_zs = NULL;
	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[419] reduce{axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_self)
				CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
			
			*stkhd++ = retain_cell(cdf_self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[420] 	0:,  s  cs  zs1s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_s);
	loc->cdf_s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_dis)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_c);
	loc->cdf_c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_s)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(loc->cdf_s);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[420] 	0:,  s  cs  zs1s");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		CHK(fill_array(arr, dat), cleanup, L"[420] 	0:,  s  cs  zs1s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[420] 	0:,  s  cs  zs1s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_zs);
	loc->cdf_zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
				*stkhd++ = arr;
			}
			
			if (!lex->cdf_identity->value)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(lex->cdf_identity->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		CHK(fill_array(arr, dat), cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[421] 	0c:zs identity   1c:zs  op");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!loc->cdf_zs)
				CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
			
			*stkhd++ = retain_cell(loc->cdf_zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[421] 	0c:zs identity   1c:zs  op");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[421] 	0c:zs identity   1c:zs  op");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[421] 	0c:zs identity   1c:zs  op");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13835, cdf_ptr13836, 2), cleanup, 
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		k->fv[0] = retain_cell(loc->cdf_z);
		k->fv[1] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[419] reduce{axis");
	return err;
}

int
cdf_ptr13835(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13836(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[422] 	z(c-1){z()op z}z(c-1)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[422] 	z(c-1){z()op z}z(c-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[422] 	z(c-1){z()op z}z(c-1)");
	return err;
}

int
cdf_ptr13837(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func_box *cdf_op;
		struct cell_array *cdf_axis;
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_axis = NULL;
	CHK(mk_array_box(&loc->cdf_rc, NULL), cleanup, L"Init mutable variable: loc->cdf_rc");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[424] nwreduce{op  axis");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rc->value);
	loc->cdf_rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array_box *bx = loc->cdf_rc;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13838, cdf_ptr13839, 3), cleanup, 
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		k->fv[0] = retain_cell(loc->cdf_rc);
		k->fv[1] = retain_cell(loc->cdf_z);
		k->fv[2] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[424] nwreduce{op  axis");
	return err;
}

int
cdf_ptr13838(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13839(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13840(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func_box *cdf_op;
		struct cell_array *cdf_axis;
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_axis = NULL;
	CHK(mk_array_box(&loc->cdf_rc, NULL), cleanup, L"Init mutable variable: loc->cdf_rc");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[424] nwreduce{op  axis");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rc->value);
	loc->cdf_rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array_box *bx = loc->cdf_rc;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13841, cdf_ptr13842, 3), cleanup, 
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		k->fv[0] = retain_cell(loc->cdf_rc);
		k->fv[1] = retain_cell(loc->cdf_z);
		k->fv[2] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[424] nwreduce{op  axis");
	return err;
}

int
cdf_ptr13841(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13842(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13843(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func_box *cdf_op;
		struct cell_array *cdf_axis;
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_axis = NULL;
	CHK(mk_array_box(&loc->cdf_rc, NULL), cleanup, L"Init mutable variable: loc->cdf_rc");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[424] nwreduce{op  axis");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rc->value);
	loc->cdf_rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array_box *bx = loc->cdf_rc;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13844, cdf_ptr13845, 3), cleanup, 
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		k->fv[0] = retain_cell(loc->cdf_rc);
		k->fv[1] = retain_cell(loc->cdf_z);
		k->fv[2] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[424] nwreduce{op  axis");
	return err;
}

int
cdf_ptr13844(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13845(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13846(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func_box *cdf_op;
		struct cell_array *cdf_axis;
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_axis = NULL;
	CHK(mk_array_box(&loc->cdf_rc, NULL), cleanup, L"Init mutable variable: loc->cdf_rc");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[424] nwreduce{op  axis");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rc->value);
	loc->cdf_rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array_box *bx = loc->cdf_rc;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13847, cdf_ptr13848, 3), cleanup, 
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		k->fv[0] = retain_cell(loc->cdf_rc);
		k->fv[1] = retain_cell(loc->cdf_z);
		k->fv[2] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[424] nwreduce{op  axis");
	return err;
}

int
cdf_ptr13847(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13848(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13849(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func_box *cdf_op;
		struct cell_func *cdf_axis;
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_axis = NULL;
	CHK(mk_array_box(&loc->cdf_rc, NULL), cleanup, L"Init mutable variable: loc->cdf_rc");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[424] nwreduce{op  axis");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rc->value);
	loc->cdf_rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array_box *bx = loc->cdf_rc;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13850, cdf_ptr13851, 3), cleanup, 
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		k->fv[0] = retain_cell(loc->cdf_rc);
		k->fv[1] = retain_cell(loc->cdf_z);
		k->fv[2] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[424] nwreduce{op  axis");
	return err;
}

int
cdf_ptr13850(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13851(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13852(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func_box *cdf_op;
		struct cell_func *cdf_axis;
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_axis = NULL;
	CHK(mk_array_box(&loc->cdf_rc, NULL), cleanup, L"Init mutable variable: loc->cdf_rc");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[424] nwreduce{op  axis");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rc->value);
	loc->cdf_rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array_box *bx = loc->cdf_rc;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13853, cdf_ptr13854, 3), cleanup, 
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		k->fv[0] = retain_cell(loc->cdf_rc);
		k->fv[1] = retain_cell(loc->cdf_z);
		k->fv[2] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[424] nwreduce{op  axis");
	return err;
}

int
cdf_ptr13853(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13854(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13855(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func_box *cdf_op;
		struct cell_func *cdf_axis;
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_axis = NULL;
	CHK(mk_array_box(&loc->cdf_rc, NULL), cleanup, L"Init mutable variable: loc->cdf_rc");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[424] nwreduce{op  axis");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rc->value);
	loc->cdf_rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array_box *bx = loc->cdf_rc;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13856, cdf_ptr13857, 3), cleanup, 
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		k->fv[0] = retain_cell(loc->cdf_rc);
		k->fv[1] = retain_cell(loc->cdf_z);
		k->fv[2] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[424] nwreduce{op  axis");
	return err;
}

int
cdf_ptr13856(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13857(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13858(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func_box *cdf_op;
		struct cell_func *cdf_axis;
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_is_integer;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_func_box(&loc->cdf_op, NULL), cleanup, L"Init mutable variable: loc->cdf_op");
	loc->cdf_axis = NULL;
	CHK(mk_array_box(&loc->cdf_rc, NULL), cleanup, L"Init mutable variable: loc->cdf_rc");
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[424] nwreduce{op  axis");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_op->value);
	loc->cdf_op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[424] nwreduce{op  axis");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!lex->cdf_is_integer->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(lex->cdf_is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_rc->value);
	loc->cdf_rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				CHK(fill_array(arr, dat), cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!loc->cdf_rc->value)
		CHK(6, cleanup, L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
	*stkhd++ = retain_cell(loc->cdf_rc->value);
	
	{
		struct cell_array_box *bx = loc->cdf_rc;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[425] 	0is_integer :SIGNAL 11  rc1+  rc<:SIGNAL 5  rc-|");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_drp)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13859, cdf_ptr13860, 3), cleanup, 
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		k->fv[0] = retain_cell(loc->cdf_rc);
		k->fv[1] = retain_cell(loc->cdf_z);
		k->fv[2] = retain_cell(loc->cdf_op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		CHK(fill_array(arr, dat), cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[424] nwreduce{op  axis");
	return err;
}

int
cdf_ptr13859(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13860(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_rc;
		struct cell_array_box *cdf_z;
		struct cell_func_box *cdf_op;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	if (!lex->cdf_op->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_op->value);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!lex->cdf_rc->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_rc->value);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_par)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	if (!lex->cdf_z->value)
		CHK(6, cleanup, L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
	*stkhd++ = retain_cell(lex->cdf_z->value);
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[426] 	z(-1){z((+rc))op z}z(-1)");
	return err;
}

int
cdf_ptr13861(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		*stkhd++ = arr;
	}
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
				CHK(fill_array(arr, dat), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
				CHK(fill_array(arr, dat), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	return err;
}

int
cdf_ptr13862(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_alpha)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lth)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
				CHK(fill_array(arr, dat), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
				CHK(fill_array(arr, dat), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.cdf_q_signal)
				CHK(6, cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		CHK(fill_array(arr, dat), cleanup, L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[428] red_check{0  1<:SIGNAL 4  1,:SIGNAL 5  0}");
	return err;
}

int
cdf_ptr13863(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_axis;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_red_check;
		struct cell_doper_box *cdf_nwreduce;
		struct cell_doper_box *cdf_reduce;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[429] rdf{   red_check :  axis0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[429] rdf{   red_check :  axis0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_red_check->value)
		CHK(6, cleanup, L"[429] rdf{   red_check :  axis0");
	
	*stkhd++ = retain_cell(lex->cdf_red_check->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[429] rdf{   red_check :  axis0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[429] rdf{   red_check :  axis0");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[429] rdf{   red_check :  axis0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[429] rdf{   red_check :  axis0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[429] rdf{   red_check :  axis0");
	
		CHK(fill_array(arr, dat), cleanup, L"[429] rdf{   red_check :  axis0");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rgt)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_axis)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(loc->cdf_axis);
			
			if (!lex->cdf_reduce->value)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(lex->cdf_reduce->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_doper *op = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_func *dst;
			
				CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
				    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_array(x);
				release_doper(op);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	if (!lex->cdf_nwreduce->value)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(lex->cdf_nwreduce->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[429] rdf{   red_check :  axis0");
	return err;
}

int
cdf_ptr13864(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_axis;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_red_check;
		struct cell_doper_box *cdf_nwreduce;
		struct cell_doper_box *cdf_reduce;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[429] rdf{   red_check :  axis0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_red_check->value)
		CHK(6, cleanup, L"[429] rdf{   red_check :  axis0");
	
	*stkhd++ = retain_cell(lex->cdf_red_check->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[429] rdf{   red_check :  axis0");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[429] rdf{   red_check :  axis0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[429] rdf{   red_check :  axis0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[429] rdf{   red_check :  axis0");
	
		CHK(fill_array(arr, dat), cleanup, L"[429] rdf{   red_check :  axis0");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rgt)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_axis)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(loc->cdf_axis);
			
			if (!lex->cdf_reduce->value)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(lex->cdf_reduce->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_doper *op = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_func *dst;
			
				CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
				    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_array(x);
				release_doper(op);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	if (!lex->cdf_nwreduce->value)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(lex->cdf_nwreduce->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[429] rdf{   red_check :  axis0");
	return err;
}

int
cdf_ptr13865(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_axis;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_red_check;
		struct cell_doper_box *cdf_nwreduce;
		struct cell_doper_box *cdf_reduce;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[429] rdf{   red_check :  axis0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[429] rdf{   red_check :  axis0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_red_check->value)
		CHK(6, cleanup, L"[429] rdf{   red_check :  axis0");
	
	*stkhd++ = retain_cell(lex->cdf_red_check->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[429] rdf{   red_check :  axis0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[429] rdf{   red_check :  axis0");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[429] rdf{   red_check :  axis0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[429] rdf{   red_check :  axis0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[429] rdf{   red_check :  axis0");
	
		CHK(fill_array(arr, dat), cleanup, L"[429] rdf{   red_check :  axis0");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rgt)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_axis)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(loc->cdf_axis);
			
			if (!lex->cdf_reduce->value)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(lex->cdf_reduce->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_doper *op = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_func *dst;
			
				CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
				    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(x);
				release_doper(op);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	if (!lex->cdf_nwreduce->value)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(lex->cdf_nwreduce->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[429] rdf{   red_check :  axis0");
	return err;
}

int
cdf_ptr13866(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_axis;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_red_check;
		struct cell_doper_box *cdf_nwreduce;
		struct cell_doper_box *cdf_reduce;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[429] rdf{   red_check :  axis0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_red_check->value)
		CHK(6, cleanup, L"[429] rdf{   red_check :  axis0");
	
	*stkhd++ = retain_cell(lex->cdf_red_check->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[429] rdf{   red_check :  axis0");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[429] rdf{   red_check :  axis0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[429] rdf{   red_check :  axis0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[429] rdf{   red_check :  axis0");
	
		CHK(fill_array(arr, dat), cleanup, L"[429] rdf{   red_check :  axis0");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rgt)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_axis)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(loc->cdf_axis);
			
			if (!lex->cdf_reduce->value)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(lex->cdf_reduce->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_doper *op = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_func *dst;
			
				CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
				    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(x);
				release_doper(op);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	if (!lex->cdf_nwreduce->value)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(lex->cdf_nwreduce->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[430] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[429] rdf{   red_check :  axis0");
	return err;
}

int
cdf_ptr13867(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_axis;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_red_check;
		struct cell_doper_box *cdf_nwreduce;
		struct cell_doper_box *cdf_reduce;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_red_check->value)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(lex->cdf_red_check->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[434] red{   red_check :  axis01+");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[434] red{   red_check :  axis01+");
	
		CHK(fill_array(arr, dat), cleanup, L"[434] red{   red_check :  axis01+");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[434] red{   red_check :  axis01+");
	
		CHK(fill_array(arr, dat), cleanup, L"[434] red{   red_check :  axis01+");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rgt)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_axis)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(loc->cdf_axis);
			
			if (!lex->cdf_reduce->value)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(lex->cdf_reduce->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_doper *op = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_func *dst;
			
				CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
				    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_array(x);
				release_doper(op);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	if (!lex->cdf_nwreduce->value)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(lex->cdf_nwreduce->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[434] red{   red_check :  axis01+");
	return err;
}

int
cdf_ptr13868(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_axis;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_red_check;
		struct cell_doper_box *cdf_nwreduce;
		struct cell_doper_box *cdf_reduce;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_red_check->value)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(lex->cdf_red_check->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[434] red{   red_check :  axis01+");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[434] red{   red_check :  axis01+");
	
		CHK(fill_array(arr, dat), cleanup, L"[434] red{   red_check :  axis01+");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[434] red{   red_check :  axis01+");
	
		CHK(fill_array(arr, dat), cleanup, L"[434] red{   red_check :  axis01+");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rgt)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_axis)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(loc->cdf_axis);
			
			if (!lex->cdf_reduce->value)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(lex->cdf_reduce->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_doper *op = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_func *dst;
			
				CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
				    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_array(x);
				release_doper(op);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	if (!lex->cdf_nwreduce->value)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(lex->cdf_nwreduce->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[434] red{   red_check :  axis01+");
	return err;
}

int
cdf_ptr13869(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_axis;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_red_check;
		struct cell_doper_box *cdf_nwreduce;
		struct cell_doper_box *cdf_reduce;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_red_check->value)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(lex->cdf_red_check->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[434] red{   red_check :  axis01+");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[434] red{   red_check :  axis01+");
	
		CHK(fill_array(arr, dat), cleanup, L"[434] red{   red_check :  axis01+");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[434] red{   red_check :  axis01+");
	
		CHK(fill_array(arr, dat), cleanup, L"[434] red{   red_check :  axis01+");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rgt)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_axis)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(loc->cdf_axis);
			
			if (!lex->cdf_reduce->value)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(lex->cdf_reduce->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_doper *op = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_func *dst;
			
				CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
				    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(x);
				release_doper(op);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	if (!lex->cdf_nwreduce->value)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(lex->cdf_nwreduce->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[434] red{   red_check :  axis01+");
	return err;
}

int
cdf_ptr13870(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_axis;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_red_check;
		struct cell_doper_box *cdf_nwreduce;
		struct cell_doper_box *cdf_reduce;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!lex->cdf_red_check->value)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(lex->cdf_red_check->value);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[434] red{   red_check :  axis01+");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[434] red{   red_check :  axis01+");
	
		CHK(fill_array(arr, dat), cleanup, L"[434] red{   red_check :  axis01+");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[434] red{   red_check :  axis01+");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[434] red{   red_check :  axis01+");
	
		CHK(fill_array(arr, dat), cleanup, L"[434] red{   red_check :  axis01+");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[434] red{   red_check :  axis01+");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		CHK(fill_array(arr, dat), cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rgt)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!loc->cdf_axis)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(loc->cdf_axis);
			
			if (!lex->cdf_reduce->value)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(lex->cdf_reduce->value);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_doper *op = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_func *dst;
			
				CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
				    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(x);
				release_doper(op);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	if (!lex->cdf_nwreduce->value)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(lex->cdf_nwreduce->value);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[435] 	1 1: reduce axis  ( nwreduce axis)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[434] red{   red_check :  axis01+");
	return err;
}

int
cdf_ptr13871(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[439] rpf{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[439] rpf{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[439] rpf{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[439] rpf{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[439] rpf{SIGNAL 16}");
	return err;
}

int
cdf_ptr13872(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[439] rpf{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[439] rpf{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[439] rpf{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[439] rpf{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[439] rpf{SIGNAL 16}");
	return err;
}

int
cdf_ptr13873(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[442] rep{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[442] rep{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[442] rep{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[442] rep{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[442] rep{SIGNAL 16}");
	return err;
}

int
cdf_ptr13874(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[442] rep{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[442] rep{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[442] rep{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[442] rep{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[442] rep{SIGNAL 16}");
	return err;
}

int
cdf_ptr13875(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array_box *cdf_X;
		struct cell_array_box *cdf_fn;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_array_box(&loc->cdf_X, NULL), cleanup, L"Init mutable variable: loc->cdf_X");
	CHK(mk_array_box(&loc->cdf_fn, NULL), cleanup, L"Init mutable variable: loc->cdf_fn");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_X->value);
	loc->cdf_X->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn->value);
	loc->cdf_fn->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		CHK(fill_array(arr, dat), cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13876, cdf_ptr13877, 2), cleanup, 
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		k->fv[0] = retain_cell(loc->cdf_fn);
		k->fv[1] = retain_cell(loc->cdf_X);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	return err;
}

int
cdf_ptr13876(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_fn;
		struct cell_array_box *cdf_X;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_X->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rpf)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	return err;
}

int
cdf_ptr13877(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_fn;
		struct cell_array_box *cdf_X;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_X->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rpf)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	return err;
}

int
cdf_ptr13878(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array_box *cdf_X;
		struct cell_array_box *cdf_fn;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_array_box(&loc->cdf_X, NULL), cleanup, L"Init mutable variable: loc->cdf_X");
	CHK(mk_array_box(&loc->cdf_fn, NULL), cleanup, L"Init mutable variable: loc->cdf_fn");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_X->value);
	loc->cdf_X->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn->value);
	loc->cdf_fn->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		CHK(fill_array(arr, dat), cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13879, cdf_ptr13880, 2), cleanup, 
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		k->fv[0] = retain_cell(loc->cdf_fn);
		k->fv[1] = retain_cell(loc->cdf_X);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	return err;
}

int
cdf_ptr13879(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_fn;
		struct cell_array_box *cdf_X;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_X->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rpf)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	return err;
}

int
cdf_ptr13880(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_fn;
		struct cell_array_box *cdf_X;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_X->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rpf)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	return err;
}

int
cdf_ptr13881(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array_box *cdf_X;
		struct cell_func_box *cdf_fn;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_array_box(&loc->cdf_X, NULL), cleanup, L"Init mutable variable: loc->cdf_X");
	CHK(mk_func_box(&loc->cdf_fn, NULL), cleanup, L"Init mutable variable: loc->cdf_fn");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_X->value);
	loc->cdf_X->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn->value);
	loc->cdf_fn->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		CHK(fill_array(arr, dat), cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13882, cdf_ptr13883, 2), cleanup, 
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		k->fv[0] = retain_cell(loc->cdf_fn);
		k->fv[1] = retain_cell(loc->cdf_X);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	return err;
}

int
cdf_ptr13882(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_fn;
		struct cell_array_box *cdf_X;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_X->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	return err;
}

int
cdf_ptr13883(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_fn;
		struct cell_array_box *cdf_X;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_X->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	return err;
}

int
cdf_ptr13884(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array_box *cdf_X;
		struct cell_func_box *cdf_fn;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	CHK(mk_array_box(&loc->cdf_X, NULL), cleanup, L"Init mutable variable: loc->cdf_X");
	CHK(mk_func_box(&loc->cdf_fn, NULL), cleanup, L"Init mutable variable: loc->cdf_fn");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_X->value);
	loc->cdf_X->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn->value);
	loc->cdf_fn->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		CHK(fill_array(arr, dat), cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13885, cdf_ptr13886, 2), cleanup, 
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		k->fv[0] = retain_cell(loc->cdf_fn);
		k->fv[1] = retain_cell(loc->cdf_X);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	return err;
}

int
cdf_ptr13885(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_fn;
		struct cell_array_box *cdf_X;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_X->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	return err;
}

int
cdf_ptr13886(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_fn;
		struct cell_array_box *cdf_X;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_X->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[445] scf{X,  fn  squeeze (){fnX[]}1+}");
	return err;
}

int
cdf_ptr13887(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_axis;
		struct cell_array_box *cdf_fn;
		struct cell_array_box *cdf_x;
		struct cell_array *cdf_c;
		struct cell_array *cdf_la;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	CHK(mk_array_box(&loc->cdf_fn, NULL), cleanup, L"Init mutable variable: loc->cdf_fn");
	CHK(mk_array_box(&loc->cdf_x, NULL), cleanup, L"Init mutable variable: loc->cdf_x");
	loc->cdf_c = NULL;
	loc->cdf_la = NULL;
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[449] 	axis01+  fn");
	
		CHK(fill_array(arr, dat), cleanup, L"[449] 	axis01+  fn");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[449] 	axis01+  fn");
	
		CHK(fill_array(arr, dat), cleanup, L"[449] 	axis01+  fn");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn->value);
	loc->cdf_fn->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_gth)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_gth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		CHK(fill_array(arr, dat), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->cdf_x->value);
			loc->cdf_x->value = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_nqv)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_iot)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_iot);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				CHK(fill_array(arr, dat), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13888, cdf_ptr13889, 2), cleanup, 
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				k->fv[0] = retain_cell(loc->cdf_fn);
				k->fv[1] = retain_cell(loc->cdf_x);
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!lex->cdf_squeeze->value)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(lex->cdf_squeeze->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_tke)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_tke);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_c);
	loc->cdf_c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_la);
	loc->cdf_la = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_la)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_la);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[451] 	caxis  laaxis  xc la");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_x->value);
	loc->cdf_x->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		CHK(fill_array(arr, dat), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_la)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_la);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_la)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_la);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13890, cdf_ptr13891, 3), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		k->fv[0] = retain_cell(loc->cdf_fn);
		k->fv[1] = retain_cell(loc->cdf_x);
		k->fv[2] = retain_cell(loc->cdf_z);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[448] scn{");
	return err;
}

int
cdf_ptr13888(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_fn;
		struct cell_array_box *cdf_x;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rpf)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	return err;
}

int
cdf_ptr13889(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_fn;
		struct cell_array_box *cdf_x;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rpf)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	return err;
}

int
cdf_ptr13890(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_fn;
		struct cell_array_box *cdf_x;
		struct cell_array_box *cdf_z;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		CHK(fill_array(arr, dat), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rep)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rep);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	return err;
}

int
cdf_ptr13891(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_fn;
		struct cell_array_box *cdf_x;
		struct cell_array_box *cdf_z;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		CHK(fill_array(arr, dat), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rep)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rep);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	return err;
}

int
cdf_ptr13892(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_axis;
		struct cell_array_box *cdf_fn;
		struct cell_array_box *cdf_x;
		struct cell_array *cdf_c;
		struct cell_array *cdf_la;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	CHK(mk_array_box(&loc->cdf_fn, NULL), cleanup, L"Init mutable variable: loc->cdf_fn");
	CHK(mk_array_box(&loc->cdf_x, NULL), cleanup, L"Init mutable variable: loc->cdf_x");
	loc->cdf_c = NULL;
	loc->cdf_la = NULL;
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[449] 	axis01+  fn");
	
		CHK(fill_array(arr, dat), cleanup, L"[449] 	axis01+  fn");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[449] 	axis01+  fn");
	
		CHK(fill_array(arr, dat), cleanup, L"[449] 	axis01+  fn");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn->value);
	loc->cdf_fn->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_gth)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_gth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		CHK(fill_array(arr, dat), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->cdf_x->value);
			loc->cdf_x->value = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_nqv)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_iot)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_iot);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				CHK(fill_array(arr, dat), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13893, cdf_ptr13894, 2), cleanup, 
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				k->fv[0] = retain_cell(loc->cdf_fn);
				k->fv[1] = retain_cell(loc->cdf_x);
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!lex->cdf_squeeze->value)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(lex->cdf_squeeze->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_tke)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_tke);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_c);
	loc->cdf_c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_la);
	loc->cdf_la = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_la)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_la);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[451] 	caxis  laaxis  xc la");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_x->value);
	loc->cdf_x->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		CHK(fill_array(arr, dat), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_la)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_la);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_la)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_la);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13895, cdf_ptr13896, 3), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		k->fv[0] = retain_cell(loc->cdf_fn);
		k->fv[1] = retain_cell(loc->cdf_x);
		k->fv[2] = retain_cell(loc->cdf_z);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[448] scn{");
	return err;
}

int
cdf_ptr13893(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_fn;
		struct cell_array_box *cdf_x;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rpf)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	return err;
}

int
cdf_ptr13894(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_fn;
		struct cell_array_box *cdf_x;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rpf)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	return err;
}

int
cdf_ptr13895(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_array_box *cdf_fn;
		struct cell_array_box *cdf_x;
		struct cell_array_box *cdf_z;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		CHK(fill_array(arr, dat), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rep)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rep);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	return err;
}

int
cdf_ptr13896(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *cdf_fn;
		struct cell_array_box *cdf_x;
		struct cell_array_box *cdf_z;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		CHK(fill_array(arr, dat), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rep)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rep);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	return err;
}

int
cdf_ptr13897(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_axis;
		struct cell_func_box *cdf_fn;
		struct cell_array_box *cdf_x;
		struct cell_array *cdf_c;
		struct cell_array *cdf_la;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	CHK(mk_func_box(&loc->cdf_fn, NULL), cleanup, L"Init mutable variable: loc->cdf_fn");
	CHK(mk_array_box(&loc->cdf_x, NULL), cleanup, L"Init mutable variable: loc->cdf_x");
	loc->cdf_c = NULL;
	loc->cdf_la = NULL;
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[449] 	axis01+  fn");
	
		CHK(fill_array(arr, dat), cleanup, L"[449] 	axis01+  fn");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[449] 	axis01+  fn");
	
		CHK(fill_array(arr, dat), cleanup, L"[449] 	axis01+  fn");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn->value);
	loc->cdf_fn->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_gth)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_gth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		CHK(fill_array(arr, dat), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->cdf_x->value);
			loc->cdf_x->value = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_nqv)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_iot)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_iot);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				CHK(fill_array(arr, dat), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13898, cdf_ptr13899, 2), cleanup, 
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				k->fv[0] = retain_cell(loc->cdf_fn);
				k->fv[1] = retain_cell(loc->cdf_x);
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!lex->cdf_squeeze->value)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(lex->cdf_squeeze->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_tke)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_tke);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_c);
	loc->cdf_c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_la);
	loc->cdf_la = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_la)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_la);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[451] 	caxis  laaxis  xc la");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_x->value);
	loc->cdf_x->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		CHK(fill_array(arr, dat), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_la)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_la);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_la)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_la);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13900, cdf_ptr13901, 3), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		k->fv[0] = retain_cell(loc->cdf_fn);
		k->fv[1] = retain_cell(loc->cdf_x);
		k->fv[2] = retain_cell(loc->cdf_z);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[448] scn{");
	return err;
}

int
cdf_ptr13898(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_fn;
		struct cell_array_box *cdf_x;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	return err;
}

int
cdf_ptr13899(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_fn;
		struct cell_array_box *cdf_x;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	return err;
}

int
cdf_ptr13900(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_fn;
		struct cell_array_box *cdf_x;
		struct cell_array_box *cdf_z;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		CHK(fill_array(arr, dat), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_red)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_red);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	return err;
}

int
cdf_ptr13901(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_fn;
		struct cell_array_box *cdf_x;
		struct cell_array_box *cdf_z;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		CHK(fill_array(arr, dat), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_red)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_red);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	return err;
}

int
cdf_ptr13902(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_axis;
		struct cell_func_box *cdf_fn;
		struct cell_array_box *cdf_x;
		struct cell_array *cdf_c;
		struct cell_array *cdf_la;
		struct cell_array_box *cdf_z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *cdf_squeeze;
	} *lex;

	lex = (struct lex_vars *)cdf_deldel->fv;

	loc->cdf_axis = NULL;
	CHK(mk_func_box(&loc->cdf_fn, NULL), cleanup, L"Init mutable variable: loc->cdf_fn");
	CHK(mk_array_box(&loc->cdf_x, NULL), cleanup, L"Init mutable variable: loc->cdf_x");
	loc->cdf_c = NULL;
	loc->cdf_la = NULL;
	CHK(mk_array_box(&loc->cdf_z, NULL), cleanup, L"Init mutable variable: loc->cdf_z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[449] 	axis01+  fn");
	
		CHK(fill_array(arr, dat), cleanup, L"[449] 	axis01+  fn");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_max)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_max);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[449] 	axis01+  fn");
	
		CHK(fill_array(arr, dat), cleanup, L"[449] 	axis01+  fn");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[449] 	axis01+  fn");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_axis);
	loc->cdf_axis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[449] 	axis01+  fn");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn->value);
	loc->cdf_fn->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_gth)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_gth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		CHK(fill_array(arr, dat), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_cat)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->cdf_x->value);
			loc->cdf_x->value = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.cdf_lft)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_lft);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_nqv)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_iot)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_iot);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_add)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				CHK(fill_array(arr, dat), cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_map)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_map);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, cdf_ptr13903, cdf_ptr13904, 2), cleanup, 
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				k->fv[0] = retain_cell(loc->cdf_fn);
				k->fv[1] = retain_cell(loc->cdf_x);
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_prim.cdf_rho)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(cdf_prim.cdf_rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!lex->cdf_squeeze->value)
				CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
			*stkhd++ = retain_cell(lex->cdf_squeeze->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[450] 	1>:squeeze (){fnx[]}1+x,");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_tke)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_tke);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_c);
	loc->cdf_c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_sqd)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sqd);
	
	if (!loc->cdf_axis)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_axis);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_la);
	loc->cdf_la = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_la)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_la);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[451] 	caxis  laaxis  xc la");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[451] 	caxis  laaxis  xc la");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[451] 	caxis  laaxis  xc la");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_x->value);
	loc->cdf_x->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		CHK(fill_array(arr, dat), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!loc->cdf_la)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_la);
	
	if (!loc->cdf_c)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_c);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_z->value);
	loc->cdf_z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_la)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_la);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, cdf_ptr13905, cdf_ptr13906, 3), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		k->fv[0] = retain_cell(loc->cdf_fn);
		k->fv[1] = retain_cell(loc->cdf_x);
		k->fv[2] = retain_cell(loc->cdf_z);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_lft)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_lft);
	
	if (!loc->cdf_z->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(loc->cdf_z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->cdf_squeeze->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[448] scn{");
	return err;
}

int
cdf_ptr13903(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_fn;
		struct cell_array_box *cdf_x;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	return err;
}

int
cdf_ptr13904(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_fn;
		struct cell_array_box *cdf_x;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[450] 	1>:squeeze (){fnx[]}1+x,");
	return err;
}

int
cdf_ptr13905(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	struct lex_vars {
		struct cell_func_box *cdf_fn;
		struct cell_array_box *cdf_x;
		struct cell_array_box *cdf_z;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		CHK(fill_array(arr, dat), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_red)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_red);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	return err;
}

int
cdf_ptr13906(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *cdf_fn;
		struct cell_array_box *cdf_x;
		struct cell_array_box *cdf_z;
	} *lex;

	lex = (struct lex_vars *)cdf_self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_add)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		CHK(fill_array(arr, dat), cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!lex->cdf_x->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_x->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_red)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_red);
	
	if (!lex->cdf_fn->value)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(lex->cdf_fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_set)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_set);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_spn)
		CHK(6, cleanup, L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_spn);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = lex->cdf_z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[452] 	squeeze ()z{z[;]fn/x[;1+]}lazc la0");
	return err;
}

int
cdf_ptr13907(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[456] xpf{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[456] xpf{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[456] xpf{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[456] xpf{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[456] xpf{SIGNAL 16}");
	return err;
}

int
cdf_ptr13908(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[456] xpf{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[456] xpf{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[456] xpf{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[456] xpf{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[456] xpf{SIGNAL 16}");
	return err;
}

int
cdf_ptr13909(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;

	cdf_alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[459] xpd{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[459] xpd{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[459] xpd{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[459] xpd{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[459] xpd{SIGNAL 16}");
	return err;
}

int
cdf_ptr13910(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[459] xpd{SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[459] xpd{SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[459] xpd{SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[459] xpd{SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[459] xpd{SIGNAL 16}");
	return err;
}

int
cdf_ptr13911(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[462] dot{  }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[462] dot{  }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[462] dot{  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[462] dot{  }");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rpf)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[462] dot{  }");
	return err;
}

int
cdf_ptr13912(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[462] dot{  }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[462] dot{  }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[462] dot{  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[462] dot{  }");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rpf)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[462] dot{  }");
	return err;
}

int
cdf_ptr13913(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[462] dot{  }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[462] dot{  }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[462] dot{  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[462] dot{  }");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[462] dot{  }");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[462] dot{  }");
	return err;
}

int
cdf_ptr13914(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[462] dot{  }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[462] dot{  }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[462] dot{  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[462] dot{  }");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[462] dot{  }");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[462] dot{  }");
	return err;
}

int
cdf_ptr13915(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[462] dot{  }");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rpf)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[462] dot{  }");
	return err;
}

int
cdf_ptr13916(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[462] dot{  }");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rpf)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rpf);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[462] dot{  }");
	return err;
}

int
cdf_ptr13917(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[462] dot{  }");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[462] dot{  }");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[462] dot{  }");
	return err;
}

int
cdf_ptr13918(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[462] dot{  }");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rdf)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rdf);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[462] dot{  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[462] dot{  }");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[462] dot{  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[462] dot{  }");
	return err;
}

int
cdf_ptr13919(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_y;
		struct cell_array *cdf_i;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_y = NULL;
	loc->cdf_i = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_y);
	loc->cdf_y = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_i);
	loc->cdf_i = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_i)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_i);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	if (!cdf_prim.cdf_div)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_div);
	
	if (!loc->cdf_i)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_min)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	return err;
}

int
cdf_ptr13920(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_y;
		struct cell_array *cdf_i;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_y = NULL;
	loc->cdf_i = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_y);
	loc->cdf_y = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_i);
	loc->cdf_i = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_i)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_i);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	if (!cdf_prim.cdf_div)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_div);
	
	if (!loc->cdf_i)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_min)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	return err;
}

int
cdf_ptr13921(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_y;
		struct cell_array *cdf_i;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_y = NULL;
	loc->cdf_i = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_y);
	loc->cdf_y = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_i);
	loc->cdf_i = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_i)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_i);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	if (!cdf_prim.cdf_div)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_div);
	
	if (!loc->cdf_i)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_min)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	return err;
}

int
cdf_ptr13922(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_y;
		struct cell_array *cdf_i;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_y = NULL;
	loc->cdf_i = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_omega)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_y);
	loc->cdf_y = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.cdf_mul)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_mul);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_nqv)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_iot)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cdf_i);
	loc->cdf_i = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->cdf_i)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_i);
	
	if (!cdf_prim.cdf_res)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_res);
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_map)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_map);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->cdf_y)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_y);
	
	if (!cdf_prim.cdf_div)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_div);
	
	if (!loc->cdf_i)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(loc->cdf_i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_min)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_brk)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_brk);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_cat)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_cat);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	if (!cdf_prim.cdf_rho)
		CHK(6, cleanup, L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[465] oup{i(,)y,  ((),)(,)[iy](,)[y|i]}");
	return err;
}

int
cdf_ptr13923(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[468] pow{0:     (-1)  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[468] pow{0:     (-1)  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[468] pow{0:     (-1)  }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[468] pow{0:     (-1)  }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[468] pow{0:     (-1)  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_deldel)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_deldel);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[468] pow{0:     (-1)  }");
	return err;
}

int
cdf_ptr13924(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[468] pow{0:     (-1)  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[468] pow{0:     (-1)  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[468] pow{0:     (-1)  }");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[468] pow{0:     (-1)  }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[468] pow{0:     (-1)  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_deldel)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_deldel);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[468] pow{0:     (-1)  }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[468] pow{0:     (-1)  }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[468] pow{0:     (-1)  }");
	return err;
}

int
cdf_ptr13925(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[468] pow{0:     (-1)  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[468] pow{0:     (-1)  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[468] pow{0:     (-1)  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_deldel)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_deldel);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[468] pow{0:     (-1)  }");
	return err;
}

int
cdf_ptr13926(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[468] pow{0:     (-1)  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[468] pow{0:     (-1)  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[468] pow{0:     (-1)  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_deldel)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_deldel);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[468] pow{0:     (-1)  }");
	return err;
}

int
cdf_ptr13927(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[468] pow{0:     (-1)  }");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[468] pow{0:     (-1)  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[468] pow{0:     (-1)  }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[468] pow{0:     (-1)  }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[468] pow{0:     (-1)  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_deldel)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_deldel);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[468] pow{0:     (-1)  }");
	return err;
}

int
cdf_ptr13928(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[468] pow{0:     (-1)  }");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[468] pow{0:     (-1)  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[468] pow{0:     (-1)  }");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[468] pow{0:     (-1)  }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[468] pow{0:     (-1)  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_deldel)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_deldel);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[468] pow{0:     (-1)  }");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[468] pow{0:     (-1)  }");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		CHK(squeeze_array(arr), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[468] pow{0:     (-1)  }");
	return err;
}

int
cdf_ptr13929(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[468] pow{0:     (-1)  }");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[468] pow{0:     (-1)  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	release_cell(cdf_alpha);
	cdf_alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[468] pow{0:     (-1)  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_deldel)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_deldel);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[468] pow{0:     (-1)  }");
	return err;
}

int
cdf_ptr13930(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[468] pow{0:     (-1)  }");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[468] pow{0:     (-1)  }");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_omega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omega);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cdf_rgt)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[468] pow{0:     (-1)  }");
	
		CHK(fill_array(arr, dat), cleanup, L"[468] pow{0:     (-1)  }");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_sub)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_deldel)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_deldel);
	
	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_alpha)
		CHK(6, cleanup, L"[468] pow{0:     (-1)  }");
	
	*stkhd++ = retain_cell(cdf_alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[468] pow{0:     (-1)  }");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[468] pow{0:     (-1)  }");
	return err;
}

int
cdf_ptr13931(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[472] 	typeNC'' '' ''");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[472] 	typeNC'' '' ''");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_type);
	loc->cdf_type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[473] 	type2 3 3:   ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[473] 	type2 3 3:   ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[473] 	type2 3 3:   ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[473] 	type2 3 3:   ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[473] 	type2 3 3:   ");
				arr->shape[0] = 4;
				CHK(alloc_array(arr), cleanup,
				    L"[473] 	type2 3 3:   ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
				dat[3] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[473] 	type2 3 3:   ");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[474] 	type0 3 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[474] 	type0 3 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[474] 	type0 3 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[474] 	type0 3 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[474] 	type0 3 3:  ");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[474] 	type0 3 3:  ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[474] 	type0 3 3:  ");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[475] 	type0 2 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[475] 	type0 2 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[475] 	type0 2 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[475] 	type0 2 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[475] 	type0 2 3:  ");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[475] 	type0 2 3:  ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[475] 	type0 2 3:  ");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[476] 	type0 3 2:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[476] 	type0 3 2:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[476] 	type0 3 2:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[476] 	type0 3 2:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[476] 	type0 3 2:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[476] 	type0 3 2:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[476] 	type0 3 2:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[476] 	type0 3 2:  ");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[476] 	type0 3 2:  ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[476] 	type0 3 2:  ");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[477] 	SIGNAL 2");
	
		CHK(fill_array(arr, dat), cleanup, L"[477] 	SIGNAL 2");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[477] 	SIGNAL 2");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[477] 	SIGNAL 2");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[471] jot{");
	return err;
}

int
cdf_ptr13932(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 2, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[472] 	typeNC'' '' ''");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[472] 	typeNC'' '' ''");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_type);
	loc->cdf_type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[473] 	type2 3 3:   ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[473] 	type2 3 3:   ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[473] 	type2 3 3:   ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[473] 	type2 3 3:   ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[473] 	type2 3 3:   ");
				arr->shape[0] = 4;
				CHK(alloc_array(arr), cleanup,
				    L"[473] 	type2 3 3:   ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
				dat[3] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[473] 	type2 3 3:   ");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[474] 	type0 3 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[474] 	type0 3 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[474] 	type0 3 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[474] 	type0 3 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[474] 	type0 3 3:  ");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[474] 	type0 3 3:  ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[474] 	type0 3 3:  ");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[475] 	type0 2 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[475] 	type0 2 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[475] 	type0 2 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[475] 	type0 2 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[475] 	type0 2 3:  ");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[475] 	type0 2 3:  ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[475] 	type0 2 3:  ");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[476] 	type0 3 2:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[476] 	type0 3 2:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[476] 	type0 3 2:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[476] 	type0 3 2:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[476] 	type0 3 2:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[476] 	type0 3 2:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[476] 	type0 3 2:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[476] 	type0 3 2:  ");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[476] 	type0 3 2:  ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[476] 	type0 3 2:  ");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[477] 	SIGNAL 2");
	
		CHK(fill_array(arr, dat), cleanup, L"[477] 	SIGNAL 2");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[477] 	SIGNAL 2");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[477] 	SIGNAL 2");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[471] jot{");
	return err;
}

int
cdf_ptr13933(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[472] 	typeNC'' '' ''");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[472] 	typeNC'' '' ''");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_type);
	loc->cdf_type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[473] 	type2 3 3:   ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[473] 	type2 3 3:   ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[473] 	type2 3 3:   ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[473] 	type2 3 3:   ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[473] 	type2 3 3:   ");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[473] 	type2 3 3:   ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[473] 	type2 3 3:   ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[473] 	type2 3 3:   ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[474] 	type0 3 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[474] 	type0 3 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[474] 	type0 3 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[474] 	type0 3 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[474] 	type0 3 3:  ");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[474] 	type0 3 3:  ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[474] 	type0 3 3:  ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[474] 	type0 3 3:  ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[475] 	type0 2 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[475] 	type0 2 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[475] 	type0 2 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[475] 	type0 2 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[475] 	type0 2 3:  ");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[475] 	type0 2 3:  ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[475] 	type0 2 3:  ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[475] 	type0 2 3:  ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[476] 	type0 3 2:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[476] 	type0 3 2:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[476] 	type0 3 2:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[476] 	type0 3 2:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[476] 	type0 3 2:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[476] 	type0 3 2:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[476] 	type0 3 2:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[476] 	type0 3 2:  ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[477] 	SIGNAL 2");
	
		CHK(fill_array(arr, dat), cleanup, L"[477] 	SIGNAL 2");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[477] 	SIGNAL 2");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[477] 	SIGNAL 2");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[471] jot{");
	return err;
}

int
cdf_ptr13934(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[472] 	typeNC'' '' ''");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[472] 	typeNC'' '' ''");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_type);
	loc->cdf_type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[473] 	type2 3 3:   ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[473] 	type2 3 3:   ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[473] 	type2 3 3:   ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[473] 	type2 3 3:   ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[473] 	type2 3 3:   ");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[473] 	type2 3 3:   ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[473] 	type2 3 3:   ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[473] 	type2 3 3:   ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[474] 	type0 3 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[474] 	type0 3 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[474] 	type0 3 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[474] 	type0 3 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[474] 	type0 3 3:  ");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[474] 	type0 3 3:  ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[474] 	type0 3 3:  ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[474] 	type0 3 3:  ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[475] 	type0 2 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[475] 	type0 2 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[475] 	type0 2 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[475] 	type0 2 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[475] 	type0 2 3:  ");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[475] 	type0 2 3:  ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[475] 	type0 2 3:  ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[475] 	type0 2 3:  ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[476] 	type0 3 2:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[476] 	type0 3 2:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[476] 	type0 3 2:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[476] 	type0 3 2:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[476] 	type0 3 2:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[476] 	type0 3 2:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_omega)
				CHK(6, cleanup, L"[476] 	type0 3 2:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[476] 	type0 3 2:  ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[477] 	SIGNAL 2");
	
		CHK(fill_array(arr, dat), cleanup, L"[477] 	SIGNAL 2");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[477] 	SIGNAL 2");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[477] 	SIGNAL 2");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[471] jot{");
	return err;
}

int
cdf_ptr13935(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[472] 	typeNC'' '' ''");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[472] 	typeNC'' '' ''");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_type);
	loc->cdf_type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[473] 	type2 3 3:   ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[473] 	type2 3 3:   ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[473] 	type2 3 3:   ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[473] 	type2 3 3:   ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[473] 	type2 3 3:   ");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[473] 	type2 3 3:   ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[473] 	type2 3 3:   ");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[473] 	type2 3 3:   ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[474] 	type0 3 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[474] 	type0 3 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[474] 	type0 3 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[474] 	type0 3 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[474] 	type0 3 3:  ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[475] 	type0 2 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[475] 	type0 2 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[475] 	type0 2 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[475] 	type0 2 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[475] 	type0 2 3:  ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[476] 	type0 3 2:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[476] 	type0 3 2:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[476] 	type0 3 2:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[476] 	type0 3 2:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			CHK(2, cleanup, L"[476] 	type0 3 2:  ");
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[477] 	SIGNAL 2");
	
		CHK(fill_array(arr, dat), cleanup, L"[477] 	SIGNAL 2");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[477] 	SIGNAL 2");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[477] 	SIGNAL 2");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[471] jot{");
	return err;
}

int
cdf_ptr13936(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[472] 	typeNC'' '' ''");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[472] 	typeNC'' '' ''");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_type);
	loc->cdf_type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[473] 	type2 3 3:   ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[473] 	type2 3 3:   ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[473] 	type2 3 3:   ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[473] 	type2 3 3:   ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[473] 	type2 3 3:   ");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[473] 	type2 3 3:   ");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				CHK(squeeze_array(arr), cleanup,
				    L"[473] 	type2 3 3:   ");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[473] 	type2 3 3:   ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[474] 	type0 3 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[474] 	type0 3 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[474] 	type0 3 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[474] 	type0 3 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[474] 	type0 3 3:  ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[475] 	type0 2 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[475] 	type0 2 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[475] 	type0 2 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[475] 	type0 2 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[475] 	type0 2 3:  ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[476] 	type0 3 2:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[476] 	type0 3 2:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[476] 	type0 3 2:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[476] 	type0 3 2:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			CHK(2, cleanup, L"[476] 	type0 3 2:  ");
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[477] 	SIGNAL 2");
	
		CHK(fill_array(arr, dat), cleanup, L"[477] 	SIGNAL 2");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[477] 	SIGNAL 2");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[477] 	SIGNAL 2");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[471] jot{");
	return err;
}

int
cdf_ptr13937(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[472] 	typeNC'' '' ''");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[472] 	typeNC'' '' ''");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_type);
	loc->cdf_type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[473] 	type2 3 3:   ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[473] 	type2 3 3:   ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[473] 	type2 3 3:   ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[473] 	type2 3 3:   ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[473] 	type2 3 3:   ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[473] 	type2 3 3:   ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[474] 	type0 3 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[474] 	type0 3 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[474] 	type0 3 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[474] 	type0 3 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[474] 	type0 3 3:  ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[474] 	type0 3 3:  ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[475] 	type0 2 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[475] 	type0 2 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[475] 	type0 2 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[475] 	type0 2 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[475] 	type0 2 3:  ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[475] 	type0 2 3:  ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[476] 	type0 3 2:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[476] 	type0 3 2:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[476] 	type0 3 2:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[476] 	type0 3 2:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			CHK(2, cleanup, L"[476] 	type0 3 2:  ");
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[477] 	SIGNAL 2");
	
		CHK(fill_array(arr, dat), cleanup, L"[477] 	SIGNAL 2");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[477] 	SIGNAL 2");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[477] 	SIGNAL 2");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[471] jot{");
	return err;
}

int
cdf_ptr13938(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[472] 	typeNC'' '' ''");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[472] 	typeNC'' '' ''");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->cdf_type);
	loc->cdf_type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[473] 	type2 3 3:   ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[473] 	type2 3 3:   ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[473] 	type2 3 3:   ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[473] 	type2 3 3:   ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[473] 	type2 3 3:   ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[473] 	type2 3 3:   ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			if (!cdf_alpha)
				CHK(6, cleanup, L"[473] 	type2 3 3:   ");
			
			*stkhd++ = retain_cell(cdf_alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[473] 	type2 3 3:   ");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[474] 	type0 3 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[474] 	type0 3 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[474] 	type0 3 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[474] 	type0 3 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[474] 	type0 3 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[474] 	type0 3 3:  ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[474] 	type0 3 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[474] 	type0 3 3:  ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[475] 	type0 2 3:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[475] 	type0 2 3:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[475] 	type0 2 3:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[475] 	type0 2 3:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[475] 	type0 2 3:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!cdf_omega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omega);
			
			if (!cdf_omegaomega)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[475] 	type0 2 3:  ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_alphaalpha)
				CHK(6, cleanup, L"[475] 	type0 2 3:  ");
			
			*stkhd++ = retain_cell(cdf_alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[475] 	type0 2 3:  ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[476] 	type0 3 2:  ");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[476] 	type0 3 2:  ");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_eqv)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_eqv);
	
	if (!loc->cdf_type)
		CHK(6, cleanup, L"[476] 	type0 3 2:  ");
	
	*stkhd++ = retain_cell(loc->cdf_type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[476] 	type0 3 2:  ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[476] 	type0 3 2:  ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			CHK(2, cleanup, L"[476] 	type0 3 2:  ");
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[477] 	SIGNAL 2");
	
		CHK(fill_array(arr, dat), cleanup, L"[477] 	SIGNAL 2");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[477] 	SIGNAL 2");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[477] 	SIGNAL 2");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[471] jot{");
	return err;
}

int
cdf_ptr13939(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_fn;
		struct cell_array *cdf_rk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_fn = NULL;
	loc->cdf_rk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn);
	loc->cdf_fn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_rk);
	loc->cdf_rk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[481] rnk{fn  rk  SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[481] rnk{fn  rk  SIGNAL 16}");
	return err;
}

int
cdf_ptr13940(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_fn;
		struct cell_array *cdf_rk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_fn = NULL;
	loc->cdf_rk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn);
	loc->cdf_fn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_rk);
	loc->cdf_rk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[481] rnk{fn  rk  SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[481] rnk{fn  rk  SIGNAL 16}");
	return err;
}

int
cdf_ptr13941(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func *cdf_fn;
		struct cell_array *cdf_rk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_fn = NULL;
	loc->cdf_rk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn);
	loc->cdf_fn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_rk);
	loc->cdf_rk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[481] rnk{fn  rk  SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[481] rnk{fn  rk  SIGNAL 16}");
	return err;
}

int
cdf_ptr13942(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_array *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func *cdf_fn;
		struct cell_array *cdf_rk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_fn = NULL;
	loc->cdf_rk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn);
	loc->cdf_fn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_rk);
	loc->cdf_rk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[481] rnk{fn  rk  SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[481] rnk{fn  rk  SIGNAL 16}");
	return err;
}

int
cdf_ptr13943(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_fn;
		struct cell_func *cdf_rk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_fn = NULL;
	loc->cdf_rk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn);
	loc->cdf_fn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_rk);
	loc->cdf_rk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[481] rnk{fn  rk  SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[481] rnk{fn  rk  SIGNAL 16}");
	return err;
}

int
cdf_ptr13944(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_array *cdf_fn;
		struct cell_func *cdf_rk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_fn = NULL;
	loc->cdf_rk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn);
	loc->cdf_fn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_rk);
	loc->cdf_rk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[481] rnk{fn  rk  SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[481] rnk{fn  rk  SIGNAL 16}");
	return err;
}

int
cdf_ptr13945(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func *cdf_fn;
		struct cell_func *cdf_rk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_fn = NULL;
	loc->cdf_rk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn);
	loc->cdf_fn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_rk);
	loc->cdf_rk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[481] rnk{fn  rk  SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[481] rnk{fn  rk  SIGNAL 16}");
	return err;
}

int
cdf_ptr13946(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;
	struct cell_func *cdf_omegaomega;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];
	cdf_omegaomega = cdf_self->fv[2];

	struct {
		struct cell_func *cdf_fn;
		struct cell_func *cdf_rk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_fn = NULL;
	loc->cdf_rk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn);
	loc->cdf_fn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!cdf_omegaomega)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_omegaomega);
	
	release_cell(loc->cdf_rk);
	loc->cdf_rk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[481] rnk{fn  rk  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[481] rnk{fn  rk  SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[481] rnk{fn  rk  SIGNAL 16}");
	return err;
}

int
cdf_ptr13947(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_fn;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_fn = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[484] key{fn  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn);
	loc->cdf_fn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[484] key{fn  SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[484] key{fn  SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[484] key{fn  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[484] key{fn  SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[484] key{fn  SIGNAL 16}");
	return err;
}

int
cdf_ptr13948(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_array *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_array *cdf_fn;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_fn = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[484] key{fn  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn);
	loc->cdf_fn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[484] key{fn  SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[484] key{fn  SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[484] key{fn  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[484] key{fn  SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[484] key{fn  SIGNAL 16}");
	return err;
}

int
cdf_ptr13949(struct cell_array **z,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *cdf_alpha;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_alpha = NULL;
	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_func *cdf_fn;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_fn = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[484] key{fn  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn);
	loc->cdf_fn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[484] key{fn  SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[484] key{fn  SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[484] key{fn  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[484] key{fn  SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(cdf_alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[484] key{fn  SIGNAL 16}");
	return err;
}

int
cdf_ptr13950(struct cell_array **z,
    struct cell_array *cdf_alpha,
    struct cell_array *cdf_omega,
    struct cell_func *cdf_self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *cdf_deldel;
	struct cell_func *cdf_alphaalpha;

	cdf_deldel = cdf_self->fv[0];
	cdf_alphaalpha = cdf_self->fv[1];

	struct {
		struct cell_func *cdf_fn;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->cdf_fn = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_alphaalpha)
		CHK(6, cleanup, L"[484] key{fn  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_alphaalpha);
	
	release_cell(loc->cdf_fn);
	loc->cdf_fn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[484] key{fn  SIGNAL 16}");
	
		CHK(fill_array(arr, dat), cleanup, L"[484] key{fn  SIGNAL 16}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cdf_q_signal)
		CHK(6, cleanup, L"[484] key{fn  SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.cdf_q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[484] key{fn  SIGNAL 16}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[484] key{fn  SIGNAL 16}");
	return err;
}

EXPORT int
cdf_q_signal(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_q_signal;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_q_signal_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_q_signal, z, l, r, L"cdf_q_signal");
}

EXPORT int
cdf_q_dr(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_q_dr;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_q_dr_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_q_dr, z, l, r, L"cdf_q_dr");
}

EXPORT int
cdf_squeeze(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_squeeze->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_squeeze_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_squeeze, z, l, r, L"cdf_squeeze");
}

EXPORT int
cdf_is_simple(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_is_simple->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_is_simple_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_is_simple, z, l, r, L"cdf_is_simple");
}

EXPORT int
cdf_is_numeric(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_is_numeric->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_is_numeric_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_is_numeric, z, l, r, L"cdf_is_numeric");
}

EXPORT int
cdf_is_char(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_is_char->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_is_char_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_is_char, z, l, r, L"cdf_is_char");
}

EXPORT int
cdf_is_integer(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_is_integer->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_is_integer_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_is_integer, z, l, r, L"cdf_is_integer");
}

EXPORT int
cdf_is_bool(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_is_bool->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_is_bool_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_is_bool, z, l, r, L"cdf_is_bool");
}

EXPORT int
cdf_is_span(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_is_span->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_is_span_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_is_span, z, l, r, L"cdf_is_span");
}

EXPORT int
cdf_max_shp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_max_shp->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_max_shp_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_max_shp, z, l, r, L"cdf_max_shp");
}

EXPORT int
cdf_has_nat_vals(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_has_nat_vals->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_has_nat_vals_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_has_nat_vals, z, l, r, L"cdf_has_nat_vals");
}

EXPORT int
cdf_chk_scl(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_chk_scl->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_chk_scl_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_chk_scl, z, l, r, L"cdf_chk_scl");
}

EXPORT int
cdf_both_simple(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_both_simple->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_both_simple_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_both_simple, z, l, r, L"cdf_both_simple");
}

EXPORT int
cdf_both_numeric(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_both_numeric->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_both_numeric_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_both_numeric, z, l, r, L"cdf_both_numeric");
}

EXPORT int
cdf_both_integer(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_both_integer->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_both_integer_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_both_integer, z, l, r, L"cdf_both_integer");
}

EXPORT int
cdf_both_char(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_both_char->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_both_char_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_both_char, z, l, r, L"cdf_both_char");
}

EXPORT int
cdf_both_bool(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_both_bool->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_both_bool_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_both_bool, z, l, r, L"cdf_both_bool");
}

EXPORT int
cdf_any(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_any->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_any_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_any, z, l, r, L"cdf_any");
}

EXPORT int
cdf_chk_valid_shape(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_chk_valid_shape->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_chk_valid_shape_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_chk_valid_shape, z, l, r, L"cdf_chk_valid_shape");
}

EXPORT int
cdf_reshape(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_reshape;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_reshape_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_reshape, z, l, r, L"cdf_reshape");
}

EXPORT int
cdf_rho(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_rho;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_rho_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_rho, z, l, r, L"cdf_rho");
}

EXPORT int
cdf_idx_rnk_check(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_idx_rnk_check->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_idx_rnk_check_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_idx_rnk_check, z, l, r, L"cdf_idx_rnk_check");
}

EXPORT int
cdf_idx_rng_check(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_idx_rng_check->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_idx_rng_check_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_idx_rng_check, z, l, r, L"cdf_idx_rng_check");
}

EXPORT int
cdf_flatten_idx(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_flatten_idx->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_flatten_idx_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_flatten_idx, z, l, r, L"cdf_flatten_idx");
}

EXPORT int
cdf_idx_shp_check(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_idx_shp_check->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_idx_shp_check_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_idx_shp_check, z, l, r, L"cdf_idx_shp_check");
}

EXPORT int
cdf_set(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_set;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_set_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_set, z, l, r, L"cdf_set");
}

EXPORT int
cdf_sqd(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_sqd;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_sqd_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_sqd, z, l, r, L"cdf_sqd");
}

EXPORT int
cdf_brk(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_brk;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_brk_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_brk, z, l, r, L"cdf_brk");
}

EXPORT int
cdf_rgt(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_rgt;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_rgt_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_rgt, z, l, r, L"cdf_rgt");
}

EXPORT int
cdf_lft(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_lft;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_lft_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_lft, z, l, r, L"cdf_lft");
}

EXPORT int
cdf_cat(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_cat;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_cat_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_cat, z, l, r, L"cdf_cat");
}

EXPORT int
cdf_ctf(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_ctf;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_ctf_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_ctf, z, l, r, L"cdf_ctf");
}

EXPORT int
cdf_depth(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_depth;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_depth_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_depth, z, l, r, L"cdf_depth");
}

EXPORT int
cdf_same(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_same->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_same_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_same, z, l, r, L"cdf_same");
}

EXPORT int
cdf_eqv(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_eqv;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_eqv_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_eqv, z, l, r, L"cdf_eqv");
}

EXPORT int
cdf_nqv(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_nqv;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_nqv_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_nqv, z, l, r, L"cdf_nqv");
}

EXPORT int
cdf_index_gen(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_index_gen;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_index_gen_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_index_gen, z, l, r, L"cdf_index_gen");
}

EXPORT int
cdf_index_of(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_index_of;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_index_of_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_index_of, z, l, r, L"cdf_index_of");
}

EXPORT int
cdf_iot(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_iot;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_iot_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_iot, z, l, r, L"cdf_iot");
}

EXPORT int
cdf_dis(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_dis;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_dis_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_dis, z, l, r, L"cdf_dis");
}

EXPORT int
cdf_enclose(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_enclose;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_enclose_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_enclose, z, l, r, L"cdf_enclose");
}

EXPORT int
cdf_par(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_par;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_par_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_par, z, l, r, L"cdf_par");
}

EXPORT int
cdf_conjugate(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_conjugate;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_conjugate_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_conjugate, z, l, r, L"cdf_conjugate");
}

EXPORT int
cdf_add(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_add;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_add_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_add, z, l, r, L"cdf_add");
}

EXPORT int
cdf_sub(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_sub;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_sub_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_sub, z, l, r, L"cdf_sub");
}

EXPORT int
cdf_sign(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_sign;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_sign_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_sign, z, l, r, L"cdf_sign");
}

EXPORT int
cdf_mul(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_mul;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_mul_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_mul, z, l, r, L"cdf_mul");
}

EXPORT int
cdf_div(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_div;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_div_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_div, z, l, r, L"cdf_div");
}

EXPORT int
cdf_absolute(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_absolute;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_absolute_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_absolute, z, l, r, L"cdf_absolute");
}

EXPORT int
cdf_residue(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_residue;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_residue_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_residue, z, l, r, L"cdf_residue");
}

EXPORT int
cdf_res(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_res;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_res_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_res, z, l, r, L"cdf_res");
}

EXPORT int
cdf_floor_array(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_floor_array;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_floor_array_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_floor_array, z, l, r, L"cdf_floor_array");
}

EXPORT int
cdf_min(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_min;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_min_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_min, z, l, r, L"cdf_min");
}

EXPORT int
cdf_ceil_array(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_ceil_array;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_ceil_array_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_ceil_array, z, l, r, L"cdf_ceil_array");
}

EXPORT int
cdf_max(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_max;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_max_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_max, z, l, r, L"cdf_max");
}

EXPORT int
cdf_exp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_exp;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_exp_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_exp, z, l, r, L"cdf_exp");
}

EXPORT int
cdf_log(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_log;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_log_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_log, z, l, r, L"cdf_log");
}

EXPORT int
cdf_pitimes(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_pitimes;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_pitimes_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_pitimes, z, l, r, L"cdf_pitimes");
}

EXPORT int
cdf_trig(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_trig;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_trig_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_trig, z, l, r, L"cdf_trig");
}

EXPORT int
cdf_cir(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_cir;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_cir_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_cir, z, l, r, L"cdf_cir");
}

EXPORT int
cdf_binomial(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_binomial;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_binomial_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_binomial, z, l, r, L"cdf_binomial");
}

EXPORT int
cdf_fac(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_fac;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_fac_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_fac, z, l, r, L"cdf_fac");
}

EXPORT int
cdf_notscl(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_notscl;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_notscl_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_notscl, z, l, r, L"cdf_notscl");
}

EXPORT int
cdf_without(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_without;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_without_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_without, z, l, r, L"cdf_without");
}

EXPORT int
cdf_not(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_not;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_not_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_not, z, l, r, L"cdf_not");
}

EXPORT int
cdf_logand(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_logand;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_logand_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_logand, z, l, r, L"cdf_logand");
}

EXPORT int
cdf_and(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_and;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_and_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_and, z, l, r, L"cdf_and");
}

EXPORT int
cdf_logor(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_logor;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_logor_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_logor, z, l, r, L"cdf_logor");
}

EXPORT int
cdf_lor(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_lor;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_lor_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_lor, z, l, r, L"cdf_lor");
}

EXPORT int
cdf_nan(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_nan;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_nan_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_nan, z, l, r, L"cdf_nan");
}

EXPORT int
cdf_nor(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_nor;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_nor_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_nor, z, l, r, L"cdf_nor");
}

EXPORT int
cdf_lessthan(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_lessthan;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_lessthan_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_lessthan, z, l, r, L"cdf_lessthan");
}

EXPORT int
cdf_lth(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_lth;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_lth_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_lth, z, l, r, L"cdf_lth");
}

EXPORT int
cdf_lesseql(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_lesseql;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_lesseql_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_lesseql, z, l, r, L"cdf_lesseql");
}

EXPORT int
cdf_lte(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_lte;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_lte_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_lte, z, l, r, L"cdf_lte");
}

EXPORT int
cdf_eql_vec(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_eql_vec->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_eql_vec_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_eql_vec, z, l, r, L"cdf_eql_vec");
}

EXPORT int
cdf_equal(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_equal;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_equal_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_equal, z, l, r, L"cdf_equal");
}

EXPORT int
cdf_eql(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_eql;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_eql_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_eql, z, l, r, L"cdf_eql");
}

EXPORT int
cdf_greatereql(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_greatereql;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_greatereql_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_greatereql, z, l, r, L"cdf_greatereql");
}

EXPORT int
cdf_gte(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_gte;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_gte_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_gte, z, l, r, L"cdf_gte");
}

EXPORT int
cdf_greaterthan(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_greaterthan;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_greaterthan_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_greaterthan, z, l, r, L"cdf_greaterthan");
}

EXPORT int
cdf_gth(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_gth;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_gth_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_gth, z, l, r, L"cdf_gth");
}

EXPORT int
cdf_firstocc(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_firstocc;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_firstocc_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_firstocc, z, l, r, L"cdf_firstocc");
}

EXPORT int
cdf_neq_vec(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_neq_vec->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_neq_vec_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_neq_vec, z, l, r, L"cdf_neq_vec");
}

EXPORT int
cdf_noteq(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_noteq;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_noteq_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_noteq, z, l, r, L"cdf_noteq");
}

EXPORT int
cdf_neq(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_neq;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_neq_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_neq, z, l, r, L"cdf_neq");
}

EXPORT int
cdf_mix(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_mix;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_mix_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_mix, z, l, r, L"cdf_mix");
}

EXPORT int
cdf_take(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_take;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_take_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_take, z, l, r, L"cdf_take");
}

EXPORT int
cdf_tke(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_tke;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_tke_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_tke, z, l, r, L"cdf_tke");
}

EXPORT int
cdf_drp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_drp;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_drp_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_drp, z, l, r, L"cdf_drp");
}

EXPORT int
cdf_rtf(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_rtf;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_rtf_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_rtf, z, l, r, L"cdf_rtf");
}

EXPORT int
cdf_reverse_last(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_reverse_last;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_reverse_last_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_reverse_last, z, l, r, L"cdf_reverse_last");
}

EXPORT int
cdf_rotate_last(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_rotate_last;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_rotate_last_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_rotate_last, z, l, r, L"cdf_rotate_last");
}

EXPORT int
cdf_rot(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_rot;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_rot_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_rot, z, l, r, L"cdf_rot");
}

EXPORT int
cdf_trn(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_trn;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_trn_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_trn, z, l, r, L"cdf_trn");
}

EXPORT int
cdf_gdu(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_gdu;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_gdu_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_gdu, z, l, r, L"cdf_gdu");
}

EXPORT int
cdf_gdd(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_gdd;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_gdd_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_gdd, z, l, r, L"cdf_gdd");
}

EXPORT int
cdf_enc(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_enc;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_enc_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_enc, z, l, r, L"cdf_enc");
}

EXPORT int
cdf_dec(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_dec;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_dec_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_dec, z, l, r, L"cdf_dec");
}

EXPORT int
cdf_mem(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_mem;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_mem_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_mem, z, l, r, L"cdf_mem");
}

EXPORT int
cdf_fnd(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_fnd;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_fnd_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_fnd, z, l, r, L"cdf_fnd");
}

EXPORT int
cdf_unq(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_unq;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_unq_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_unq, z, l, r, L"cdf_unq");
}

EXPORT int
cdf_int(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_int;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_int_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_int, z, l, r, L"cdf_int");
}

EXPORT int
cdf_deal(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_deal;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_deal_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_deal, z, l, r, L"cdf_deal");
}

EXPORT int
cdf_roll(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_roll;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_roll_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_roll, z, l, r, L"cdf_roll");
}

EXPORT int
cdf_rol(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_rol;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_rol_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_rol, z, l, r, L"cdf_rol");
}

EXPORT int
cdf_mdv(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_mdv;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_mdv_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_mdv, z, l, r, L"cdf_mdv");
}

EXPORT int
cdf_red_check(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_red_check->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_red_check_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_red_check, z, l, r, L"cdf_red_check");
}

EXPORT int
cdf_rpf(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_rpf;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_rpf_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_rpf, z, l, r, L"cdf_rpf");
}

EXPORT int
cdf_rep(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_rep;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_rep_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_rep, z, l, r, L"cdf_rep");
}

EXPORT int
cdf_xpf(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_xpf;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_xpf_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_xpf, z, l, r, L"cdf_xpf");
}

EXPORT int
cdf_xpd(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cdf_xpd;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cdf_xpd_dwa(void *z, void *l, void *r)
{
	return call_dwa(cdf_xpd, z, l, r, L"cdf_xpd");
}

